# Autores
* Luis Alfonso Huertas Delgado
* Miguel Jara Arroyo
* Pedro del Castillo Gómez
* Jorge del Castillo Gómez
# Índice
- [Índice](#índice)
- [Introduccion <a name="introduction"></a>](#introduccion-)
- [Propuesta inicial <a name="propuestaInicial"></a>](#propuesta-inicial-)
  - [Descripción de la idea <a name="descripcionDeLaIdea"></a>](#descripción-de-la-idea-)
    - [Público objetivo <a name="publicoObjetivo"></a>](#Público-objetivo-)
- [Funcionalidades principales <a name="funcionalidadesprincipales"></a>](#funcionalidades-principales-)
- [Análisis <a name="analisis"></a>](#análisis-)
  - [Casos de uso estructurales <a name="casosdeusoestructurales"></a>](#casos-de-uso-estructurales-)
  - [Casos de uso no estructurales <a name="casosdeusonoestructurales"></a>](#casos-de-uso-no-estructurales-)
  - [Conjuntos de casos de uso <a name="conjuntosdecasosdeuso"></a>](#conjuntos-de-casos-de-uso-)
  - [Requisitos no funcionales <a name="requisitosNoFuncionales"></a>](#Requisitos-no-funcionales-)
- [Metodologías de desarrollo <a name="metodologiasdedesarrollo"></a>](#metodologías-de-desarrollo-)
  - [Proceso de desarrollo <a name="procesodedesarrollo"></a>](#proceso-de-desarrollo-)
  - [Planificación del proyecto <a name="planificaciondelproyecto"></a>](#planificación-del-proyecto-)
    - [Proceso de planificación <a name="procesodeplanificacion"></a>](#proceso-de-planificación-)
    - [Distribución de casos de uso <a name="distribuciondecasosdeuso"></a>](#distribución-de-casos-de-uso-)
    - [Análisis de la distribución <a name="analisisdeladistribucion"></a>](#análisis-de-la-distribución-)
    - [Planificación del proyecto <a name="planificaciondelproyecto2"></a>](#planificación-del-proyecto--1)
    - [Análisis de la planificación <a name="analisisdelaplanificacion"></a>](#análisis-de-la-planificación-)
      - [Camino Crítico <a name="caminocritico"></a>](#camino-crítico-)
  - [Configuración del seguimiento de la planificación <a name="configSeguimientoPlan"></a>](#Configuración-del-seguimiento-de-la-planificación-)
    - [Señor Blanco (Equipo 1) <a name="señorBlanco"></a>](#señor-blanco-equipo-1-)
      - [Proceso seguido <a name="procesoSeguidoBlanco"></a>](#proceso-seguido-)
      - [Análisis del progreso <a name="analisisProgresoBlanco"></a>](#análisis-del-progreso-)
    - [Señor Marrón (Equipo 2) <a name="señorMarron"></a>](#señor-marrón-equipo-2-)
      - [Proceso seguido <a name="procesoSeguidoMarron"></a>](#proceso-seguido--1)
      - [Análisis del progreso <a name="analisisProgresoMarron"></a>](#análisis-del-progreso--1)
    - [Señor Naranja (Equipo 3) <a name="señorNaranja"></a>](#señor-naranja-equipo-3-)
      - [Proceso seguido <a name="procesoSeguidoNaranja"></a>](#proceso-seguido--2)
      - [Análisis del progreso <a name="analisisProgresoNaranja"></a>](#análisis-del-progreso--2)
      - [Proporción de Épicas, Tareas y Subtareas <a name="analisisGraficoNaranja"></a>](#proporci%C3%B3n-de-%C3%A9picas-tareas-y-subtareas--1)
    - [Señor Azul (Equipo 4) <a name="señorAzul"></a>](#señor-azul-equipo-4-)
      - [Proceso seguido <a name="procesoSeguidoAzul"></a>](#proceso-seguido--3)
      - [Análisis del progreso <a name="analisisProgresoAzul"></a>](#análisis-del-progreso--3)
      - [Proporción de tareas por caso de uso <a name="analisisGraficoAzul"></a>](#proporci%C3%B3n-de-tareas-por-caso-de-uso-)
    - [Proporción de Épicas, Tareas y Subtareas <a name="analisisGraficoNaranja"></a>](#proporci%C3%B3n-de-%C3%A9picas-tareas-y-subtareas--1)
    - [Proporción de tareas por caso de uso <a name="analisisGraficoAzul"></a>](#proporci%C3%B3n-de-tareas-por-caso-de-uso-)
    - [Contribución de los líderes de equipo <a name="contribucionBlanco"></a>](#contribuci%C3%B3n-de-los-l%C3%ADderes-de-equipo-)
  - [Progreso del proyecto <a name="desarrolloProgreso"></a>](#Progreso-del-proyecto-)
    - [Síntesis de la planificación por roles <a name="sintesisPlanificacion"></a>](#Síntesis-de-la-planificación-por-roles-)
    - [Proceso seguido del Equipo 1 (Sr. Blanco) <a name="desarrolloEquipo1"></a>](#Proceso-seguido-del-Equipo-1-Sr-Blanco-)
    - [Proceso seguido del Equipo 2 (Sr. Marrón) <a name="desarrolloEquipo2"></a>](#Proceso-seguido-del-Equipo-2-Sr-Marrón-)
    - [Proceso seguido del Equipo 3 (Sr. Naranja) <a name="desarrolloEquipo3"></a>](#Proceso-seguido-del-Equipo-3-Sr-Naranja-)
    - [Proceso seguido del Equipo 4 (Sr. Azul) <a name="desarrolloEquipo4"></a>](#Proceso-seguido-del-Equipo-4-Sr-Azul-)
    - [Análisis del progreso <a name="analisisProgreso2"></a>](#Análisis-del-progreso--4)
- [Diseño de la interfaz de usuario <a name="diseñoInterfazUsuario"></a>](#Diseño-de-la-interfaz-de-usuario-)
  - [Mapa de Navegación: pantallas, patrones y diagrama <a name="mapaNavegacion"></a>](#Mapa-de-Navegación-pantallas-patrones-y-diagrama-)
    - [Diagrama de casos de uso <a name="diagramaCasosdeUso"></a>](#Diagrama-de-casos-de-uso-)
    - [Diagrama de navegación <a name="diagramadeNavegacion"></a>](#Diagrama-de-navegación-)
    - [Mockup <a name="Mockup"></a>](#Mockup-)
    - [Grafo de navegación <a name="grafodeNavegacion"></a>](#Grafo-de-navegación-)
    - [Patrones de navegación aplicados <a name="patronesNavegacion"></a>](#Patrones-de-navegación-aplicados-)
- [Diseño arquitectónico <a name="diseñoArquitectonico"></a>](#Diseño-arquitectónico-)
  - [Diagrama e interacción de componentes <a name="diagramaComponentes"></a>](#Diagrama-e-interacción-de-componentes-)
  - [Patrones arquitectónicos <a name="patronesArquitectonicos"></a>](#Patrones-arquitectónicos-)
- [Gestión del entorno <a name="gestionEntorno"></a>](#Gestión-del-entorno-)
  - [Gestión de la configuración <a name="gestionConfiguracion"></a>](#Gestión-de-la-configuración-)
    - [Entorno utilizado <a name="entornoUtilizado"></a>](#Entorno-utilizado-)
      - [Herramienta de implementación: Android Studio <a name="androidStudio"></a>](#Herramienta-de-implementación-Android-Studio-)
      - [Estructura de un proyecto en Android Studio <a name="estructuraProyecto"></a>](#Estructura-de-un-proyecto-en-Android-Studio-)
      - [Componentes de la interfaz de Android Studio <a name="componentesInterfaz"></a>](#Componentes-de-la-interfaz-de-Android-Studio-)
      - [Funcionamiento de una App en Android Studio <a name="funcionamientoApp"></a>](#Funcionamiento-de-una-App-en-Android-Studio-)
      - [Compilación en Gradle <a name="compilacionGradle"></a>](#Compilación-en-Gradle-)
      - [Integración de Jira en Android Studio <a name="integracionContextJira"></a>](#integraci%C3%B3n-de-jira-en-android-studio-)
        - [Integración de Jira en Android Studio a través de la herramienta de contexto <a name="integracionContextJira"></a>](#integraci%C3%B3n-de-jira-en-android-studio-a-trav%C3%A9s-de-la-herramienta-de-contexto-)
        - [Integración de Jira en Android Studio a través de un plugin <a name="integracionPluginJira"></a>](#integraci%C3%B3n-de-jira-en-android-studio-a-trav%C3%A9s-de-un-plugin-)
      - [Ramas utilizadas en el proyecto <a name="ramas"></a>](#Ramas-utilizadas-en-el-proyecto-)
  - [Integración continua <a name="integracionContinua"></a>](#Integración-continua-)
- [Implementación <a name="implementacion"></a>](#Implementación-)
  - [Estructura del proyecto <a name="estructura"></a>](#Estructura)
  - [Modelo de datos <a name="modeloDatos"></a>](#Modelo-de-datos-)
  - [Detalles de implementación <a name="detallesImplementacion"></a>](#Detalles-de-implementación-)
    - [Patrones de Diseño <a name="patronesDiseño"></a>](#Patrones-de-Diseño-)
    - [Refactorización <a name="refactorización "></a>](#Refactorización-)
    - [Aspectos novedosos y decisiones tomadas <a name="aspectosNovedosos"></a>](#Aspectos-novedosos-y-decisiones-tomadas-)
      - [Gestión de la API <a name="gestionAPI"></a>](#Gestión-de-la-API-)
      - [Obtención de localización <a name="obtencionLocalizacion"></a>](#Obtención-de-localización-)
      - [Gestión de Permisos <a name="gestionPermisos"></a>](#Gestión-de-Permisos-)
      - [Carga de municipios y montañas desde JSON <a name="cargaJSON"></a>](#Carga-de-municipios-y-montañas-desde-JSON-)
      - [Menú de Hamburguesa <a name="menuHamburguesa"></a>](#Menú-de-Hamburguesa-)
      - [Filtro de Eventos <a name="filtroEventos"></a>](#Filtro-de-Eventos-)
      - [Usuario único <a name="usuarioUnico"></a>](#Usuario-único-)
      - [Implementación de Spinners en diversos campos <a name="spinners"></a>](#Implementación-de-Spinners-en-diversos-campos-)
      - [Filtrado de localizaciones <a name="filtradoLocalizaciones"></a>](#Filtrado-de-localizaciones-)
      - [Modo Oscuro <a name="modoOscuro"></a>](#Modo-Oscuro-)
- [Gestión de la calidad del Software <a name="gestionCalidadSoftware"></a>](#Gestión-de-la-calidad-del-Software-)
  - [Pruebas implementadas <a name="pruebasImplementadas"></a>](#Pruebas-implementadas-)
    - [Equipo 1 (Señor Blanco) <a name="testEquipo1"></a>](#Equipo-1-Señor-Blanco-)
    - [Equipo 2 (Señor Marrón) <a name="testEquipo2"></a>](#Equipo-2-Señor-Marrón-)
    - [Equipo 3 (Señor Naranja) <a name="testEquipo3"></a>](#Equipo-3-Señor-Naranja-)
    - [Equipo 4 (Señor Azul) <a name="testEquipo4"></a>](#Equipo-4-Señor-Azul-)
    - [Arreglo de errores <a name="arregloErrores"></a>](#Arreglo-de-errores-)
  - [Análisis de la calidad <a name="gestionCalidad"></a>](#Análisis-de-la-calidad-)
    - [Características de SonarCloud <a name="caracteristicasSonarCloud"></a>](#Características-de-SonarCloud-)
    - [Pasos para gestionar la calidad <a name="pasosGestionCalidad"></a>](#Pasos-para-gestionar-la-calidad-)
    - [Repositorios utilizados <a name="repositoriosUtilizados"></a>](#Repositorios-utilizados-)
    - [Detección de fallos <a name="calidadGestionFallos"></a>](#Detección-de-fallos-)
    - [Problemas solventados <a name="problemasSolventados"></a>](#Problemas-solventados-)
      - [Análisis del Sr. Blanco <a name="calidadSrBlanco"></a>](#Análisis-del-Sr-Blanco-)
      - [Análisis del Sr. Marrón <a name="calidadSrMarron"></a>](#Análisis-del-Sr-Marrón-)
      - [Análisis del Sr. Azul <a name="calidadSrAzul"></a>](#Análisis-del-Sr-Azul-)
      - [Análisis del Sr. Naranja <a name="calidadSrNaranja"></a>](#Análisis-del-Sr-Naranja-)
- [Reflexión <a name="reflexion"></a>](#Reflexión-)      

# Introduccion <a name="introduction"></a>

**Motivación**

<p>

En los últimos años, la plataforma Android ha gobernado notablemente el mercado móvil, de tal manera que iOS nunca ha sido capaz de recuperar el status con el que se inició en el “mundillo” tecnológico. Además, junto con el crecimiento exponencial del “Big Data”, apareció un nuevo formato de aplicaciones móviles que accedían a grandes cantidades de datos. Como consecuencia,  los servicios que proporcionaban grandes fuentes de datos debían incorporar la forma de brindar datos con un acceso libre y seguro, conocido como “Open Data”. 
</p>

<p>
En cuanto al nicho de mercado, apenas existen propuestas novedosas de aplicaciones meteorológicas, puesto que la mayoría de dispositivos Android incorporan estas aplicaciones de fábrica. Del mismo modo, los usuarios no parecen ser tan exigentes con este tipo de aplicaciones al ser conformistas con lo que disponen. 
</p>

<p>
Hoy en día, las aplicaciones móviles no se centran únicamente en una tarea, sino que aglutinan diversas funcionalidades relacionadas entre sí. Por otro lado, el hardware móvil ha evolucionado hasta tal punto en que los desarrolladores tienen un gran abanico de opciones para desarrollar una IU con una alta usabilidad y accesibilidad.
</p>


**Objetivos**

<p>

El propósito del equipo de desarrollo es afianzar conocimientos: cómo utilizar Android Studio, cómo tratar el gran flujo de información devuelto por la API y la forma en la que se presentan los datos al usuario.  Asimismo, se va a focalizar en el diseño de la interfaz de usuario, haciéndola atractiva, novedosa y cumpliendo los requisitos de usabilidad y accesibilidad. Se pretende aportar al mercado un servicio de buena calidad a primera vista.
</p>


**Resumen**
<p>

En los siguientes apartados, hablaremos de la propuesta inicial del proyecto con una descripción y su funcionalidad inicial. A continuación, se detalla el marco de desarrollo, en otras palabras, la planificación y el proceso seguido para cumplir con los objetivos propuestos. La metodología empleada por el equipo es el “Proceso Unificado”, un marco de desarrollo iterativo e incremental basado en casos de uso y centrado en la arquitectura del sistema.  Por último, se presentará el funcionamiento interno de la aplicación, así como los mockup (interfaz de usuario primigenia) y la navegación entre las diferentes pantallas.
</p>

<p>&nbsp;</p>


# Propuesta inicial <a name="propuestaInicial"></a>


## Descripción de la idea <a name="descripcionDeLaIdea"></a>
<p>
El objetivo principal de este trabajo es el desarrollo de una aplicación móvil Android llamada <b>KikoGaku (en japones, Climatología)</b> centrada en la visualización del tiempo meteorológico de una localización en España, dicha información proporcionada por la API de AEMET. 
</p>
</p>El usuario puede crear eventos personalizados ligados a una ubicación, los cuales tendrán asignado las condiciones meteorológicas a tiempo real en dicha localización. De igual importancia, se favorece la interacción de los usuarios con el medio ambiente, permitiéndoles crear eventos tanto en municipios como en montañas.
<p>


### Público objetivo <a name="publicoObjetivo"></a>
En este apartado, se especifica a qué público va dirigida nuestra aplicación mediante estudios y gráficas. Antes de adentrarnos en el “quid” de la cuestión, cabe destacar el motivo por el que se ha elegido Android como plataforma sobre la que se implementa la aplicación. Según [StatCounter](https://statcounter.com/), Android ha dominado el 70% de la cuota de mercado por delante de iOS en creces, como se muestra en la siguiente gráfica:

<img src="https://i.imgur.com/WW9jHmJ.png"/>

Asimismo, no es una sorpresa que Android gobierne el mercado de dispositivos móviles. Según Google, el número de usuarios con dispositivos Android ha aumentado notablemente. En la siguiente tabla, se especifica la evolución de los usuarios activos durante los últimos años en billones como unidad.

<img src="https://i.imgur.com/m1Ke0H4.png"/>


**¿A quién va dirigido?**

La  categoría  de  apps  del tiempo  son  el  0,4%  del  total, con más de 11.500 disponibles y  un  promedio  de  valoración de 4,0 (frente al 4,1 del resto de categorías  contando  solo  las apps  con  más  de  100  valoraciones). El 12% de las apps del tiempo se han descargado más de 50.000 veces (9,5% de media  para  el  resto  de  apps).

Además dentro de la tienda Play Store de Google, la aplicaciones del tiempo estando dentro de las categorías más usadas, es la que atrae al menor número de usuarios, como se puede ver en el siguiente enlace,  el 32% de los usuarios se descarga una aplicación climatológica:
[Estadísticas para este 2022 en la tienda de Google Play](https://appsrentables.com/estadisticas-tienda-google-play/)

Esto es debido a que la totalidad de los dispositivos android ya vienen instalados con una aplicación climatológica, esto deriva en que solo los usuarios que quieren una experiencia mejor que a la que les dan sus dispositivos buscan una alternativa a la aplicación preinstalada, estos usuarios no buscan una aplicación que les diga el tiempo sin más, sino que además buscan funcionalidades extras y podríamos decir que son un tipo de usuarios que buscan una aplicación climatológica más específica.

Es por esto que el **prototipo de usuario** al que ya he dirigido nuestra aplicación será fundamentalmente una persona mayor de edad, entre los 18 y 50 años, la cual realice actividades o eventos de una manera regular, y que sea importante para dichos eventos conocer la situación meteorológica de la ubicación en la que se producen, como por ejemplo eventos deportivos, bodas y banquetes al aire libre, etc.

# Funcionalidades principales <a name="funcionalidadesprincipales"></a>


<p>
Para poder utilizar las diferentes funcionalidades de la aplicación, un usuario debe registrarse con unas credenciales. Una vez se registre e inicie sesión, podrá :

<ul>
    <li>En la pantalla principal, visualizar el tiempo meteorológico de la ubicación actual del dispositivo.
    </li>
    <li>Visualizar el listado de eventos en municipios o montañas  creados por el usuario.
    </li>
    <li>Gestionar un evento, así como su creación, edición y borrado, mediante las preferencias (fecha, nombre, descripción, color, ubicación, etc).
    </li>
    <li>Consultar en detalle el tiempo meteorológico de una ubicación específica.
    </li>
    <li>Editar los datos personales y borrar la cuenta de usuario.
    </li>
</ul>
</p>
<p>&nbsp;</p>

# Análisis <a name="analisis"></a>
En este apartado, se profundiza sobre aspectos esenciales de la propuesta inicial del proyecto, así como los requisitos funcionales y no funcionales. 


## Casos de uso estructurales <a name="casosdeusoestructurales"></a>

<ul>
    <li>CU-01: Añadir Evento de Municipio.
    </li>
    <li>CU-02: Añadir Evento de Ruta Montaña.
    </li>
    <li>CU-03: Añadir Usuario.
    </li>
    <li>CU-04: Añadir una barra de búsqueda y filtrado de ubicaciones.
    </li>
    <li>CU-05: Añadir preferencias desde el menú de AppBar (ajustes …)
    </li>
</ul>


## Casos de uso no estructurales <a name="casosdeusonoestructurales"></a>

<ul>
    <li>CU-06: Consultar el tiempo detallado de una ubicación.
    </li>
    <li>CU-07: Modificar un evento.
    </li>
    <li>CU-08: Eliminar un evento.
    </li>
    <li>CU-09: Consultar tiempo meteorológico en la ubicación actual
    </li>
    <li>CU-10: Modificar idioma y tema a modo oscuro
    </li>
    <li>CU-11: Consultar lista de eventos.
    </li>
    <li>CU-12: Consultar un evento.
    </li>
    <li>CU-13: Iniciar sesión.
    </li>
    <li>CU-14: Cerrar sesión.
    </li>
    <li>CU-15: Modificar usuario.
    </li>
    <li>CU-16: Eliminar usuario.
    </li>
</ul>

## Conjuntos de casos de uso <a name="conjuntosdecasosdeuso"></a>

| ID | Nombre | Descripción | 
|----|---|---|
|CU-01|Añadir Evento de Municipio.|El usuario podrá añadir un nuevo evento de municipio en una fecha determinada, estando asignado a una condición meteorológica en tiempo real de la ubicación del municipio.|
|CU-02|Añadir Evento de Ruta Montaña.|El usuario podrá añadir un nuevo evento de montaña en una fecha determinada, estando asignado a una condición meteorológica en tiempo real de la ubicación de la montaña.|
|CU-03|Añadir Usuario.|El sistema permite al usuario registrarse con unas credenciales.|
|CU-04|Añadir una barra de búsqueda y filtrado de ubicaciones.|El sistema deberá incorporar una barra de búsqueda para buscar una ubicación con su tiempo meteorológico asignado.|
|CU-05|Añadir preferencias desde el menú de AppBar (ajustes …)|El sistema deberá incorporar un apartado de configuración que permite al usuario personalizar su experiencia con la aplicación, así como el modo oscuro, preferencias, etc.|
|CU-06|Consultar el tiempo detallado de una ubicación.|El usuario podrá visualizar el tiempo meteorológico de una ubicación específica en tiempo real.|
|CU-07|Modificar un evento.|El usuario podrá modificar los datos de un evento, así como su nombre, descripción, fecha y ubicación.|
|CU-08|Eliminar un evento.|El usuario podrá borrar un evento creado y configurado previamente en la lista de eventos.|
|CU-09|Consultar el tiempo meteorológico en la ubicación actual.|El usuario podrá consultar los detalles del tiempo asociado a la localización/municipio más cercano.|
|CU-10|Modificar idioma y tema a modo oscuro.|El usuario podrá realizar una serie de modificaciones en la aplicación para configurar esta a su gusto como cambiar el idioma, el tema a modo oscuro, etc.|
|CU-11|Consultar lista de eventos.|El usuario podrá visualizar el listado completo de eventos de municipios y montañas creados por su parte.|
|CU-12|Consultar un evento.|El usuario podrá visualizar en detalle los datos pertinentes de un evento de municipio o montaña.|
|CU-13|Iniciar sesión.|El sistema permite iniciar sesión con las credenciales asociadas a su cuenta de usuario.|
|CU-14|Cerrar sesión.|El sistema permite cerrar sesión a un usuario.|
|CU-15|Modificar usuario.|El usuario podrá modificar su nombre de usuario, contraseña asociadas a su cuenta en un apartado “perfil”.| 
|CU-16|Eliminar usuario.|En el apartado “perfil”, el usuario podrá eliminar su cuenta de la aplicación y cerrar sesión.|


## Requisitos no funcionales <a name="requisitosNoFuncionales"></a>
Los requisitos no funcionales son aquellos que no hacen referencia a las funciones específicas del sistema, sino a las propiedades que este debe satisfacer. Suponen restricciones en su implementación. Para su definición vamos a agruparlos en varias categorías:

1. **Usabilidad**: Característica relacionada con el modo de interacción entre el usuario y la aplicación. 
> * **RNF 1**: La aplicación debe estar diseñada de manera que se adapte a la resolución al tamaño de pantalla de cualquier dispositivo móvil.
> * **RNF 2**: Los usuarios habituados a las aplicaciones meteorológicas deben entender al instante el funcionamiento de la aplicación. El tiempo para una persona no habituada no debe ser superior a 5 minutos. 
> * **RNF 3**: La aplicación debe seguir los patrones establecidos por Google Material Design. 
> * **RNF 4**: El sistema proporcionará feedback constante al usuario durante el uso de la aplicación, bien informando de un error o confirmando una acción realizada. 
> * **RNF 5**: Para aquellas tareas que no finalicen inmediatamente se deberá mostrar una barra de progreso que informe de su estado actual. 
> * **RNF 6**: La aplicación debe ser apta para usuarios de habla inglesa o español, y permitir una fácil adaptación a cualquier otro idioma.


2. **Eficiencia**: Capacidad para realizar adecuadamente una función. 
> * **RNF 7**: La aplicación no debe tardar más de 3 segundos en iniciarse. 
> * **RNF 8**: No demorar más de 6 segundos en la carga de información con las predicciones meteorológicas tras haber seleccionado una localidad, para que el usuario no se desespere. 


3. **Consistencia**: Característica que define a algo sólido y estable. 
> * **RNF 9**: La aplicación no debe bloquearse en ningún momento mientras se esté utilizando.


4. **Integridad**: Capacidad para mostrar algo sin ser distorsionado.
> * **RNF 10**: La información mostrada debe ser auténtica y coherente con los datos que la Agencia Española de Meteorología nos proporciona a través de su API.


5. **Mantenibilidad**: Facilidad para ser modificado. 
> * **RNF 11**: El código de la aplicación debe estar bien estructurado, utilizando patrones arquitectónicos, de modo que si hay que añadir o corregir alguna funcionalidad tardemos el menor tiempo posible en solucionarlo.


6. **Compatibilidad**: Cualidad de un elemento que le permite poder trabajar con otro correctamente. 
> * **RNF 12**: Se espera que la aplicación sea compatible con el 85% de los dispositivos móviles existentes que utilicen Android, para ello usará la versión de Android 6.0.


7. **Disponibilidad**: Probabilidad de que la aplicación falle.
> * **RNF 13**: Se espera que la aplicación se encuentre disponible al menos el 99,95% de las veces que sean utilizadas por los usuarios, teniendo una probabilidad de fallo de como máximo un 0,05%.


8. **Seguridad**: Capacidad que tiene la aplicación de proteger a sus usuarios.
> * **RNF 14**: Se espera que la aplicación garantice la privacidad de los datos del usuario frente a amenazas externas de robo de datos o pérdida de estos gracias a mecanismos como el respaldo de estos mediante una copia de seguridad periódica y la restricción a su acceso a únicamente el administrador.

<p>&nbsp;</p>

# Metodologías de desarrollo <a name="metodologiasdedesarrollo"></a>

## Proceso de desarrollo <a name="procesodedesarrollo"></a>

Para llevar a cabo la realización del proyecto se ha utilizado el método denominado como <b>Proceso Unificado</b> (SCRUM), que consiste en una metodología ágil gracias a la cual se pueden desarrollar proyectos pudiendo realizar modificaciones en este fácilmente.
Así mismo, este proceso divide su desarrollo en <b>fases</b> utilizando el concepto de Casos de Uso para representar a los requisitos. Las fases se desarrollarán de forma incremental mediante una serie de <b>iteraciones</b>.
En este proceso, los <b>casos de uso</b> se crean e implementan a través de <b>cuatro fases</b>:
1. <b>Inicio</b>: Se especifica o declara el requisito en concreto, madurando dicha idea hasta un concepto más sólido.
2. <b>Elaboración</b>: El requisito pasa por un proceso de análisis y diseño, que amplían el concepto y cómo se debería implementar.
3. <b>Construcción</b>: El requisito se implementa en código software para ser utilizado en el programa.
4. <b>Transición</b>: Se prueba la versión final del requisito para saber si el código software es correcto, y en caso afirmativo se integra este junto con el resto en el programa. 

## Planificación del proyecto <a name="planificaciondelproyecto"></a>

### Proceso de planificación <a name="procesodeplanificacion"></a>

En la planificación de este proyecto, existirán <b>cuatro roles</b> que influyen de forma distinta la creación de casos de uso. Estos roles son:
1. <b>Jefe de proyecto</b>: Es el encargado principal de gestionar el desarrollo del proyecto.
2. <b>Desarrollador de software Senior</b>: Es un programador de Software relativamente experimentado.
3. <b>Desarrollador de software Junior</b>: Es un programador de software que cuenta con poca experiencia.
4. <b>Arquitecto de software</b>: Es un experto en la Arquitectura de Software, el cual, además de trabajar en la creación de la aplicación, también ayudará al jefe de proyecto con la gestión.

Cada uno de estos roles tendrá que realizar una serie de tareas que les serán asignadas al comienzo del proyecto, las cuales ocupan cierta cantidad de tiempo designada durante la planificación.      

### Distribución de casos de uso <a name="distribuciondecasosdeuso"></a>

[Excel Utilizado para la organización de los CASOS DE USO](https://docs.google.com/spreadsheets/d/1bhTUTApi7z-_fucTtovXuDvmLPavcS8W/edit?usp=sharing&ouid=101170322248995906530&rtpof=true&sd=true)
<p>
Para seguir este proceso, los casos de uso especificados se desarrollan e implementan a lo largo de una serie de iteraciones, las cuales duran una semana, en las que los cuatro roles distinguidos llevarán a cabo una las distintas disciplinas de desarrollo de los casos de uso, además de tareas de gestión del proyecto.
</p>

<p>
Estas disciplinas permitirán marcar la vida de desarrollo de los casos de uso, y estarán relacionados con las cuatro fases existentes en el método de Proceso Unificado. Las disciplinas son las siguientes:
</p>

* Modelado del negocio (Previa al inicio)
* Requisitos (Relacionada con la fase de inicio)
* Análisis y Diseño (Relacionada con la fase de elaboración)
* Implementación (Relacionada con la fase de construcción)
* Test e Integración (Relacionada con la fase de transición)
* Despliegue (Posterior a la transición)

De esta forma, cada rol realiza las siguientes disciplinas:
* Jefe del proyecto: Realiza la disciplina de Modelado del negocio (BM) y también tareas de gestión del proyecto.
* Arquitecto del software: Realiza las disciplinas Requisitos (R), Análisis y Diseño (A&D) e Implementación (Imp). También colaborará en situaciones extraordinarias en la disciplina de Test e Integración (T&I).
* Desarrollador de Software Junior: Realiza las disciplinas de Implementación (Imp), Test e integración (T&I) y Despliegue (D).
* Desarrollador de Software Senior: Realiza las disciplinas de Requisitos (R), Análisis y Diseño (A&D), Implementación (Imp), Test e integración (T&I) y Despliegue (D).

<p>Para resumir y poder visualizar mejor esto, realizamos la siguiente tabla:</p>
<img src="https://i.imgur.com/yItDb6b.png"/>

### Análisis de la distribución <a name="analisisdeladistribucion"></a>

<p>
Para calcular el tiempo total que tendrá disponible cada rol y cada caso de uso en número de horas se tendrá en cuenta una jornada laboral de 8 horas. Trabajando 5 días a la semana y teniendo en cuenta las 7 iteraciones (semanas), con lo que se obtiene la siguiente cantidad de tiempo:
</p>

<img src="https://i.imgur.com/nZJrXfF.png"/>

<p>
Esto nos da que la jornada laboral tiene 280 horas por semana, de las cuales, según la implicación de cada rol en el proyecto se obtiene el tiempo que emplean:

* Jefe del proyecto: **20%**
* Arquitecto del Software: **100%** 
* Desarrollador de software Senior: **100%** 
* Desarrollador de software Junior: **50%** 

Con esto, el tiempo total empleado en el proyecto es de **756 horas**.
</p>

Según las investigaciones proporcionadas por el periódico 
[diarioSevilla](https://www.diariodesevilla.es/canalempleo/espanoles-productivos-jornada-laboral_0_1615338736.html) , en España, existe una estimación de productividad general de un 93% del tiempo trabajado.

<p>
<strong>Tiempo productivo en el proyecto: 93% de 756 h ≈ 703,08 horas</strong>
</p>
<p>Con lo cual contamos con 703,08 horas de trabajo real, de las cuales el <b>15%</b> se dedica a <b>tareas de gestión del proyecto (Tareas de Project)</b>, y el resto del tiempo <b>(85%)</b> a la creación de los casos de uso, por lo que tenemos <b>597,618 horas</b> para realizar todos los casos de uso.
</p>

<img src="https://i.imgur.com/nRQOaHS.png"/>

<p>En esta tabla se pueden observar los <b>porcentajes de tiempo</b> que se van a dedicar a cada uno de los <b>casos de uso</b>.

* Definición de requisitos: 10%
* Análisis y Diseño: 20%
* Implementación: 45%
* Test e Integración: 20%
* Despliegue: 5%
</p>

<p>
El tiempo que tenemos para cada caso de uso es calculado con: <b>Tiempo bruto total / Número de casos de uso</b>
</p>
<p>
De este tiempo, tanto el <b>Jefe del proyecto</b> como el <b>Arquitecto del software</b> emplearán tiempo para las <b>tareas de Modelado de Negocio</b>, lo cual se ha estimado que ocupará un <b>5%</b> del tiempo.

Por lo cual las <b>Tareas de Gestión + Modelado de negocio</b> ocupan un total de:

*105,46 + 29,89 = 135,35 horas.*

Con lo que nos quedan <b>47,31 horas</b> para realizar el resto de fases de los CU.

<img src="https://i.imgur.com/ns2n1ju.png"/>

En la tabla anterior podemos ver que los trabajadores disponen de <b>93 horas semanales</b> para realizar los casos de uso, así como las distintas cantidades de tiempo que dedicará cada rol en el proyecto.
</p>

### Planificación inicial <a name="planificaciondelproyecto2"></a>
<p>
Se ha priorizado que sea el arquitecto de software el que tenga tiempo restante, como se puede ver en cada una de las siguientes tablas, para así dedicárselo a la gestión del proyecto.

El proyecto se desarrollará a lo largo de <b>7 iteraciones</b>, cada una de una semana de duración, las cuales se organizará de la siguiente manera:
</p>

<p>
De esta forma, cada una de las iteraciones se han planificado en función de las distintas <b>fases</b> que pueden realizar cada uno de los <b>roles</b>.
</p>

<p>Con lo cual la planificación por iteración quedaría de la siguiente manera:
</p>
<p>&nbsp;</p>

🔸 **Fase de Inicio**
<p>&nbsp;</p>
<img src="https://i.imgur.com/8yYq7dM.png"/>
<p>&nbsp;</p>

🔸 **Fase de Elaboración**
<p>&nbsp;</p>
<img src="https://i.imgur.com/ETmUXMZ.png"/>
<p>&nbsp;</p>

🔸 **Fase de Construcción**
<p>&nbsp;</p>
<img src="https://i.imgur.com/KlCxGTv.png"/>

<img src="https://i.imgur.com/I0TNETc.png"/>

<img src="https://i.imgur.com/a7jpIUU.png"/>

<img src="https://i.imgur.com/9fi0OCW.png"/>
<p>&nbsp;</p>

🔸 **Fase de Transición**
<p>&nbsp;</p>
<img src="https://i.imgur.com/bUhDX6l.png"/>

### Planificación modificada <a name="planificaciondelproyecto3"></a>
Posteriormente, el **cliente** añadió cuatro casos de uso más para un total de **dieciséis** , **uno** de ellos **estructural** (CU-05), y los otros **tres no estructurales** (CU-14, CU-15 y CU-16). Puesto que no hay suficiente tiempo para realizar estas nuevas funcionalidades con la actual planificación del proyecto,  se han añadido **2 iteraciones** más en la fase de **transición**, las cuales han permitido solucionar esta falta de tiempo.

Esto da lugar a una planificación compuesta por:
* Una iteración en la fase de Inicio.
* Una iteración en la fase de Elaboración.
* Cinco iteraciones en la fase de Construcción.
* Dos iteraciones en la fase de Transición.

De esta forma, la planificación por iteración después de realizar las modificaciones sería:

<img src="https://i.imgur.com/auJmfHD.png"/>

Debido a que las cuatro primeras iteraciones tienen la misma planificación que en la inicial, son las iteraciones de la IT5 a la IT9 las que deben ser realizadas de nuevo, dejando la planificación modificada como la siguiente:
<p>&nbsp;</p>

🔸 **Fase de Construcción**
<p>&nbsp;</p>
<img src="https://i.imgur.com/7NfxYXq.png"/>

<img src="https://i.imgur.com/m5JHWdZ.png"/>

<img src="https://i.imgur.com/y9oYT7m.png"/>
<p>&nbsp;</p>

🔸 **Fase de Transición**
<p>&nbsp;</p>
<img src="https://i.imgur.com/uXOspdK.png"/>

<img src="https://i.imgur.com/PG2uIXk.png"/>
<p>&nbsp;</p>

Como podemos ver, en esta **última iteración** ha sido necesario que el **arquitecto** ayude a los dos roles de desarrolladores a realizar ciertas tareas de **test e integración.**

También hay que tener en cuenta que todo el **tiempo que le sobra** al arquitecto es tiempo que dedica a **tareas de gestión Project** en conjunto con el jefe de proyecto.

Una vez finalizados todos los cálculos y cuadradas las horas del proyecto, se procede a **migrar el mismo a Microsoft Project**, una herramienta que nos permite detallar más información acerca de fechas, horas laborales, planificación, diagramas, tareas... etc.

Para ello, primero es necesario obtener la jornada laboral de cada uno de los roles basándose en su implicación en el desarrollo. Esta es la siguiente:

<img src="https://i.imgur.com/ijWhNNq.png"/>
<p>&nbsp;</p>

* Jornada diaria del <b>Jefe de Proyecto</b>: 8 horas semanales / 5 días = 1.6h
* Jornada diaria del <b>Arquitecto Software</b>: 40 horas semanales / 5 días = 8h
* Jornada diaria del <b>Desarrollador Software Senior</b>: 40 horas semanales / 5 días = 8h
* Jornada diaria del <b>Desarrollador Software Junior</b>: 20 horas semanales / 5 días = 4h

A estas horas les aplicamos el porcentaje de productividad <b>93%</b> para calcular el tiempo que realmente le dedican al proyecto:

* <b>Jefe de Proyecto</b>: 1,488h
* <b>Arquitecto Software</b>: 7,44h
* <b>Desarrollador Software Senior</b>: 7,44h
* <b>Desarrollador Software Junior</b>: 3,72

En Microsoft Project  se han realizado **2 tipos de planificaciones**, una planificación por **iteraciones** y una posterior planificación por **casos de uso**.

<img src="https://i.imgur.com/bfOr6sr.png"/>
<p>&nbsp;</p>
Como se puede observar se ha planificado el proyecto basándose en la intervención de los roles en cada iteración.

Por ello, en cada iteración se encuentran **2 secciones** dedicadas a:

* <b>Management disciplines</b>: Esta sección está dedicada para las tareas de gestión del proyecto, en ella trabajan tanto el jefe de proyecto como el arquitecto software, y se divide en 3 subsecciones, Project Management, Environment y Configuration & Change Management.
* <b>Use Cases Disciplines</b>: Esta sección está utilizada para las distintas fases de los casos de uso, en ella trabaja todo el equipo y sus posibles subsecciones son las siguientes:
   - <b>Business Modeling</b>: Esta sección se encarga por completo del jefe del proyecto, entrando dentro de lo que conocemos como el modelado del negocio.
   - <b>Requirements</b>: Esta sección corresponde con los requerimientos de cada caso de uso.
   - <b>Analysis and Design</b>: Esta sección corresponde con el análisis y el diseño de cada caso de uso del proyecto.
   - <b>Implementation</b>: Esta subsección corresponde con la implementación de cada caso de uso
   - <b>Test y Integration</b>: En estas dos subsecciones corresponden con la fase de test e integración del Excel
   - <b>Deployment</b>: Esta subsección corresponde con el despliegue, y es la última que se realiza antes de que el caso de uso esté completamente desarrollado en la aplicación.

Cada iteración corresponde con una semana, por lo que en esta planificación se han ido repartiendo las horas de cada trabajador en cada una de las tareas que había que realizar para dicha integración, de tal forma que la repartición de horas, en función de los siguientes días y respetando su jornada laboral, se puede ver en la siguiente imagen:

<img src="https://i.imgur.com/o6TILqp.png"/>


Planificación por casos de uso:

<img src="https://i.imgur.com/NnHGRz1.png"/>
<p>&nbsp;</p>
Para realizarla, se ha tenido en cuenta la planificación previa por iteraciones y se han agrupado todas las intervenciones de los roles en esta por caso de uso.
En concreto, se compone de <b>3 secciones</b>:

* <b>Management</b>: Dedicada a la gestión del proyecto y el modelado de negocio, con las intervenciones del jefe del proyecto y el Arquitecto del Software
* <b>Use Cases</b>: Contiene las disciplinas realizadas de los casos de uso, en la fecha y hora que se realizaron y los roles que intervinieron.
* <b>Despliegues</b>: Contiene los despliegues de cada caso de uso, con la fecha y hora de su realización

### Análisis de la planificación <a name="analisisdelaplanificacion"></a>
En primer lugar, la planificación ha requerido <b>más horas</b> de las que realmente se disponen para completarse, esto es debido a que en la planificación inicial, los cálculos se realizaron en torno a <b>7 semanas y 12 casos de uso</b>, obteniendo un total de <b>41,23 horas</b> por cada caso de uso. Sin embargo, fue necesario modificar la planificación del proyecto expandiendo 2 semanas su duracion. 

Se ha decidido que el <b>Arquitecto del Software</b> se encargará de aquellas tareas que no debía realizar por su cualificación, pero que no se disponía del tiempo requerido para llevarlas a cabo. En este caso se trata de la disciplina de <b>Test e Integración</b>, pues a lo largo de las <b>últimas iteraciones</b> era necesario completarla para llevar a cabo el despliegue.

Considerando la falta de horas para realizar todo el trabajo, el <b>arquitecto software</b> priorizará trabajar en las disciplinas dedicadas a los <b>casos de uso</b>, y tras su realización, dedicará el tiempo sobrante de cada iteración en realizar <b>horas de gestión</b>. En la siguiente tabla se observan las <b>13,16</b> horas de gestión que realizará el arquitecto tras finalizar tu contribución en las tareas dedicadas a los casos de uso.

<img src="https://i.imgur.com/sZuqyhH.png"/>


Respecto a la distribución de horas de los distintos roles en las distintas disciplinas,  el <b>Jefe de proyecto</b> es el que se encarga de todo el tiempo de <b>Business Modeling</b>, tras ello, dedica sus horas restantes a la <b>gestión</b>.

El <b>arquitecto de software</b> por tanto se dedica a las disciplinas de Requisitos, Análisis y Diseño, Implementación y extraordinariamente en la última iteración realizará Tests e Integración. Como se comentó previamente, invertirá las horas restantes que tenga en cada iteración en tareas de <b>gestión</b>.

El <b>desarrollador senior</b>, dedica todas sus horas a las siguientes disciplinas de los casos de uso: Requisitos, Análisis y Diseño, Implementación, Test e Integración y Despliegue. 

Finalmente el <b>desarrollador junior</b>, dedica sus horas a las siguientes disciplinas de los casos de uso: Implementación, Test e Integración y Despliegue.

A continuación se muestra la distribución de horas que se ha seguido en las disciplinas de los casos de uso para cada uno de los <b>roles</b>, exceptuando el jefe de proyecto:


Datos:

<img src="https://i.imgur.com/oMGRcTV.png"/>

<p>&nbsp;</p>
<img src="https://i.imgur.com/4TEkAy6.png"/>

<p>&nbsp;</p>
<img src="https://i.imgur.com/0DCVgGj.png"/>
<p>&nbsp;</p>


Gráficos:

<img src="https://i.imgur.com/ZNHT4Gr.png"/>

<img src="https://i.imgur.com/b7LEifJ.png"/>

<img src="https://i.imgur.com/7gY8Ekp.png"/>

<img src="https://i.imgur.com/b29ITu5.png"/>

<img src="https://i.imgur.com/m0OfGct.png"/>

De esta forma, las <b>horas máximas</b> que se han dedicado al proyecto respecto de las que se <b>disponen</b> en primer lugar son las siguientes:

<img src="https://i.imgur.com/gikVlbj.png"/>
<p>&nbsp;</p>

Con estos datos, se puede comprobar el **rendimiento** que se ha tenido por cada iteración:

<img src="https://i.imgur.com/YXYwKox.png"/>

Se puede apreciar una bajada de trabajo en horas en la primera semana (semana 36), debido a que el desarrollador senior no puede trabajar en sus disciplinas por las dependencias de tareas. Respecto a las semanas posteriores, las horas de trabajo se mantienen constantes (100 horas).

A continuación, se muestra una gráfica de coste de los recursos de la planificación:

<img src="https://i.imgur.com/ruwHRHc.png"/>

El coste total del proyecto se acerca a los 28.000 €, presupuesto que se desglosa según los recursos humanos. El jefe del proyecto cobra 3.300 € durante 9 semanas desde el inicio del proyecto; El desarrollador junior gana en torno 3.300 €, menos de la mitad del costo del desarrollador senior, el cual se encuentra cercano a los 10.000€. Por último, el presupuesto para cubrir el costo del arquitecto software es el más alto, 11.000 €.

Seguidamente, se muestra una descripción gráfica de las horas trabajadas por los roles en total durante toda la planificación del proyecto. 

<img src="https://i.imgur.com/fYQTvAX.png"/>

En este informe se puede observar el trabajo restante que les queda por hacer a cada uno de los trabajadores desde la fecha de comienzo 31/08/20  hasta el 30/10/20 como esta es una fecha pasada, el trabajo previsto está a 0, pero aun así, nos podemos hacer una idea de la carga de trabajo que soportará cada uno de los roles.



###  Camino Crítico <a name="caminocritico"></a>
Por último, dentro del análisis de la planificación nos encontramos ante el camino crítico. Este nos informará si hay algún punto crítico dentro del proyecto  ya sea por culpa de horas mal planificadas o sobrecarga de trabajo.

<img src="https://i.imgur.com/eKHPHmv.png"/>
<img src="https://i.imgur.com/rlrB8G1.png"/>

Como se puede ver en estas dos fotos anteriores, hay zonas críticas debido a las horas, algunas acciones empiezan y acaban el mismo día (Business Modeling) la cual es predecesora de las disciplinas de los casos de usos.


# Configuración del seguimiento de la planificación <a name="configSeguimientoPlan"></a>

La planificación del proyecto se ha trasladado a **Jira**, una herramienta centrada en la **gestión de proyectos**, seguimiento de errores y  del estado de desarrollo, la administración de tareas y la gestión de requisitos.

Así mismo, permite una profunda documentación sobre seguimientos y errores que contendría el proyecto y gestión de workflows ideales para proyectos software ágiles, como SCRUM. Es una herramienta flexible que facilita la gestión de proyectos pequeños, medianos o muy extensos.

Se ha decidido utilizar este software porque aporta un medio para la realización de la planificación de un proyecto de forma compartida y en tiempo real gracias a la plataforma web online . Así como porque presenta una interfaz relativamente sencilla e intuitiva. Además, los informes, las estadísticas y los progresos se muestran en **tiempo real**. De este modo, todos los implicados están siempre al día.

En cuanto a la sintaxis, cada caso de uso se ha creado como una **incidencia épica**, mientras que cada una de las tareas que se corresponden a cada caso de uso se han diseñado como tareas. Sin embargo, aquellas tareas que son compartidas por más de un rol contienen una **subtarea** con la contribución de cada rol.

Respecto a las iteraciones, estas vendrán definidas como un Sprint que contendrá todas las tareas implicadas en el progreso de dicha iteración. Por añadidura, todas las tareas de un caso de uso estarán enlazadas a la tarea épica del caso de uso susodicho y pertenecerán a un sprint concreto, correspondiente a una de las 9 iteraciones o semanas que durará el proyecto.

En la siguiente imagen se puede observar en detalle una tarea épica (caso de uso Añadir Evento Municipio):

<p>&nbsp;</p>

<img src="https://i.imgur.com/6xKmLcR.png"/>

<p>&nbsp;</p>

En la próxima imagen se puede ver una Tarea (**Incidencia**) con atribuciones de los roles (**Subtareas**):

<p>&nbsp;</p>

<img src="https://i.imgur.com/fSwBcqe.png"/>

<p>&nbsp;</p>

En la imagen siguiente se puede ver una Iteración (sprint) en la que se desarrollan tareas:

<p>&nbsp;</p>

<img src="https://i.imgur.com/ylNYQJG.png"/>

<p>&nbsp;</p>

Cada una de las incidencias (épicas o de tipo tarea) tienen asociada una prioridad. Las incidencias de los casos de usos estructurales vendrán definidas con una prioridad **High**, mientras que las incidencias relativas a los casos de uso no estructurales **Medium**.

En lo referente al nombre/título de cada tarea, se especificará en JIRA con la siguiente sintaxis:

> _IT[Nº de Iteración] - UC[Nº de caso de uso] - [fase de disciplina] - [Rol encargado]_

A partir del contexto anterior, es momento de especificar que equipos de desarrollo se han planificado para realizar el proyecto y qué tareas se han repartido en cada equipo. Adicionalmente, se informará en qué consisten dichas tareas y cómo se realizan, estimando el tiempo que tienen el/los miembros del equipo asignados a hacerla a lo largo de las iteraciones.

Para llevar a cabo la planificación de cada disciplina de los casos de uso, estas disciplinas se han descompuesto en tareas de la siguiente manera:

* **Definición de requisitos**:
    * Análisis del problema tratando de comprender a los Stakeholders.
    * Definición y redefinición de los requisitos del sistema.
* **Análisis y Diseño**:
    * Analizar el comportamiento y definir una arquitectura software candidata.
    * Diseñar la base de datos y los componentes del sistema.
* **Implementación**:
    * Implementar los componentes.
    * Testear esos componentes (comprobar su funcionamiento).
* **Integración y testeo**:
    * Integración:
      * Integrar cada subsistema al completo.
      * Integrar todos los subsistemas al sistema.
    * Testeo:
      * Testear y evaluar el resultado.
      * Asegurarse de que el sistema proporcionado cumple con los objetivos establecidos y comprobar que los test son correctos.
* **Despliegue**:
    * Producir la Unidad de despliegue.
    * Gestionar las pruebas de instalación del sistema en el sitio deseado.
    * Desarrollar material de soporte.

Estas  serán codificadas como **tareas**, en el caso de ser compartidas por más de un rol del equipo, contendrán unas **subtareas** con la contribución de cada rol. Para aquellas tareas que representan de manera uniforme un caso de uso, se definen como **épicas**.

En cuanto a las iteraciones, estas se contabilizarán con los **sprints**, que contendrán las distintas tareas que se realizarán dentro de dicha iteración.

De esta forma, todas las tareas de un caso de uso serán **asignadas a la Incidencia** correspondiente a dicho caso de uso, y pertenecerán a un sprint concreto, correspondiente a **una de las 9 iteraciones** que durará el proyecto.

Por tanto, dentro de Jira se ha seguido el siguiente procedimiento: 

1. Se crea una épica para el caso de uso que se esté realizando

   1.1. Como nombre de épica se utiliza la nomenclatura CUXX.

   1.2. En el resumen se utiliza CUXX - Nombre_del_Caso.

   1.3. Se incluye una pequeña descripción del caso de uso.

   1.4. Se añade una etiqueta idéntica al nombre de la épica. 

2. Dentro de cada épica, se crea una incidencia de tipo tarea por cada tarea de proyect correspondiente al caso de uso

   2.1. Como resumen de la tarea se utiliza la nomenclatura ITXX - UCXX - Fase - Nombre_de_la_Tarea

   2.2. Se asignan las etiquetas correspondientes al caso de uso, la iteración, la persona asignada a la tarea (en caso de que sólo sea una), y la fase

   2.3. Se asigna al responsable de la tarea, en caso de que sólo haya uno, y se añaden la cantidad de horas previstas. En caso de que la tarea no tenga un sólo responsable, se crean las subtareas necesarias para asignar el tiempo y las personas necesarias a dicha tarea, siguiendo el mismo procedimiento que para las tareas.

3. Se revisa que las tareas y las épicas están creadas correctamente

   3.1. Se comprueba que las horas son las adecuadas.

   3.2. Se comprueba que la tarea está asignada a la persona correspondiente.

   3.3. Se revisan las etiquetas y el sprint asignado.

   
## Señor Blanco (Equipo 1) <a name="señorBlanco"></a>

### Proceso seguido <a name="procesoSeguidoBlanco"></a>

El señor blanco ha liderado al equipo 1, donde cada rol es interpretado por los siguientes miembros:

* Jefe del proyecto (JP): Sr. Blanco
* Arquitecto Software (AS): Sr. Marrón
* Desarrollador Senior (DS): Sr. Naranja
* Desarrollador Junior (DJ): Sr.  Azul

El **Sr. Blanco** (JP) se encargará de las tareas de modelado de negocio (BM) y gestión del proyecto software, en otras palabras, se ocupará de asignar las tareas a realizar a cada rol. 

El **Sr. Marrón** (AS) se ocupará de las disciplinas de Requisitos, análisis y Diseño e Implementación. El **Sr. Naranja** (DS) se centra en todas las disciplinas que abarcan el desarrollo completo de cada caso de uso; desde la Definición de Requisitos, Análisis y Diseño, Implementación, Integración y Test y Despliegue. Por último, el **Sr. Azul** (DJ) ejecuta las disciplinas de Implementación, Test e Integración y Despliegue.

* **CU01**: Añadir Evento de Municipio.
* **CU02**: Añadir Evento de Ruta Montaña.
* **CU03**: Añadir Usuario.
* **CU04**: Añadir una barra de búsqueda y filtrado de ubicaciones.

Por último, las incidencias relacionadas con los cinco casos de uso estructurales dispondrán de una prioridad alta (**High**). 

### Análisis del progreso <a name="analisisProgresoBlanco"></a>

En este apartado se detalla la distribución de las tareas realizadas por cada rol a lo largo de las 9 iteraciones, según las disciplinas que puedan realizar cada uno de ellos.

Antes de dar principio, es imprescindible aclarar que el tiempo inicial disponible del arquitecto software es de 37.20 horas semanales. En el caso de que realice sus tareas y quede tiempo sobrante, este se lo dedicará a tareas de gestión.

<p>&nbsp;</p>

 ⌚ **Planificación tareas CU01 - Añadir Evento de Municipio**

Es el primer caso de uso estructural del proyecto; el usuario podrá añadir un nuevo evento de municipio en una fecha determinada, estando asignado a una condición meteorológica en tiempo real de la ubicación del municipio. 

El desarrollo de este caso de uso comienza con su Definición de Requisitos (RE) en la **iteración 1** y finaliza en la **iteración 8**, con el despliegue del paquete de requisitos CU01, CU02 y CU03.

El encargado de realizar las tareas correspondientes a la **Definición de Requisitos** (RE) en la iteración 1 es el Arquitecto software (Sr. Marrón). 

En cuanto al **Análisis y Diseño** (A&D), esta disciplina comienza en la IT1 y es completada por el Desarrollador Senior (Sr. Naranja).

La **Implementación** (Imp), como consecuencia de ser un caso de uso estructural, se realizará en la primera iteración de elaboración IT2. Los roles encargados de completar las tareas de esta disciplina son el Desarrollador Junior y el Desarrollador Senior (Sr. Azul y Sr. Naranja).

* La tarea de implementación “Implementar los componentes” es compartida por los DJ y DS.

El **Test e Integración** (T&I) se realiza en la iteración IT4 por el Desarrollador Senior (Sr. Naranja).

En última instancia, el **Despliegue** (D) se completa en la IT8 por el Desarrollador Junior (Sr. Azul) en el paquete de casos de uso CU01, CU02 y CU03.

En la siguiente tabla se puede ver la distribución de manera resumida:

<img src="https://i.imgur.com/gPhoqxf.png"/>

<p>&nbsp;</p>

 ⌚ **Planificación tareas CU02 - Añadir Evento de Ruta Montaña**

Es el segundo caso de uso estructural del proyecto; El usuario podrá añadir un nuevo evento de montaña en una fecha determinada, estando asignado a una condición meteorológica en tiempo real de la ubicación de la montaña. 

El desarrollo de este caso de uso comienza con su Definición de Requisitos (RE) en la **iteración 1** y finaliza en la **iteración 8**, con el despliegue del paquete de requisitos CU01, CU02 y CU03.

El encargado de realizar las tareas correspondientes a la **Definición de Requisitos** (RE) en la iteración 1 es el Arquitecto software (Sr. Marrón).

En cuanto al **Análisis y Diseño** (A&D), esta disciplina comienza en la IT1 y es completada por el Desarrollador Senior (Sr. Naranja).

La **Implementación** (Imp), como consecuencia de ser un caso de uso estructural, se realizará en la primera iteración de elaboración IT2. El rol encargado de completar las tareas de esta disciplina es el Desarrollador Senior (Sr. Naranja).

El **Test e Integración** (T&I) se realiza en la iteración IT4 por el Desarrollador Senior (Sr. Naranja).

En última instancia, el **Despliegue** (D) se completa en la IT8 por el Desarrollador Junior (Sr. Azul) en el paquete de casos de uso CU01, CU02 y CU03.

En la siguiente tabla se puede ver la distribución de manera resumida:

<img src="https://i.imgur.com/4HV2Z8U.png"/>

<p>&nbsp;</p>

 ⌚ **Planificación tareas CU03 - Añadir Usuario**

Es el tercer caso de uso estructural del proyecto; El sistema permite al usuario registrarse con unas credenciales, de forma que en la base de datos se inserta un nuevo objeto con la información relativa al nuevo perfil creado en la aplicación. Con estas credenciales, el usuario podrá utilizar la funcionalidad de la aplicación.

El desarrollo de este caso de uso comienza con su Definición de Requisitos (RE) en la **iteración 1** y finaliza en la **iteración 8**, con el despliegue del paquete de requisitos CU01, CU02 y CU03.

El encargado de realizar las tareas correspondientes a la **Definición de Requisitos** (RE) en la iteración 1 es el Arquitecto software (Sr. Marrón).

En cuanto al **Análisis y Diseño** (A&D), esta disciplina comienza en la IT1 y es completada por el Desarrollador Senior (Sr. Naranja), en añadidura del Arquitecto Software (Sr. Marrón) para completar las tareas.

* La tarea de Análisis y Diseño “Analizar el comportamiento y definir una Arquitectura software candidata” es compartida por los AS y DS.

La **Implementación** (Imp), como consecuencia de ser un caso de uso estructural, se realizará en la primera iteración de elaboración IT2. Los encargados de completar las tareas de esta disciplina son el Desarrollador Senior (Sr. Naranja) y el Arquitecto Software (Sr. Marrón).

* La tarea de Implementación “Implementar los componentes” es compartida por los AS y DS.

El **Test e Integración** (T&I) se realiza en la iteración IT4 por el Desarrollador Senior (Sr. Naranja).

En última instancia, el **Despliegue** (D) se completa en la IT8 por el Desarrollador Junior (Sr. Azul) en el paquete de casos de uso CU01, CU02 y CU03.

En la siguiente tabla se puede ver la distribución de manera resumida:

<img src="https://i.imgur.com/PA52KSN.png"/>

<p>&nbsp;</p>

 ⌚ **Planificación tareas CU04 - Añadir una barra de búsqueda y filtrado de ubicaciones**

Es el cuarto caso de uso estructural del proyecto; El sistema deberá incorporar una barra de búsqueda para buscar una ubicación con su tiempo meteorológico asignado. 

El desarrollo de este caso de uso comienza con su Definición de Requisitos (RE) en la **iteración 1** y finaliza en la **iteración 9**, con el despliegue del paquete de requisitos CU04…CU16.

El encargado de realizar las tareas correspondientes a la **Definición de Requisitos** (RE) en la iteración 1 es el Arquitecto software (Sr. Marrón). 

En cuanto al **Análisis y Diseño** (A&D), esta disciplina comienza en la IT1 y es completada por el Arquitecto Software (Sr. Marrón).

La **Implementación** (Imp), como consecuencia de ser un caso de uso estructural, se realizará en la primera iteración de elaboración IT3. Los encargados de completar las tareas de esta disciplina son el Desarrollador Senior (Sr. Naranja) y el Desarrollador Junior (Sr. Azul).

* La tarea de Implementación “Implementar los componentes” es compartida por los DJ y DS.
* La tarea de Implementación “Testear esos componentes (comprobar su funcionamiento)” es compartida por los DJ y DS.

El **Test e Integración** (T&I) se realiza en la iteración IT7 por el Desarrollador Junior (Sr. Azul).

En última instancia, el **Despliegue** (D) se completa en la IT9 por el Desarrollador Junior (Sr. Azul) en el paquete de casos de uso CU01, CU02 y CU03.

En la siguiente tabla se puede ver la distribución de manera resumida:

<img src="https://i.imgur.com/DuRwXEK.png"/>


## Señor Marrón (Equipo 2) <a name="señorMarron"></a>

## Proceso seguido <a name="procesoSeguidoMarron"></a>

El señor marrón ha liderado al equipo 2, donde cada rol es interpretado por los siguientes miembros:
* Jefe del proyecto (JP): Sr. Marrón
* Arquitecto Software (AS): Sr. Naranja
* Desarrollador Senior (DS): Sr. Azul
* Desarrollador Junior (DJ): Sr.  Blanco

El **Sr. Marrón(JP)** se encargará de las tareas de modelado de negocio (BM) y gestión del proyecto software, en otras palabras, se ocupará de asignar las tareas a realizar a cada rol. 

El **Sr. Naranja(AS)** se ocupará de las disciplinas de Requisitos, análisis y Diseño e Implementación. El Sr. Azul(DS) se centra en todas las disciplinas que abarcan el desarrollo completo de cada caso de uso; desde la Definición de Requisitos, Análisis y Diseño, Implementación, Integración y Test y Despliegue. Por último, el Sr. Blanco(DJ) ejecuta las disciplinas de Implementación, Test e Integración y Despliegue.

Respecto los casos de uso, el **equipo 2** se encarga de la totalidad de disciplinas de los siguientes casos de uso (en negrita, los estructurales):
* CU05: Añadir preferencias desde el menú de AppBar (ajustes…)
* CU06: Consultar el tiempo detallado de una ubicación.
* CU07: Modificar un evento.
* CU08: Eliminar un evento..

Por último, las incidencias relacionadas con el caso de uso estructural (CU05) dispondrás de una prioridad alta (**High**). 

## Análisis del progreso <a name="analisisProgresoMarron"></a>
En este apartado se detalla la distribución de las tareas realizadas por cada rol a lo largo de las 9 iteraciones, según las disciplinas que puedan realizar cada uno de ellos.

Antes de dar principio, es imprescindible aclarar que el tiempo inicial disponible del arquitecto software es de 37.20 horas semanales. En el caso de que realice sus tareas y quede tiempo sobrante, este se lo dedicará a tareas de gestión.

<p>&nbsp;</p>

 ⌚ **Planificación tareas CU05 - Añadir preferencias desde el menú de AppBar (ajustes…)**

Se trata de un caso de uso estructural; el sistema deberá incorporar un apartado de configuración que permite al usuario personalizar su experiencia con la aplicación, así como el modo oscuro, preferencias…etc.

El desarrollo de este caso de uso comienza con su Definición de Requisitos (RE) en la **iteración 5** y finaliza en la **iteración 9**, con el despliegue del paquete de requisitos del CU04 al CU16.

El encargado de realizar las tareas correspondientes a la **Definición de Requisitos (RE)** en la iteración 5 es el Desarrollador Senior (Sr. Azul). 

En cuanto al **Análisis y Diseño (A&D)**, esta disciplina comienza en la IT5 y es completada por el Desarrollador Senior (Sr. Azul).

La **Implementación** (Imp), como consecuencia de ser un caso de uso estructural, se realizará cuanto antes posible, es decir, en la iteración 6. Los roles encargados de completar las tareas de esta disciplina son el Desarrollador Junior y el Arquitecto Software (Sr. Blanco y Sr. Azul).
* Las tareas de implementación “Implementar los componentes” y “Testear los componentes”  son compartidas por los DJ y AS.

El **Test e Integración** (T&I) se realiza en la iteración IT7 por el Desarrollador Senior (Sr. Azul).

En última instancia, el **Despliegue** (D) se completa en la IT9 por el Desarrollador Senior (Sr. Azul) en el paquete de casos de uso CU04 al CU16.

En la siguiente tabla se puede ver la distribución de manera resumida:

<img src="https://i.imgur.com/gLASWeG.png"/>

<p>&nbsp;</p>

 ⌚ **Planificación tareas CU06 - Consultar el tiempo detallado de una ubicación**

Es el primer caso de uso no estructural del proyecto; El usuario podrá visualizar el tiempo meteorológico de una ubicación específica en tiempo real.

El desarrollo de este caso de uso comienza con su **Definición de Requisitos** (RE) en la **iteración 1** y finaliza en la **iteración 9**, con el despliegue del paquete de requisitos CU04…CU16.

El encargado de realizar las tareas correspondientes a la **Definición de Requisitos** (RE) en la iteración 1 es el Desarrollador Senior (Sr. Azul). 

En cuanto al **Análisis y Diseño** (A&D), esta disciplina comienza en la IT2 y es completada por el Arquitecto Software (Sr. Naranja).

La **Implementación** (Imp), se realizará en la segunda iteración de construcción IT4. Los encargados de completar las tareas de esta disciplina son el Desarrollador Junior (Sr. Blanco) y el Arquitecto Software (Sr. Naranja).

* La tarea de Implementación “Implementar los componentes” es compartida por los DJ y AS.

El **Test e Integración** (T&I) se realiza en la iteración IT7 por el Desarrollador Senior(Sr. Azul) y el Desarrollador Junior  (Sr. Blanco).
* Todas las tareas de esta disciplina son compartidas por los DS y DJ.

En última instancia, el **Despliegue** (D) se completa en la IT9 por el Desarrollador Senior (Sr. Azul) en el paquete de casos de uso CU04…CU16.

En la siguiente tabla se puede ver la distribución de manera resumida:

<img src="https://i.imgur.com/vkHZZCL.png"/>

<p>&nbsp;</p>

 ⌚ **Planificación tareas CU07 - Modificar un evento**
En este caso de uso no estructural del proyecto; El usuario podrá modificar los datos de un evento, así como su nombre, descripción, fecha y ubicación.

El desarrollo de este caso de uso comienza con su Definición de Requisitos (RE) en la **iteración 1** y finaliza en la **iteración 9**, con el despliegue del paquete de requisitos CU04…CU16.

El encargado de realizar las tareas correspondientes a la **Definición de Requisitos** (RE) en la iteración 1 es el Desarrollador Senior (Sr. Azul). 

En cuanto al **Análisis y Diseño** (A&D), esta disciplina comienza en la IT2 y es completada por el Arquitecto Software (Sr. Naranja).

La **Implementación** (Imp), se realizará en la segunda iteración de construcción IT4. El encargado de completar las tareas de esta disciplina es el Arquitecto Software (Sr. Naranja).

El **Test e Integración** (T&I) se realiza en la iteración IT8  por el Desarrollador Senior(Sr. Azul).

En última instancia, el **Despliegue** (D) se completa en la IT9 por el Desarrollador Senior (Sr. Azul) en el paquete de casos de uso CU04…CU16.

En la siguiente tabla se puede ver la distribución de manera resumida:

<img src="https://i.imgur.com/dprB7NY.png"/>

<p>&nbsp;</p>

 ⌚ **Planificación tareas CU08 - Consultar el tiempo meteorológico en la ubicación actual**
En este caso de uso no estructural del proyecto; El usuario podrá consultar los detalles del tiempo asociado a la localización/municipio más cercano.

El desarrollo de este caso de uso comienza con su Definición de Requisitos (RE) en la **iteración 1** y finaliza en la **iteración 9**, con el despliegue del paquete de requisitos CU04…CU16.

El encargado de realizar las tareas correspondientes a la **Definición de Requisitos** (RE) en la iteración 1 es el Desarrollador Senior (Sr. Azul). 

En cuanto al **Análisis y Diseño** (A&D), esta disciplina comienza en la IT2 y es completada por el Arquitecto Software (Sr. Naranja).

La **Implementación** (Imp), se realizará en la segunda iteración de construcción IT4. Los encargados de completar las tareas de esta disciplina son el Desarrollador Senior (Sr. Azul) y el Arquitecto Software (Sr. Naranja).
* Ambas tareas de Implementación son compartidas por los DS y AS.

El **Test e Integración** (T&I) se realiza en la iteración IT8  por el Desarrollador Senior(Sr. Azul).

En última instancia, el **Despliegue** (D) se completa en la IT9 por el Desarrollador Senior (Sr. Azul) en el paquete de casos de uso CU04…CU16.

En la siguiente tabla se puede ver la distribución de manera resumida:

<img src="https://i.imgur.com/uXfwUnr.png"/>

## Señor Naranja (Equipo 3) <a name="señorNaranja"></a>

## Proceso seguido <a name="procesoSeguidoNaranja"></a>
El señor naranja ha liderado al equipo 3, donde cada rol es interpretado por los siguientes miembros:
* Jefe del proyecto (JP): Sr. Naranja
* Arquitecto Software (AS): Sr. Azul
* Desarrollador Senior (DS): Sr. Blanco
* Desarrollador Junior (DJ): Sr. Marrón

El **Sr. Naranja** (JP) se encargará de las tareas de modelado de negocio (BM) y gestión del proyecto software, en otras palabras, se ocupará de asignar las tareas a realizar a cada rol. 

El **Sr. Azul** (AS) se ocupará de las disciplinas de Requisitos, análisis y Diseño e Implementación. El **Sr. Blanco** (DS) se centra en todas las disciplinas que abarcan el desarrollo completo de cada caso de uso; desde la Definición de Requisitos, Análisis y Diseño, Implementación, Integración y Test y Despliegue. Por último, el **Sr. Marrón** (DJ) ejecuta las disciplinas de Implementación, Test e Integración y Despliegue.

Respecto los casos de uso, el equipo 3 se encarga de la totalidad de disciplinas de los siguientes casos de uso:
* CU09: Consultar tiempo meteorológico en la ubicación actual
* CU10: Modificar idioma y tema a modo oscuro
* CU11: Consultar lista de eventos.
* CU12: Consultar un evento.

Por último, las incidencias relacionadas con los cinco casos de uso estructurales dispondrán de una prioridad alta (High).

## Análisis del progreso <a name="analisisProgresoNaranja"></a>
En este apartado se detalla la distribución de las tareas realizadas por cada rol a lo largo de las 9 iteraciones, según las disciplinas que puedan realizar cada uno de ellos.

Antes de dar principio, es imprescindible aclarar que el tiempo inicial disponible del arquitecto software es de 37.20 horas semanales. En el caso de que realice sus tareas y quede tiempo sobrante, este se lo dedicará a tareas de gestión.

<p>&nbsp;</p>

 ⌚ **Planificación tareas CU09 - Consultar tiempo meteorológico en la ubicación actual**
<p>
Es el noveno caso de uso del proyecto; el usuario podrá consultar los detalles del tiempo asociado a la localización/municipio más cercano. Los roles que participarán en el desarrollo de este caso de uso son todos los miembros del equipo, exceptuando el Sr. Naranja (JP). 
</p>

El desarrollo de este caso de uso comienza con su Definición de Requisitos (RE) en la iteración 3 y finaliza en la iteración 9, con el despliegue del paquete de requisitos CU04…CU16.

El encargado de realizar las tareas correspondientes a la **Definición de Requisitos** (RE) en la **iteración 3** es el Arquitecto software (Sr. Azul).

En cuanto al **Análisis y Diseño** (A&D), esta disciplina comienza en la **iteración 3** y es completada por el Desarrollador Senior (Sr. Blanco).

La **Implementación** (Imp), comienza en la **iteración 5** y es realizada por el Desarrollador Senior y el Arquitecto Software (Sr. Blanco y Sr. Azul).

El **Test e Integración** (T&I) se realiza en la **iteración 8** por el Desarrollador Senior (Sr. Blanco).

En última instancia, el **Despliegue** (D) se completa en la **iteración 9** por el Desarrollador Senior (Sr. Blanco) en el paquete de casos de uso CU04 … CU16.

En la siguiente tabla se puede ver la distribución de manera resumida:

<img src="https://i.imgur.com/24eBqsa.png"/>

 ⌚ **Planificación tareas CU10 - Modificar idioma y tema a modo oscuro**
<p>
Es el décimo caso de uso del proyecto; el usuario podrá realizar una serie de modificaciones en la aplicación para configurar esta a su gusto como cambiar el idioma, el tema a modo oscuro, etc.
</p>

El desarrollo de este caso de uso comienza con su **Definición de Requisitos** (RE) en la iteración 3 y finaliza en la iteración 9, con el **despliegue** del paquete de requisitos CU04-16.

El encargado de realizar las tareas correspondientes a la **Definición de Requisitos** (RE) en la **iteración 3** es el Arquitecto software (Sr. Azul).

En cuanto al **Análisis y Diseño** (A&D), esta disciplina comienza en la **iteración 3** y es completada por el Desarrollador Senior (Sr. Blanco).

La **Implementación** (Imp), esta disciplina comienza en la **iteración 5** y es realizada por el Arquitecto Software (Sr. Azul).

El **Test e Integración** (T&I) se realiza en la iteración **iteración 8** por el Desarrollador Senior y el Desarrollador Junior (Sr. Blanco y Sr. Marrón).

En última instancia, el **Despliegue** (D) se completa en la **iteración 9** por el Desarrollador Senior (Sr. Blanco) en el paquete de casos de uso CU04 … CU16.

En la siguiente tabla se puede ver la distribución de manera resumida:

<img src="https://i.imgur.com/PYvgEx1.png"/>

 ⌚ **Planificación tareas CU11 - Consultar lista de eventos**
<p>
Es el undécimo caso de uso del proyecto; el usuario podrá visualizar el listado completo de eventos de municipios y montañas creados por su parte.
</p>

El desarrollo de este caso de uso comienza con su **Definición de Requisitos** (RE) en la iteración 3 y finaliza en la iteración 9, con el **despliegue** del paquete de requisitos CU04-16.

El encargado de realizar las tareas correspondientes a la **Definición de Requisitos** (RE) en la **iteración 3** es el Arquitecto software (Sr. Azul).

En cuanto al **Análisis y Diseño** (A&D), esta disciplina comienza en la **iteración 3** y es completada por el Desarrollador Senior (Sr. Blanco).

La **Implementación** (Imp), esta disciplina comienza en la **iteración 5** y es realizada por el Desarrollador Senior y el Arquitecto Software (Sr. Blanco y Sr. Azul).

El **Test e Integración** (T&I) se realiza en la **iteración 8** por el Desarrollador Junior (Sr. Marrón).

En última instancia, el **Despliegue** (D) se completa en la **iteración 9** por el Desarrollador Senior (Sr. Blanco) en el paquete de casos de uso CU04 … CU16.

En la siguiente tabla se puede ver la distribución de manera resumida:

<img src="https://i.imgur.com/KHBwNMY.png"/>

 ⌚ **Planificación tareas CU12 - Consultar un evento**
<p>
Es el duodécimo caso de uso del proyecto; el usuario podrá visualizar en detalle los datos pertinentes de un evento de municipio o montaña.
</p>

El desarrollo de este caso de uso comienza con su **Definición de Requisitos** (RE) en la iteración 3 y finaliza en la iteración 9, con el **despliegue** del paquete de requisitos CU04-16.

El encargado de realizar las tareas correspondientes a la **Definición de Requisitos** (RE) en la **iteración 3** es el Arquitecto software (Sr. Azul).

En cuanto al **Análisis y Diseño** (A&D), esta disciplina comienza en la **iteración 3** y es realizada por el Desarrollador Senior y el Arquitecto Software (Sr. Blanco y Sr. Azul).
* La tarea de Análisis y diseño “Analizar el comportamiento y definir una Arquitectura software candidata” es compartida por los DS y AS.

La **Implementación** (Imp), comienza en la **iteración 6** y es realizada por el Desarrollador Senior (Sr. Blanco).

El **Test e Integración** (T&I) se realiza en la **iteración 9** por el Desarrollador Junior (Sr. Marrón).

En última instancia, el **Despliegue** (D) se completa en la **iteración 9** por el Desarrollador Senior (Sr. Blanco) en el paquete de casos de uso CU04 … CU16.

En la siguiente tabla se puede ver la distribución de manera resumida:

<img src="https://i.imgur.com/Rdmjam4.png"/>

## Señor Azul (Equipo 4) <a name="señorAzul"></a>

### Proceso seguido <a name="procesoSeguidoAzul"></a>

El señor azul ha liderado al equipo 4, donde cada rol es interpretado por los siguientes miembros:
* Jefe del proyecto (JP): Sr. Azul
* Arquitecto Software (AS): Sr. Blanco
* Desarrollador Senior (DS): Sr. Marrón
* Desarrollador Junior (DJ): Sr.  Naranja

El **Sr. Azul** (JP) se encargará de las tareas de modelado de negocio (BM) y gestión del proyecto software, en otras palabras, se ocupará de asignar las tareas a realizar a cada rol. 

El **Sr. Blanco** (AS) se ocupará de las disciplinas de Requisitos, análisis y Diseño e Implementación. 

El **Sr. Marrón** (DS) se centra en todas las disciplinas que abarcan el desarrollo completo de cada caso de uso; desde la Definición de Requisitos, Análisis y Diseño, Implementación, Integración y Test y Despliegue. Por último, 

El **Sr. Naranja** (DJ) ejecuta las disciplinas de Implementación, Test e Integración y Despliegue.
	
Respecto los casos de uso, el equipo 4 se encarga de la totalidad de disciplinas de los siguientes casos de uso:
* CU-13: Iniciar sesión.
* CU-14: Cerrar sesión.
* CU-15: Modificar usuario.
* CU-16: Eliminar usuario.


### Análisis del progreso <a name="analisisProgresoAzul"></a>
En este apartado se detalla la distribución de las tareas realizadas por cada rol a lo largo de las 9 iteraciones, según las disciplinas que puedan realizar cada uno de ellos.

Antes de empezar, es imprescindible aclarar que el tiempo inicial disponible del arquitecto software es de 37.20 horas semanales. En el caso de que realice sus tareas y quede tiempo sobrante, este se lo dedicará a tareas de gestión.

<p>&nbsp;</p>

 ⌚ **Planificación tareas CU13 - Iniciar sesión**
<p>
En este caso de uso el usuario podrá iniciar sesión dentro de la aplicación, para lo cual deberá haber creado previamente su usuario. 
Todos los roles participarán de manera conjunta para el desarrollo de este caso de uso. 
</p>

El desarrollo de este caso de uso comienza con su **Definición de Requisitos** (RE) en la iteración 3 y finaliza en la iteración 9, con el **despliegue** del paquete de requisitos **CU04-16**.

El encargado de la **Definición de Requisitos** (RE) en la **iteración 3** es el Arquitecto software (Sr. Blanco). 

En cuanto al **Análisis y Diseño** (A&D), esta disciplina comienza en la **iteración 3** y es completada por el Arquitecto software (Sr. Blanco).

La **Implementación** (Imp) se realizará en la **iteración 6**. Los roles encargados de completar las tareas de esta disciplina son el Desarrollador Senior (Sr. Marrón) y el Arquitecto software (Sr. Blanco).

El **Test e Integración** (T&I) se realiza en la **iteración 9** y es completada por el Desarrollador Senior (Sr. Marrón) y el Desarrollador junior (Sr. Naranja).

Por último, el **Despliegue** (D) se completa en la **iteración 9** por el Desarrollador Senior (Sr. Marrón) en el paquete de casos de uso CU04-16.

En la siguiente tabla se puede ver la distribución de manera resumida:
<img src="https://i.imgur.com/S7OGneq.png"/>

<p>&nbsp;</p>

 ⌚ **Planificación tareas CU14 - Cerrar sesión**
<p>
En este caso de uso el usuario podrá cerrar su sesión dentro de la aplicación, para lo cual deberá haber iniciado previamente su sesión de usuario. 
Todos los roles participarán de manera conjunta para el desarrollo de este caso de uso. 
</p>

El desarrollo de este caso de uso comienza con su **Definición de Requisitos** (RE) en la iteración 5 y finaliza en la iteración 9, con el **despliegue** del paquete de requisitos **CU04-16**.

El encargado de la **Definición de Requisitos** (RE) en la **iteración 5** es el Desarrollador Senior (Sr. Marrón). 

En cuanto al **Análisis y Diseño** (A&D), esta disciplina comienza en la **iteración 6** y es completada por el Arquitecto software (Sr. Blanco).

La **Implementación** (Imp) se realizará en la **iteración 7** y es completada por el Desarrollador Senior (Sr. Marrón).

El **Test e Integración** (T&I) se realiza en la **iteración 9** y es completada por el Desarrollador Senior (Sr. Marrón) y el Arquitecto software (Sr. Blanco).

Por último, el **Despliegue** (D) se completa en la **iteración 9** por el Desarrollador Senior (Sr. Marrón) en el paquete de casos de uso CU04-16.

En la siguiente tabla se puede ver la distribución de manera resumida:
<img src="https://i.imgur.com/DpjKGVs.png"/>

 ⌚ **Planificación tareas CU15 - Modificar usuario**
<p>
En este caso de uso el usuario podrá modificar su perfil dentro de la aplicación, para lo cual deberá haber iniciado previamente su sesión de usuario. 
Todos los roles participarán de manera conjunta para el desarrollo de este caso de uso. 
</p>

El desarrollo de este caso de uso comienza con su **Definición de Requisitos** (RE) en la iteración 5 y finaliza en la iteración 9, con el **despliegue** del paquete de requisitos **CU04-16**.

El encargado de la **Definición de Requisitos** (RE) en la **iteración 5** es el Desarrollador Senior (Sr. Marrón). 

En cuanto al **Análisis y Diseño** (A&D), esta disciplina comienza en la **iteración 6** y es completada por el Arquitecto software (Sr. Blanco).

La **Implementación** (Imp) se realizará en la **iteración 7** y es completada por el Desarrollador Senior (Sr. Marrón) y el Arquitecto software (Sr. Blanco).

El **Test e Integración** (T&I) se realiza en la **iteración 9** y es completada por el Arquitecto software (Sr. Blanco).

Por último, el **Despliegue** (D) se completa en la **iteración 9** por el Desarrollador Senior (Sr. Marrón) en el paquete de casos de uso CU04-16.

En la siguiente tabla se puede ver la distribución de manera resumida:
<img src="https://i.imgur.com/ei5FuEx.png"/>

 ⌚ **Planificación tareas CU16 - Eliminar usuario**
<p>
En este caso de uso el usuario podrá eliminar su perfil dentro de la aplicación, para lo cual deberá haber iniciado previamente su sesión de usuario. 
Todos los roles participarán de manera conjunta para el desarrollo de este caso de uso. 
</p>

El desarrollo de este caso de uso comienza con su **Definición de Requisitos** (RE) en la iteración 5 y finaliza en la iteración 9, con el **despliegue** del paquete de requisitos **CU04-16**.

El encargado de la **Definición de Requisitos** (RE) en la **iteración 5** es el Desarrollador Senior (Sr. Marrón). 

En cuanto al **Análisis y Diseño** (A&D), esta disciplina comienza en la **iteración 6** y es completada por el Arquitecto software (Sr. Blanco).

La **Implementación** (Imp) se realizará en la **iteración 7** y es completada por el Arquitecto software (Sr. Blanco).

El **Test e Integración** (T&I) se realiza en la **iteración 9** y es completada por el Arquitecto software (Sr. Blanco).

Por último, el **Despliegue** (D) se completa en la **iteración 9** por el Desarrollador Senior (Sr. Marrón) en el paquete de casos de uso CU04-16.

En la siguiente tabla se puede ver la distribución de manera resumida:
<img src="https://i.imgur.com/Fg0Egaz.png"/>


### Proporción de Épicas, Tareas y Subtareas <a name="grafomarron"></a>
En el siguiente gráfico de tipo tarta se presenta la distribución existente en el proyecto de los distintos tipos de incidencias: épicas ( Casos de Uso), tareas y subtareas.

Se puede apreciar que la mayor parte del gráfico está compuesto por Tareas, seguido de un número alto de Subtareas.

Podemos observar que hay 16 incidencias de tipo Épica, las cuales referencian los casos de uso del proyecto.
<img src="https://i.imgur.com/0pmXF6h.png"/>

A continuación se muestra el porcentaje de cada uno de estos tipos de incidencia:

<img src="https://i.imgur.com/uDYMGrD.png"/>


### Proporción de Épicas, Tareas y Subtareas <a name="grafonaranja"></a>
En el siguiente gráfico de tipo tarta, se puede ver la distribución de incidencias a lo largo de cada una de las iteraciones. 

Se puede apreciar que las iteraciones que más incidencias contienen son las iteraciones 8 y 9 puesto que en ellas se realizan las tareas de despliegue de los casos de uso.

Las tareas que no están asignadas a ninguna iteración corresponden a las 16 tareas Épicas que son los casos de uso.

<img src="https://i.imgur.com/gWbvTY5.png"/>

A continuación se muestra una tabla con los porcentajes de cada iteración:
<img src="https://i.imgur.com/BZvjK3M.png"/>


### Proporción de tareas por caso de uso <a name="grafoazul"></a>
En el siguiente informe de tipo tarta se puede observar la distribución por casos de uso de las tareas. Cada caso de uso cuenta con el mismo número de tareas pues todos tienen las mismas fases.

Se puede apreciar un gran número de tareas no asignadas a ningún caso de uso. Corresponden a las subtareas, las cuales heredan el caso de uso al que pertenecen de la tarea padre. Por lo que este grafico nos sirve para saber cuántas tareas tiene cada **Caso de Uso** y el número de subtareas del proyecto.

<img src="https://i.imgur.com/I1CbHxH.png"/>


### Contribución de los líderes de equipo <a name="contribucionBlanco"></a>

Por último, mediante los informas del Jira se va mostrar la **contribución de cada usuario** a las tareas asignadas a cada caso de uso, además del tiempo estimado que se espera que tarden dichas tareas en realizarse.

* **Señor Blanco**:

<img src="https://i.imgur.com/ca0aZZ0.png"/>

* **Señor Marron**:

<img src="https://i.imgur.com/qzs3Vg7.png"/>

* **Señor Naranja**:

<img src="https://i.imgur.com/P01Ugy6.png"/>

* **Señor Azul**:

<img src="https://i.imgur.com/WPeRALn.png"/>

Hay que concretar que dentro de este informe no se tienen en cuenta las **subtareas**, ni el tiempo que estas ocupan en cada usuario, por lo que puede variar entre distintos usuarios.

# Progreso del proyecto <a name="desarrolloProgreso"></a>

**Importante**: durante el desarrollo de la práctica de GPS, inicialmente se crearon las ramas referentes a los primeros 4 casos de uso. Seguidamente se implementaron los 4 casos de usos con sus commits (ligados a las tareas de Jira) y se integraron en la rama develop. En este instante, nos percatamos de que se nos había olvidado crear el resto de ramas (cu05-cu16), de manera que estas ramas se crearon a partir de la integracion de los primeros casos de uso en la rama develop.

## Síntesis de la planificación por roles <a name="sintesisPlanificacion"></a>

En este apartado se documentará la distribución de los casos de uso, realizados teniendo en cuenta el punto de vista de los roles, que participan en cada uno de los equipos, a modo de síntesis del apartado de configuración del seguimiento de planificación. 
En concreto, estos roles siguen la siguiente planificación:

<img src="https://imgur.com/dzITlYn.png"/>

Siendo cada uno de los roles el líder de uno de los 4 equipos.

Así mismo, la planificación de los roles respecto de las disciplinas de Implementación e Integración y Testeo es:

<img src="https://imgur.com/koHJTPj.png"/>

Para comprobar que este reparto de tareas es equitativo entre los distintos roles, a continuación se muestra el número de tareas asignadas a cada rol, en la que cada disciplina compartida por 2 roles es ponderada con 0,5 en cada rol:

**Distribución de implementaciones:**
| Encargado  | Casos de uso                                   | Núm |
| ---------- | ---------------------------------------------- | --- |
| Sr Blanco  | CU05, CU06, CU11, CU12, CU13, CU15, CU16       | 4,5 |
| Sr Marron  | CU03, CU09, CU13, CU14, CU15                   | 3   |
| Sr Naranja | CU01, CU02, CU03, CU04, CU05, CU06, CU07, CU08 | 5   |
| Sr Azul    | CU01, CU04, CU08, CU09, CU10, CU11             | 3,5 |

**Distribución de integraciones:**
| Encargado  | Casos de uso                       | Núm |
| ---------- | ---------------------------------- | --- |
| Sr Blanco  | CU06, CU09, CU10, CU14, CU15, CU16 | 4,5 |
| Sr Marron  | CU10,  CU11, CU12, CU14            | 3   |
| Sr Naranja | CU01, CU02, CU03, CU13             | 4   |
| Sr Azul    | CU04, CU05, CU06, CU07, CU08       | 4,5 |

## Proceso seguido del Equipo 1 (Sr. Blanco) <a name="desarrolloEquipo1"></a>

En este apartado se documentará todo el proceso seguido por el Equipo 1 para realizar los casos de uso, desde la implementación hasta la integración final. Se detalla **qué archivos se han modificado** concretamente y **cómo se ha realizado la integración** de estos casos de uso.

El equipo 1 será el encargado de llevar a cabo los casos de uso **CU01, CU02, CU03 y CU04.** A continuación se explicarán las tareas de implementación e integración que se han realizado en cada uno de ellos.

### CU01 - Añadir Evento de Municipio

Este caso de uso estructural permite al usuario añadir un nuevo evento de municipio en una fecha determinada, estando asignado a una condición meteorológica en tiempo real de la ubicación del municipio.

#### Implementación de CU01

Para realizar este caso de uso ha sido necesaria la creación de la clase Evento perteneciente a la lógica de negocio. Esta clase evento, además requirió emplear el servicio de Room para almacenar los eventos en la base de datos, por lo que también ha sido necesaria la realización de una interfaz EventoDao. Así mismo, en este caso de uso también se ha creado la clase **AppDatabase** para conectarse a la base de datos.

Así mismo, se han creado las clases necesarias para obtener todos los municipios existentes de España, que se encuentran en un documento **municipios.json.** Dichas clases son JsonSingleton, que permite obtener los datos del documento, y Municipio, que representa cada municipio obtenido.

Esta disciplina ha sido realizada en conjunto por el **Sr. Naranja** y el **Sr. Azul.**

Por tanto, en la realización de este caso de uso se han creado las siguientes clases:
* La Activity correspondientes a la pantalla de crear un evento de Municipio (CrearEventoActivity) y sus fragmentos (CrearEvento y CrearEventoMunicipio), junto con los layout correspondiente a dichos componentes software
* La clase Evento
* Una Interfaz EventoDao
* La clase AppDatabase
* Las clases correspondientes para obtener los municipios de la API (JsonSingleton y Municipio)

#### Integración de CU01

La integración de este caso de uso únicamente ha necesitado **la publicación del código terminado** lanzando una primitiva **Push** en la rama del repositorio correspondiente, pues no necesita la implementación de ningún otro caso de uso.

Esta disciplina ha sido realizada por el **Sr. Naranja.**

Una vez finalizada esta fase, se **integrará este caso de uso en la rama Develop** con todos los cambios de la rama correspondiente mediante un Merge, publicando después los cambios correspondientes en la rama Develop mediante la primitiva Push.

### CU02 - Añadir Evento de Ruta Montaña

Este caso de uso estructural permite al usuario añadir un nuevo evento de montaña en una fecha determinada, estando asignado a una condición meteorológica en tiempo real de la ubicación de la montaña.

#### Implementación de CU02
Para realizar este caso de uso ha sido necesaria la implementación del CU01 - Crear Evento de Municipio, que contiene las clases Evento y EventoDAO, utilizando también la clase **AppDatabase.**

Esto ha implicado la creación de un nuevo fragmento CrearEventoMontana en la actividad de creación de un evento (CrearEventoActivity), que permite crear un evento de montaña concreto a partir de las montañas existentes.

Esta disciplina ha sido realizada por el **Sr. Naranja.**

Por tanto, la implementación de este caso de uso ha supuesto la creación de la siguiente clase:

* El fragmento CrearEventoMontana y su layout

#### Integración de CU02

La integración de este caso de uso ha necesitado la integración previamente del caso de uso CU01, por lo que se ha realizado una primitiva **Merge** para trabajar sobre el código con este caso de uso realizado.

Posteriormente, una vez que el caso de uso está implementado, **se ha realizado la publicación del código** terminado en la rama del repositorio correspondiente lanzando una primitiva **Push.** Esta tarea la ha realizado el **Sr. Naranja.**

Una vez finalizada esta fase, se **integrará este caso de uso en la rama Develop** con todos los cambios de la rama correspondiente mediante un Merge, publicando después los cambios correspondientes en la rama Develop mediante la primitiva Push.

### CU03 - Añadir Usuario

Este caso de uso estructural permite al usuario registrarse con unas credenciales.

#### Implementación de CU03

Para realizar este caso de uso ha sido necesaria la implementación del CU02 - Añadir Ruta de Montaña, que crea un evento de Montaña en la base de datos.

Este caso de uso contiene las clases Usuario y UsuarioDAO, utilizando también la clase **AppDatabase.** 

Esta disciplina ha sido realizada en conjunto por el **Sr. Naranja** y el **Sr. Marrón.**

Por tanto, la implementación de este caso de uso ha supuesto la modificación de la siguiente clase:

* La Activity Main

Así mismo, ha supuesto la creación de las siguientes clases:

* Las Activity correspondiente a la pantalla de registro (Registrarse) y su layout
* La clase del modelo de datos Usuario
* Una Interfaz UsuarioDao

#### Integración de CU03

La integración de este caso de uso ha necesitado la integración previamente del caso de uso CU02 - Añadir Evento de Ruta Montaña.

Posteriormente, una vez que el caso de uso está implementado, **se ha realizado la publicación del código** terminado en la rama del repositorio correspondiente lanzando una primitiva **Push.** Esta tarea la ha realizado el **Sr. Naranja.**

Una vez finalizada esta fase, se **integrará este caso de uso en la rama Develop** con todos los cambios de la rama correspondiente mediante un Merge, publicando después los cambios correspondientes en la rama Develop mediante la primitiva Push.

### CU04 - Añadir una barra de búsqueda y filtrado de ubicaciones

Este caso de uso estructural consiste en la incorporación de una barra de búsqueda para buscar una ubicación con su tiempo meteorológico asignado.

#### Implementación de CU04

Para realizar este caso de uso ha sido necesaria la implementación del CU03 - Añadir Usuario, que contiene las clases Usuario y UsuarioDAO, utilizando también la clase AppDatabase.

Esta disciplina ha sido realizada en conjunto por el **Sr. Naranja** y el **Sr. Azul.**

La implementación de este caso de uso se ha completado, mediante la modificación de las siguientes clases:

* MainActivity. Incluye la incorporación del icono que redirige al listado de ubicaciones
* AndroidManifest
* Layout del menú main.xml

Además, se han añadido las siguientes clases:

* La actividad LocalizacionesActivity
* Clase APIManager y APIManagerDelegate

### Integración de CU04

La integración de este caso de uso ha necesitado la integración previamente del caso de uso CU03, por lo que se ha realizado una primitiva **Merge** para trabajar sobre el código con este caso de uso realizado.

Posteriormente, una vez que el caso de uso está implementado, **se ha realizado la publicación del código** terminado en la rama del repositorio correspondiente lanzando una primitiva **Push.** Esta tarea la ha realizado el **Sr Azul.**

Una vez finalizada esta fase, **se integrará este caso de uso en la rama Develop** con todos los cambios de la rama correspondiente mediante un Merge, publicando después los cambios correspondientes en la rama Develop mediante la primitiva Push.

## Proceso seguido del Equipo 2 (Sr. Marrón) <a name="desarrolloEquipo2"></a>

En este apartado se documentará todo el proceso seguido por el Equipo 2 para realizar los casos de uso, desde la implementación hasta la integración final. Se detalla **qué archivos se han modificado** concretamente y **cómo se ha realizado la integración** de estos casos de uso.

El equipo 2 será el encargado de llevar a cabo los casos de uso CU05, CU06, CU07 y CU08. A continuación se explicarán las tareas de implementación e integración que se han realizado en cada uno de ellos.

### CU05 - Añadir preferencias desde el menú de AppBar (ajustes …)

Este caso de uso estructural consiste en incorporar un apartado de configuración que permite al usuario personalizar su experiencia con la aplicación, así como el modo oscuro, preferencias, etc.

#### Implementación de CU05

Para realizar este caso de uso ha sido necesaria la implementación del caso de uso CU13 - Iniciar sesión, que contiene la clase IniciarSesion (Activity).

Esta disciplina ha sido realizada en conjunto por el **Sr. Naranja** y el **Sr. Blanco.**

La implementación de este caso de uso se ha completado mediante la modificación de las siguientes clases:

* Se ha modificado todos los archivos relativos al panel lateral de navegación, drawer, etc.

Además, se han añadido las siguientes clases:

* AjustesFragment y su correspondiente layout

#### Integración de CU05

La integración de este caso de uso ha necesitado la integración previamente del caso de uso CU13, por lo que se ha realizado una primitiva **Merge** para trabajar sobre el código con este caso de uso realizado.

Posteriormente, una vez que el caso de uso está implementado, **se ha realizado la publicación del código** terminado en la rama del repositorio correspondiente lanzando una primitiva **Push.** Esta tarea la ha realizado el **Sr Azul.**

Una vez finalizada esta fase, se **integrará este caso de uso en la rama Develop** con todos los cambios de la rama correspondiente mediante un Merge, publicando después los cambios correspondientes en la rama Develop mediante la primitiva Push.

### CU06 - Consultar el tiempo detallado de una ubicación

Este caso de uso no estructural permite al usuario visualizar el tiempo meteorológico de una ubicación específica en tiempo real.

#### Implementación de CU06

Para realizar este caso de uso ha sido necesaria la implementación del caso de uso CU04 - Añadir una barra de búsqueda y filtrado de ubicaciones, el cual incluye las clases java necesarias para realizar peticiones a la API. Se ha necesitado crear una nueva actividad que gestione el detalle del tiempo de una ubicación, de la lista de ubicaciones (municipios).

Esta disciplina ha sido realizada en conjunto por el **Sr. Naranja** y el **Sr. Blanco.**

La implementación de este caso de uso se ha completado mediante la modificación de las siguientes clases:

* Clase ListadoLocalizacionesActivity

Además, se han incluido la siguiente clase:

* DetalleLocalizaciónActivity y su layout

#### Integración de CU06

La integración de este caso de uso ha necesitado la integración previamente del caso de uso CU04, por lo que se ha realizado una primitiva **Merge** para trabajar sobre el código con este caso de uso realizado.

Posteriormente, una vez que el caso de uso está implementado, **se ha realizado la publicación del código** terminado en la rama del repositorio correspondiente lanzando una primitiva **Push.**

Esta disciplina ha sido realizada en conjunto por el **Sr. Azul** y el **Sr. Blanco.**

Una vez finalizada esta fase, **se integrará este caso de uso en la rama Develop** con todos los cambios de la rama correspondiente mediante un Merge, publicando después los cambios correspondientes en la rama Develop mediante la primitiva Push.

### CU07 - Modificar un evento

Este caso de uso no estructural permite al usuario modificar los datos de un evento, así como su nombre, descripción, fecha y ubicación.

#### Implementación de CU07

Para realizar este caso de uso ha sido necesaria la implementación del caso de uso CU06 - Consultar el tiempo detallado de una ubicación, el cual incluye los componentes software de Android necesarios para elegir y ver las condiciones meteorológicas de una ubicación específica.

Esta disciplina ha sido realizada por el **Sr. Naranja.**

La implementación de este caso de uso se ha completado mediante la modificación de las siguientes clases:

* La clase DAO de los eventos llamada EventoDAO

Además, se han creado las siguientes clases:

* Los fragmentos ModificarEventoMontanaFragment y ModificarEventoMunicipioFragment y sus respectivos layouts.

#### Integración de CU07

La integración de este caso de uso ha necesitado la integración previamente del caso de uso CU06, por lo que se ha realizado una primitiva **Merge** para trabajar sobre el código con este caso de uso realizado.

Posteriormente, una vez que el caso de uso está implementado, **se ha realizado la publicación del código** terminado en la rama del repositorio correspondiente lanzando una primitiva **Push.**

Esta disciplina ha sido realizada por el **Sr. Azul.**

Una vez finalizada esta fase, **se integrará este caso de uso en la rama Develop** con todos los cambios de la rama correspondiente mediante un Merge, publicando después los cambios correspondientes en la rama Develop mediante la primitiva Push.

### CU08 - Eliminar un evento

Este caso de uso no estructural permite al usuario borrar un evento creado y configurado previamente en la lista de eventos.

#### Implementación de CU08

Para realizar este caso de uso ha sido necesaria la implementación del CU01 - Crear Evento de Municipio y el caso CU02 - Crear Evento de Montaña, que contiene las clases Evento y EventoDAO, utilizando también la clase AppDatabase.

De esta forma se ha trabajado sobre el componente de detalles de un evento sobre el cual se ha añadido la funcionalidad de borrar el mismo. 

Por tanto, en la realización de este caso de uso se han creado la siguiente clase:

* La clase DeleteEventDialog

Esta disciplina ha sido realizada en conjunto por el Sr. Naranja y el Sr. Azul.

#### Integración de CU08

La integración de este caso de uso ha necesitado la integración previamente de los casos de uso  CU06, por lo que se ha realizado una primitiva **Merge** para trabajar sobre el código con este caso de uso realizado.

Posteriormente, una vez que el caso de uso está implementado, **se ha realizado la publicación del código** terminado en la rama del repositorio correspondiente lanzando una primitiva **Push.**

Esta disciplina ha sido realizada por el **Sr. Azul.**

Una vez finalizada esta fase, se **integrará este caso de uso en la rama Develop** con todos los cambios de la rama correspondiente mediante un Merge, publicando después los cambios correspondientes en la rama Develop mediante la primitiva Push.

## Proceso seguido del Equipo 3 (Sr. Naranja) <a name="desarrolloEquipo3"></a>

En este apartado se documentará todo el proceso seguido por el Equipo 3 para realizar los casos de uso, desde la implementación hasta la integración final. Se detalla **qué archivos se han modificado** concretamente y **cómo se ha realizado la integración** de estos casos de uso.

El equipo 3 será el encargado de llevar a cabo los casos de uso CU09, CU10, CU11 y CU12. A continuación se explicarán las tareas de implementación e integración que se han realizado en cada uno de ellos.

### CU09 - Consultar el tiempo meteorológico en la ubicación actual

Este caso de uso no estructural permite al usuario consultar los detalles del tiempo asociado a la localización/municipio más cercano.

#### Implementación de CU09

Para realizar este caso de uso ha sido necesaria la implementación del caso de uso CU08 - Eliminar un evento.

La implementación de este caso de uso se ha llevado a cabo mediante la modificación de los siguientes archivos:

* El fragmento InicioFragment

A su vez se han creado los siguientes nuevos archivos:

* Clase Weather
* Clase APIManager
* Clase APIManagerDelegate

Esta disciplina ha sido realizada en conjunto por el **Sr. Blanco** y el **Sr. Azul.**

#### Integración de CU09

La integración de este caso de uso ha necesitado la integración previamente del caso de uso CU08, por lo que se ha realizado una primitiva **Merge** para trabajar sobre el código con este caso de uso realizado.

Posteriormente, una vez que el caso de uso está implementado, **se ha realizado la publicación del código** terminado en la rama del repositorio correspondiente lanzando una primitiva **Push.**

Esta disciplina ha sido realizada por el **Sr. Blanco.**

Una vez finalizada esta fase, se **integrará este caso de uso en la rama Develop** con todos los cambios de la rama correspondiente mediante un Merge, publicando después los cambios correspondientes en la rama Develop mediante la primitiva Push.

### CU10 - Modificar idioma y tema a modo oscuro

Este caso de uso no estructural permite al usuario realizar una serie de modificaciones en la aplicación para configurar esta a su gusto como cambiar el idioma, el tema a modo oscuro, etc.

#### Implementación de CU10

Para la implementación de este caso de uso se han modificado la mayoría de actividades y fragmentos del proyecto.

Cabe mencionar la modificación del fragmento AjustesFragment en el cual se ha añadido la opción de activar el modo oscuro en la aplicación.

Finalmente todo el código referido a las características de ambos modos (oscuro y claro) se encuentra en los dos archivos themes del layout.

Esta disciplina ha sido realizada por el **Sr. Azul.**

#### Integración de CU10

La integración de este caso de uso ha necesitado la integración previamente del caso de uso CU09, por lo que se ha realizado una primitiva **Merge** para trabajar sobre el código con este caso de uso realizado.

Posteriormente, una vez que el caso de uso está implementado, **se ha realizado la publicación del código** terminado en la rama del repositorio correspondiente lanzando una primitiva **Push.**

Esta disciplina ha sido realizada en conjunto por el **Sr. Blanco** y el **Sr. Marrón.**

Una vez finalizada esta fase, **se integrará este caso de uso en la rama Develop** con todos los cambios de la rama correspondiente mediante un Merge, publicando después los cambios correspondientes en la rama Develop mediante la primitiva Push.

### CU11 - Consultar lista de eventos

Este caso de uso no estructural permite al usuario visualizar el listado completo de eventos de municipios y montañas creados por su parte.

#### Implementación de CU11

Para realizar este caso de uso ha sido necesaria la implementación del CU01 - Crear Evento de Municipio y el caso CU02 - Crear Evento de Montaña, que contiene las clases Evento y EventoDAO, utilizando también la clase AppDatabase.

La implementación de este caso de uso se ha completado mediante la creación de las siguientes clases:

* Clase java PlaceholderItem
* Fragmento ConsultaEventosFragment
* Fragmento ListaEventosFragment

Esta disciplina ha sido realizada en conjunto por el **Sr. Blanco** y el **Sr. Azul.**

#### Integración de CU11

La integración de este caso de uso ha necesitado la integración previamente del caso de uso CU10, por lo que se ha realizado una primitiva **Merge** para trabajar sobre el código con este caso de uso realizado.

Posteriormente, una vez que el caso de uso está implementado, **se ha realizado la publicación del código** terminado en la rama del repositorio correspondiente lanzando una primitiva **Push.**

Esta disciplina ha sido realizada por el **Sr. Marrón.**

Una vez finalizada esta fase, **se integrará este caso de uso en la rama Develop** con todos los cambios de la rama correspondiente mediante un Merge, publicando después los cambios correspondientes en la rama Develop mediante la primitiva Push.

### CU12 - Consultar un evento

Este caso de uso no estructural permite al usuario visualizar en detalle los datos pertinentes de un evento de municipio o montaña.

#### Implementación de CU12

Para realizar este caso de uso ha sido necesaria la implementación de los casos de uso CU01, CU02 y CU09 correspondientes con la creación de eventos y obtención de los datos metereológicos de una ubicación.

La implementación de este caso de uso se ha completado mediante la creación de las siguientes clases:

* Interfaz fragment_detalles_evento
* Interfaz activity_detalles_localizaciones
* Fragmento DetallesEventoFragment
* Actividad DetallesEventoActivity

Esta disciplina ha sido realizada por el **Sr. Blanco.**

#### Integración de CU12

La integración de este caso de uso ha necesitado la integración previamente del caso de uso CU11, por lo que se ha realizado una primitiva **Merge** para trabajar sobre el código con este caso de uso realizado.

Posteriormente, una vez que el caso de uso está implementado, **se ha realizado la publicación del código** terminado en la rama del repositorio correspondiente lanzando una primitiva **Push.**

Esta disciplina ha sido realizada por el **Sr. Marrón.**

Una vez finalizada esta fase, **se integrará este caso de uso en la rama Develop** con todos los cambios de la rama correspondiente mediante un Merge, publicando después los cambios correspondientes en la rama Develop mediante la primitiva Push.

## Proceso seguido del Equipo 4 (Sr. Azul) <a name="desarrolloEquipo4"></a>

En este apartado se documentará todo el proceso seguido por el Equipo 4 para realizar los casos de uso, desde la implementación hasta la integración final. Se detalla **qué archivos se han modificado** concretamente y **cómo se ha realizado la integración** de estos casos de uso.

El equipo 4 será el encargado de llevar a cabo los casos de uso CU13, CU14, CU15 y CU16. A continuación se explicarán las tareas de implementación e integración que se han realizado en cada uno de ellos.

### CU13 - Iniciar sesión

Este caso de uso no estructural permite al usuario iniciar sesión con las credenciales asociadas a su cuenta de usuario.

#### Implementación de CU13

Para realizar este caso de uso ha sido necesaria la implementación del caso de uso CU12 - Consultar un evento, el cual incluye las actividades y fragmentos DetallesEvento.

Esta disciplina ha sido realizada por el **Sr. Naranja.**

La implementación de este caso de uso se ha completado mediante la modificación de la siguiente clase:

* La clase MainActivity

Además, se han creado la siguiente clase:

* La actividad InicioSesion junto con su layout

#### Integración de CU13

La integración de este caso de uso ha necesitado la integración previamente del caso de uso CU12, por lo que se ha realizado una primitiva **Merge** para trabajar sobre el código con este caso de uso realizado.

Posteriormente, una vez que el caso de uso está implementado, **se ha realizado la publicación del código** terminado en la rama del repositorio correspondiente lanzando una primitiva **Push.**

Según la planificación de JIRA, esta disciplina la debe realizar tanto el Sr. Marrón como el Sr. Naranja. Sin embargo, en la realidad sólo la ha realizado el **Sr. Marrón,** y la tarea de integración del **Sr. Naranja** se ha puesto como estado a “Hecho”.

Una vez finalizada esta fase, **se integrará este caso de uso en la rama Develop** con todos los cambios de la rama correspondiente mediante un Merge, publicando después los cambios correspondientes en la rama Develop mediante la primitiva Push.

### CU14 - Cerrar sesión

Este caso de uso no estructural permite al usuario cerrar sesión.

#### Implementación de CU14

Para realizar este caso de uso ha sido necesaria la implementación del caso de uso CU05 - Añadir preferencias desde el menú de AppBar (ajustes …), el cual incluye el código necesario para la implementación de un apartado de Ajustes mediante la clase AjustesFragment.

Esta disciplina ha sido realizada por el **Sr. Marrón.**

La implementación de este caso de uso se ha completado mediante la modificación de la siguiente clase:

* La clase MainActivity
* El layout main.xml correspondiente al menú

#### Integración de CU14

La integración de este caso de uso ha necesitado la integración previamente del caso de uso CU05, por lo que se ha realizado una primitiva **Merge** para trabajar sobre el código con este caso de uso realizado.

Posteriormente, una vez que el caso de uso está implementado, **se ha realizado la publicación del código** terminado en la rama del repositorio correspondiente lanzando una primitiva **Push.**

Según la planificación de JIRA, esta disciplina la debe realizar tanto el Sr. Marrón como el Sr. Blanco. Sin embargo, en la realidad sólo la ha realizado el  **Sr. Marrón,** y la tarea de integración del **Sr. Blanco** se ha puesto como estado a “Hecho”.

Una vez finalizada esta fase, **se integrará este caso de uso en la rama Develop** con todos los cambios de la rama correspondiente mediante un Merge, publicando después los cambios correspondientes en la rama Develop mediante la primitiva Push.

### CU15 - Modificar usuario

Este caso de uso no estructural permite al usuario modificar su perfil de usuario, así como su nombre de usuario y contraseña.

#### Implementación de CU15

Para realizar este caso de uso ha sido necesaria la implementación del caso de uso CU14 - Cerrar sesión, el cual incluye el código necesario para cerrar la sesión de usuario.

Esta disciplina ha sido realizada por el Sr. Marrón y el Sr. Blanco.

Se ha modificado la clase EventoDAO, implementando la operación de la base de datos de eliminación de cuenta de usuario.

Además, se han creado la siguiente clase:

* El fragmento PerfilFragment y su layout

#### Integración de CU15

La integración de este caso de uso ha necesitado la integración previamente del caso de uso CU14, por lo que se ha realizado una primitiva **Merge** para trabajar sobre el código con este caso de uso realizado.

Posteriormente, una vez que el caso de uso está implementado, **se ha realizado la publicación del código** terminado en la rama del repositorio correspondiente lanzando una primitiva Push.

Esta disciplina la debe realizar el **Sr. Blanco.** 

Una vez finalizada esta fase, **se integrará este caso de uso en la rama Develop** con todos los cambios de la rama correspondiente mediante un Merge, publicando después los cambios correspondientes en la rama Develop mediante la primitiva Push.

### CU16 - Eliminar usuario

Este caso de uso no estructural permite al usuario modificar su perfil de usuario, así como su nombre de usuario y contraseña.

#### Implementación de CU16

Para realizar este caso de uso ha sido necesaria la implementación del caso de uso CU15, Modificar Usuario, el cual incluye la clase PerfilFragment.

Esta disciplina ha sido realizada por el **Sr. Blanco.**

Se ha modificado la clase EventoDAO, implementando la operación de la base de datos de eliminación de cuenta de usuario.

Además, se han creado la siguiente clase:

* El evento de diálogo DeleteDialogFragment

#### Integración de CU16

La integración de este caso de uso ha necesitado la integración previamente del caso de uso CU15, por lo que se ha realizado una primitiva **Merge** para trabajar sobre el código con este caso de uso realizado.

Posteriormente, una vez que el caso de uso está implementado, **se ha realizado la publicación del código** terminado en la rama del repositorio correspondiente lanzando una primitiva Push.

Esta disciplina la debe realizar el **Sr. Blanco.** 

Una vez finalizada esta fase, **se integrará este caso de uso en la rama Develop** con todos los cambios de la rama correspondiente mediante un Merge, publicando después los cambios correspondientes en la rama Develop mediante la primitiva Push.

### Análisis del progreso <a name="analisisProgreso2"></a>

Informe de Seguimiento del Tiempo
<img src="https://imgur.com/SXYFi4i.png"/>

En este primer informe podemos ver el progreso que llevamos del proyecto en función del tiempo que tenemos planeado dedicarle, dando como resultado que ya hemos hecho el **35%** de la carga del trabajo del proyecto quedando por tanto un **65% restante**.

Informe de gráfico de tarta en función del estado
<img src="https://imgur.com/XB5XUe1.png"/>

El segundo informe nos indica todas las tareas que ya hemos realizado del total, dándonos como que ya hemos realizado el 52% de las tareas y que quedan por hacer el 47%, en contraste con el informe anterior podemos ver que el porcentaje de tareas realizadas es mucho mayor que el de carga de trabajo, esto es porque las últimas tareas son las que más tiempo consumen.

Gráfica de trabajo hecho
<img src="https://imgur.com/kd2CDeL.png"/>

En el tercer informe vemos una gráfica del trabajo realizado conforme al tiempo, en este informe podemos ver en qué instante del tiempo se han ido realizando las distintas tareas hasta el día de hoy.


# Diseño de la interfaz de usuario <a name="diseñoInterfazUsuario"></a>

## Mapa de Navegación: pantallas, patrones y diagrama <a name="mapaNavegacion"></a>

### Diagrama de casos de uso <a name="diagramaCasosdeUso"></a>
A continuación se muestra el diagrama de casos de uso de la aplicación, todos referentes a las acciones que puede realizar el usuario y el sistema.

<img src="https://i.imgur.com/sHvsqqx.png"/>

### Diagrama de navegación <a name="diagramadeNavegacion"></a>
A continuación se muestra un posible diagrama de navegación que podría seguir la aplicación:

<img src="https://imgur.com/MzHCzeg.png"/>

### Mockup <a name="Mockup"></a>
A continuación se muestra un Mockup que contiene un conjunto de posibles pantallas del proyecto, a modo de prototipo que muestre las funcionalidades de la aplicación:

<img src="https://imgur.com/Fulg3ve.png"/>
<img src="https://imgur.com/BxExdwr.png"/>

<p>&nbsp;</p>
Como se puede observar, para poder utilizar la aplicación en primer lugar es necesario iniciar sesión contando con pantallas para iniciar sesión con una cuenta y otra para registrarse, pudiendo crear una cuenta nueva en caso de que esta no exista.

Una vez se ha iniciado sesión, la aplicación consta principalmente de 4 pantallas, siendo estas las siguientes:

* Una **pantalla principal**, que muestra el tiempo que hace (temperatura, clima…) en la ubicación actual del usuario, así como una lista con los eventos que ha creado, a través de la cual se pueden consultar los detalles (tiempo, entre otros) de este.

* Una pantalla destinada al **filtrado de eventos**, pudiendo buscar entre los distintos eventos creados por el usuario a través de una serie de filtros, como el tiempo actual que hace, lugar en el que se desarrolla el evento, etc.

* Una pantalla con el **perfil del usuario**, que muestra todos sus datos, pudiendo consultar o modificar estos, así como incluso borrar el usuario.

* Una pantalla de **ajustes**, que contiene los principales ajustes que se pueden aplicar a la app, como el tema claro/oscuro, notificaciones, etc.

Cabe destacar que tanto en la lista de todos los eventos ubicada en la pantalla principal como en las listas proporcionadas por la pantalla de filtrado de eventos, se pueden acceder a los datos de un evento tocando sobre estos, que mostrará una pantalla desde la que se pueden consultar sus datos (lugar, temperatura, clima, fecha, etc..) o incluso modificar algunos de ellos, pudiendo también borrar dicho evento de la app.

Así mismo, posee un panel lateral desplegable en la pantalla principal desde el que se pueden acceder a las principales funcionales de la aplicación, siendo estas:

* **Inicio**: Un acceso a la propia pantalla principal.
* **Eventos**: Un acceso a la lista de eventos que ha creado el usuario para poder filtrarlos.
* **Perfil**: Un acceso al perfil del usuario.
* **Ajustes**: Un acceso a la pantalla con los principales ajustes de la aplicación.

### Grafo de navegación <a name="grafodeNavegacion"></a>

<img src="https://imgur.com/9r1yf8r.png"/>

### Patrones de navegación aplicados <a name="patronesNavegacion"></a>  
   
En este apartado se muestran todos los patrones de navegación que se han utilizado para la realización de la aplicación, siendo estos los siguientes:

* Patrón de lista y detalle.
* Patrón de cajón de navegación.
* Patrón de botones y objetivos sencillos.

A continuación se detallarán cada uno de los patrones implementados.

🔹 Patrón de lista y detalle

Para desplazarse por la aplicación se ha utilizado un patrón de lista y detalle referente a la pantalla de inicio, que mostrará los elementos de más interés para el usuario, en este caso una lista con todos los eventos que ha creado.

De la misma forma, en la pantalla de lista de eventos también se ha aplicado este patrón para buscar una lista de eventos concretos a través de la pantalla de filtrado de eventos.

Así mismo, a través de estas listas, se puede acceder a una pantalla que permite consultar los detalles de un evento concreto tocando sobre dicho evento de la lista, que llevará a una pantalla que muestra sus datos.

<img src="https://i.imgur.com/Q3Fyb60.png"/>
<p>&nbsp;</p>

🔹 Patrón de cajón de navegación

En lo referente a cada una de las funcionalidades, se utilizará un **patrón de cajón de navegación**, creando un menú lateral desplegable desde el que se puede navegar entre funcionalidad y funcionalidad, pudiendo cambiar rápidamente de pantalla a través de dicho menú lateral.

🔹 Patrón de botones y objetos sencillos

Finalmente, se ha aplicado el patrón de botones y objetivos sencillos mostrando mediante botones con iconos intuitivos en ciertas funcionalidades, de manera que permitan a los usuarios acceder más fácilmente a dichas funcionalidades.

<img src="https://i.imgur.com/jPea9kb.png"/>

# Diseño arquitectónico <a name="diseñoArquitectonico"></a>

## Diagrama e interacción de componentes <a name="diagramaComponentes"></a>

A continuación se muestra un diagrama con todos los principales componentes que conforman el sistema:

<img src="https://i.imgur.com/0RFY7NO.jpg"/>

Estos componentes pueden clasificarse en 3 tipos:

* **Componentes de interfaz de usuario**: Son aquellos que interactúan directamente con el usuario, ofreciéndoles las diversas funcionalidades (crear un evento, consultar la lista de eventos, modificar estos, etc).

* **Repositorios**: Consisten en los componentes que hacen la función de repositorios, utilizados en el patrón Repository para obtener los datos de fuentes externas y son utilizados en otros componentes a través de los viewmodel. Se trata de los componentes EventRepository, UserRepository y LocationRepository.

* **Componentes que enlazan fuentes externas**: Se trata de los componentes que permiten acceder a  datos de fuentes externas, como la base de datos de Room (AppDatabase), los ficheros Json con municipios y montañas (JsonSingleton) o la api que obtiene la información del clima (ApiManager).

Así mismo, entre los componentes presentados en el diagrama anterior existen las siguientes interacciones:

* El **usuario interactúa con la aplicación** utilizando la interfaz de usuario (UI) definida por los componentes Android y sus layouts, agrupados en el paquete “Interfaz de usuario”. Esto se representa con la relación entre el actor usuario y la interfaz “operaciones IU”.

* El componente **JsonSingleton** ofrece la interfaz “obtenerMunicipiosMontañas”, requerida por el componente CrearEvento.

* Los **componentes de la interfaz del usuario acceden**, a través de los distintos viewmodels, **a los diferentes repositorios** que existen dentro de AppContainer (UserRepository, LocationRepository y EventRepository) para almacenar y obtener datos de fuentes externas. Por ello, cada componente del patrón repository ofrece interfaces “viewmodel” que son utilizadas por los componentes de la interfaz de usuario.

* La agrupación de componentes de tipo **Repository** (UserRepository, LocationRepository y EventRepository) hacen uso de las operaciones de la Room, a través de las interfaces DAO ofrecidas por el componente AppDataBase, para realizar operaciones en la base de datos.

* El componente **APIManager** proporciona las peticiones pertinentes a la API OpenWeather mediante la interfaz “obtenerTiempo”,  requerida por los repositorios EventRepository, donde cada evento tiene asociado el tiempo meteorológico según la ubicación; LocationRepository, donde cada localización (municipio) tiene asignado unas condiciones meteorológicas.

## Patrones arquitectónicos <a name="patronesArquitectonicos"></a>

#### Patrón Repository
Se ha optado por unificar todas las fuentes de datos creando una sola instancia que permita acceder a todos los datos.

<img src="https://imgur.com/XH3atJm.png"/>

Para ello, se han creado una serie de Repositorios asociados a los objetos del modelo de datos que son almacenados en la base de datos y accedidos desde la app. 

La clase **EventRepository** permitirá acceder tanto a los datos procedentes de la api (APIManager) como a la información que se encuentra en la base de datos de Room (AppDatabase).  La clase de repositorio aísla las fuentes de datos del resto de la app, una capa intermedia entre la capa de dominio y la capa de acceso de datos. Usar una clase de repositorio garantiza que este código sea independiente de la clase ViewModel y es una práctica recomendada para la separación del código y su arquitectura.

Por demás,  un evento tiene asociado datos relacionados con el tiempo meteorológico proporcionados por la API. Si el usuario desea consultar los detalles de un evento consultado recientemente, **EventRepository** se encarga de cargar los datos de la Room (o caché). En el caso de consultar los detalles de un evento en un periodo de tiempo superior al umbral establecido, entonces se realiza una petición a la API OpenWeather y se actualiza la caché con los datos retornados de la API.

Así mismo, también se ha creado una clase **LocationRepository** la cual permitirá acceder a los datos de la API (APIManager) como fuente de datos externa y al modelo de Room (LocationDAO), en el que se manejan las localizaciones alojadas (municipios). De esta manera, el repositorio hará de capa intermedia entre la app (los ViewModels) y estas fuentes de datos.

Del mismo modo, se ha creado una clase **UserRepository** la cual permitirá acceder a los usuarios de Room. 

En el proceso de implementación de este patrón, se consideraron una serie de cambios relativos al modelo de datos de la aplicación propuesto en una versión temprana, con el objetivo de implementar la memoria caché.
* Para comprobar si se requiere una actualización del tiempo meteorológico de un evento, es conveniente almacenar la información del tiempo dentro del propio objeto Evento. Por ello, se ha modificado la entidad Evento incluyendo los atributos relativos al tiempo meteorológico, que anteriormente se encontraba en la clase Weather. 
* Por ende, al consultar los detalles de un evento, se comprueba si es necesario recuperar los datos asociados al tiempo de dicho evento desde la caché o actualizar la base de datos con los datos devueltos de la API.
* Creación de una clase Location, que almacena toda la información (tiempo) relativa a una ubicación concreta. Esta clase sustituye a la anterior Weather, que se introducirá dentro de la clase Evento.
* Creación de una interfaz dao LocationDAO relativa a la gestión de objetos Location en la base de datos. 

Tras todas estas modificaciones, el modelo de datos resultante utilizado en la base de datos sería el siguiente:

<img src="https://imgur.com/uMSEZGA.png"/>

**Ventajas de usar un repositorio**
Un módulo de repositorio controla operaciones de datos y te permite usar varios backends. En una app real típica, el repositorio implementa la lógica para decidir si debe recuperar datos de una red o usar resultados almacenados en caché de una base de datos local. 

Con un repositorio, puedes intercambiar los detalles de la implementación, como la migración a una biblioteca de persistencia diferente, sin afectar el código de llamada, como los modelos de vista. Esto también permite que tu código sea modular y se pueda probar. Puedes simular con facilidad el repositorio y probar el resto del código.

Un repositorio debe funcionar como una única fuente de verdad para una parte específica de los datos de tu app. Cuando se trabaja con varias fuentes de datos, como un recurso conectado en red y una caché sin conexión, el repositorio garantiza que los datos de la app sean lo más precisos y actualizados, lo que proporcionará la mejor experiencia posible incluso cuando la app esté sin conexión.

#### Patrón Model - View - ViewModel (MVVM)
Con el objetivo de incrementar la seguridad de la aplicación y gestionar los datos de forma más rápida y eficiente se ha implementado el patrón Model - View - ViewModel (MVVM).
 
Se han implementado los siguientes viewmodels:

* ListaEventosViewModel: Viewmodel que permite gestionar los datos de la lista de eventos del fragmento ListaEventosFragment.
* DetallesEventoViewModel: Viewmodel que gestiona los datos al mostrar los detalles de un evento en el fragmento DetallesEventoFragment.
* TiempoActualViewModel: Viewmodel que gestiona el tiempo actual mostrado en el fragmento de inicio InicioFragment.
* DetallesLocalizacionViewModel: Viewmodel que gestiona el tiempo de una ubicación concreta en la actividad DetalleLocalizacionActivity.
* IniciarSesionViewModel: Viewmodel que gestiona el inicio de sesión en la actividad InicioSesion.
* RegistrarseViewModel: Viewmodel que gestiona la pantalla de registro de usuario en la actividad Registrarse.
* PerfilViewModel: Viewmodel que gestiona la consulta y modificación del usuario en el fragmento PerfilFragment.
* BorrarPerfilViewModel: Viewmodel que permite eliminar el usuario en el fragmento DeleteDialogFragment.
* ModificarEventoViewModel: Viewmodel que gestiona los detalles relativos a la pantalla de modificar un evento del fragmento ModificarEventoFragment.
* mainUsuarioViewModel: Viewmodel que permite comprobar y cerrar la sesión del usuario en MainActivity.

Cabe mencionar que los ViewModels tienen una dependencia relacionada con un Repository específico. Para solventar la escalabilidad de código de nuestra aplicación respecto la adicción de nuevas dependencias a los ViewModel, se ha implementado el patrón de diseño Factory para crear instancias ViewModel de manera sencilla. Además, ante el crecimiento de dependencias de la app como los repositorios, AppDataBase y factories, entre otros; se han agrupado como atributos en una clase Singleton llamada AppContainer, la cual es instanciada por primera vez en una nueva clase llamada MyApplication que extiende Application. Para iniciar esta clase, se ha modificado el AndroidManifest incrustando un atributo android:name=”.MyApplication”.

El recurso de ViewModel destaca como el componente que se encargará de servir como puente entre la interacción de la Vista (View) y el Modelo (Model).

Entre sus ventajas encontramos:

* Su capacidad para separar de forma limpia la presentación de una aplicación determinada y la lógica del negocio de su interfaz de usuario. Lo que contribuye a abordar múltiples tipos de inconvenientes de desarrollo, prueba, mantenimiento y evolución del sistema.
* Permite que los desarrolladores creen pruebas unitarias para el Model View y el modelo, sin que sea necesario el uso de la vista.
* Los encargados del diseño y desarrollo de aplicaciones pueden ser capaces de trabajar de manera simultánea e independiente, cada uno en sus componentes durante los procesos de la app.
* ViewModel permite la conservación tanto en el estado que contiene un ViewModel como en las operaciones que esté activa. Este almacenamiento en caché significa que no necesitas recuperar datos mediante cambios de configuración comunes, como una rotación de pantalla.
* SaveStateHandle te permite conservar datos no solo a través de cambios de configuración, sino también durante la recreación de procesos. Es decir, te permite mantener el estado de la IU intacto, incluso cuando el usuario cierra la app y la abre más adelante.
* Reducción de la complejidad: al separar la lógica de presentación de la lógica de negocio en componentes distintos, el código de la aplicación se vuelve más fácil de entender y mantener.
* Mayor reutilización de código: debido a que la lógica de presentación y la lógica de negocio están separadas, se pueden reutilizar fácilmente en diferentes vistas y contextos.
* Mejora del rendimiento: el patrón MVVM permite que la vista se actualice automáticamente cuando los datos cambien en el modelo, lo que reduce la cantidad de código que se debe escribir y mejora el rendimiento de la aplicación.


# Gestión del entorno <a name="gestionEntorno"></a>

En este apartado se abordarán todos los detalles sobre el entorno en el que se ha llevado a cabo el proyecto, comprendiendo desde las características que poseen hasta los pasos que se han seguido para configurar dichos entornos.

## Gestión de la configuración <a name="gestionConfiguracion"></a>

### Entorno utilizado <a name="entornoUtilizado"></a>

En concreto, para la realización de este proceso se han utilizado 2 herramientas, una para la **codificar la aplicación** (y posteriormente ejecutar el código implementado) y otra para **almacenar el código creado por los integrantes del equipo**, pudiendo compartirse este y permitiendo integrarlo todo en un repositorio Git. A continuación se explicarán cada una de estas herramientas.

#### Herramienta de implementación: Android Studio <a name="androidStudio"></a>

Android Studio es una herramienta de codificación y ejecución de programas y aplicaciones para dispositivos Android basada en IntelliJ IDEA.

Este consiste en un software que permite programar en lenguajes como Java o Kotlin aplicaciones para posteriormente poder ser ejecutada en dispositivos con versiones de Android superiores a 3.0.

Además de ofrecer las mismas herramientas para desarrolladores de IntelliJ, Android Studio ofrece incluso más funciones, entre otras:

* Un sistema de compilación flexible basado en Gradle
* Un emulador rápido y cargado de funciones
* Un entorno unificado donde puedes desarrollar para todos los dispositivos Android
* Aplicación de cambios para insertar cambios de código y recursos a la app en ejecución sin reiniciarla
* Integración con GitHub y plantillas de código para ayudarte a compilar funciones de apps comunes y también importar código de muestra
* Variedad de marcos de trabajo y herramientas de prueba
* Herramientas de Lint para identificar problemas de rendimiento, usabilidad y compatibilidad de versiones, entre otros
* Compatibilidad con C++ y NDK
* Compatibilidad integrada con [Google Cloud Platform](https://cloud.google.com/tools/android-studio/docs/?hl=es-419), que facilita la integración con Google Cloud Messaging y App Engine

Así mismo, ofrece la funcionalidad de acceso y manejo de bases de datos gracias al soporte con Room, así como la posibilidad de ejecutar un programa en un dispositivo con AVD que va desde teléfonos inteligentes de varios modelos y marcas, hasta tablets, televisiones y ordenadores, entre otros.

#### Estructura de un proyecto en Android Studio <a name="estructuraProyecto"></a>

En concreto, un proyecto en android studio se compone de las siguientes partes:

* **manifests**: consiste en un fichero llamado AndroidManifest.xml que contiene información adicional de la aplicación como el nombre de la aplicación, el icono que utilizará el launcher, qué actividad es la principal, los parámetros del intent (intent-filters) por los que se puede filtrar la aplicación, entre otros.
* **java**: contiene los archivos de código fuente Java, incluido el código de prueba de JUnit, este suele constar en clases y enumeraciones en Java, así como las diferentes actividades y fragmentos de los que se componen las interfaces de usuario.
* **res**: contiene todos los recursos sin código, como diseños XML, strings de IU e imágenes de mapa de bits, suele ofrecer todas las imágenes y prediseños que utilizarán los proyectos como recursos.

![](https://i.imgur.com/U2pox55.png)

A continuación se muestran las diferentes vistas que componen la interfaz del programa.

#### Componentes de la interfaz de Android Studio <a name="componentesInterfaz"></a>

**Android Studio** ofrece una serie de vistas y componentes en su interfaz que ofrecen información sobre un proyecto. Dentro de una ventana, se encuentran los siguientes componentes:

![](https://i.imgur.com/LX57g2i.png)

* La **barra de herramientas** te permite realizar una gran variedad de acciones, como ejecutar tu app e iniciar las herramientas de Android.
* La **barra de navegación** te ayuda a explorar tu proyecto y abrir archivos para editar. Proporciona una vista más compacta de la estructura visible en la ventana Project.
* La **ventana del editor** es el área en la que puedes crear y modificar código. Según el tipo de actividad actual, el editor puede cambiar. Por ejemplo, cuando ves un archivo de diseño, el editor muestra el Editor de diseño.
* La **barra de la ventana de herramientas** se encuentra afuera de la ventana del IDE y contiene los botones que te permiten expandir o contraer ventanas de herramientas individuales.
* Las **ventanas de herramientas** te brindan acceso a tareas específicas, como la administración de proyectos, la búsqueda, el control de versiones, entre otras. Puedes expandirlas y contraerlas.
* En la **barra de estado**, se muestra el estado de tu proyecto y el IDE, además de advertencias o mensajes.

#### Funcionamiento de una App en Android Studio <a name="funcionamientoApp"></a>

Este software utiliza las llamadas actividades (Activity) para ejecutarlas como pantallas individuales. Estas son archivos en código Java que indican el funcionamiento de todos los eventos que suceden y las acciones que se realizan dentro de una pantalla de la aplicación. 

Estas tienen el diseño indicado en el layout de dicha actividad, que consiste en un fichero xml que se encuentra en la carpeta res > layout, y que codifica cómo se mostrará la pantalla y los elementos que compondrán la interfaz.

Adicionalmente existen los fragmentos (Fragment), que consisten en ficheros java que permiten contener el funcionamiento de una actividad en una pantalla, permitiendo existir varios fragmentos en una misma Activity. Estos se pueden intercambiar por otros en cualquier momento, permitiendo a la aplicación un comportamiento más dinámico.

Una actividad se puede comunicar con otra a través de los llamados Intent, que son clases que permiten a una actividad llamar a otra. Cada instancia de la clase “intent contiene la clase de la actividad que llama a la siguiente, la clase de la actividad llamada, y otros datos adicionales como información que se quiere pasar en la llamada.

Una aplicación puede obtener los recursos como imágenes o iconos a través de la carpeta drawable, dentro de res. Esta contiene los recursos que se utilizan referente a los iconos, imágenes predeterminadas, etc.

Finalmente, cabe destacar el fichero strings.xml, que contiene todas las cadenas que se mostrarán en la aplicación de forma dinámica. Pudiendo cambiarse sin tener que acceder al código. Esto dota de independencia al sistema de asignación de cadenas ya que no necesitan modificar directamente el código para cambiarse, teniendo que modificar únicamente el fichero. Para acceder al archivo strings.xml debe escribirse la cadena @string/ seguido del identificador que se haya puesto en el campo name de la etiqueta <string> que identifica a la cadena que se quiere insertar.

En el siguiente apartado se explicará el funcionamiento del componente Gradle.

#### Compilación en Gradle <a name="compilacionGradle"></a>

Android Studio usa Gradle como base del sistema de compilación, y el [complemento de Android para Gradle](https://developer.android.com/studio/releases/gradle-plugin?hl=es-419) proporciona capacidades específicas de Android. Este sistema de compilación se ejecuta en una herramienta integrada desde el menú de Android Studio, y lo hace independientemente de la línea de comandos. El propósito de las funciones del sistema de compilación es el siguiente:

* Personalizar, configurar y extender el proceso de compilación
* Crear varios APK para tu app; diferentes funciones usan el mismo proyecto y los mismos módulos
* Volver a usar códigos y recursos en conjuntos de archivos fuente

Gracias a la flexibilidad de Gradle, se puede lograr sin modificar los archivos fuente de la aplicación. Los archivos de compilación de Android Studio se denominan build.gradle. Son archivos de texto sin formato que usan la sintaxis [Groovy](http://groovy-lang.org/) a fin de configurar la compilación con elementos que proporciona el complemento de Android para Gradle. 

Cada proyecto tiene un archivo de compilación de nivel superior para todo el proyecto y archivos de compilación de nivel de módulo independientes para cada módulo. Cuando se importa un proyecto existente, Android Studio genera automáticamente los archivos de compilación necesarios.

#### Integración de Jira en Android Studio <a name="integracionJira"></a>
Con el objetivo de poder informar sobre las tareas de implementación o integración que se realizan en el proyecto se ha optado por la sincronización del programa de **Android Studio** con el software **Jira**, de manera que a lo largo de la realización del proyecto se puedan actualizar el estado de las tareas a través del propio Android Studio.
 
Para llevar a cabo la integración de Jira con el software de Android Studio se pueden seguir dos caminos:
* Utilizando la herramienta de contexto que viene predefinida dentro de Android Studio.
* Utilizando un plugin que nos permite interaccionar con Jira a través de Android Studio.

A continuación se explica cada uno de estas opciones.

#### Integración de Jira en Android Studio a través de la herramienta de contexto <a name="integracionJiraHerramienta"></a>
Lo primero que debemos hacer es configurar el servidor de Jira, para ello deberemos irnos a Tools > Tasks & Contexts > Configure Servers…, que se encuentra en la parte superior izquierda del programa.

<img src="https://i.imgur.com/7eqmC0F.png"/>

Una vez accedido a este apartado debería de aparecer una ventana de diálogo como la siguiente.

<img src="https://i.imgur.com/hCr3Y9N.png"/>

Dentro de esta ventana deberemos seleccionar el botón de “+” y seleccionar el tipo de Server al cual queremos acceder, en nuestro caso será el Server de Jira.

<img src="https://i.imgur.com/Y1PyTWq.png"/>

Una vez seleccionado el servidor aparecerán los registros que deberemos de rellenar para acceder a este.

<img src="https://i.imgur.com/03vfufz.png"/>

Estos atributos son los siguientes:
* **Server URL**: La url en la que se encuentra el servidor.
* **Username**: El nombre de usuario de la conexión que se va a realizar.
* **Password**: La contraseña asociada a dicho nombre de usuario.
* **Search**: Corresponde a una serie de asignaciones de valores a ciertos parámetros configuración

Esta debe rellenarse con los datos de la conexión a nuestro proyecto de Jira en cuestión, siendo estos la url del servidor de Jira (http://jira.spilab.es:8080/), el nombre de uno de los usuarios del proyecto y su contraseña, como se muestra a continuación:

<img src="https://i.imgur.com/yI2rKD4.png"/>

Una vez dado al botón ‘**ok**’, y si los datos se han puesto de forma correcta se accederá a servidor de Jira.

Ahora podremos empezar a realizar tareas, para ello deberemos de acceder a la lista de tareas a través de Tools > Tasks & Contexts > Open Task…

<img src="https://i.imgur.com/TJmQFz0.png"/>

Una vez hecho esto podremos seleccionar la tarea de Jira que queremos empezar a desarrollar buscándola dentro de la lista que nos aparece.

<img src="https://i.imgur.com/Xj1PuEE.png"/>

Al seleccionarla nos aparecerá una ventana similar a la siguiente, en la cual deberemos de elegir en qué rama vamos a realizar dicha tarea.

<img src="https://i.imgur.com/8N8a8C7.png"/>

Una vez acabemos de trabajar, tan solo tendremos que realizar un **commit** en el cual indicamos el id de la tarea, su título y el autor que la realiza. Además de esto se pueden añadir más cosas como un comentario o el tiempo dedicado a dicha tarea utilizando **Smart commits**, pero no es necesario.

#### Integración de Jira en Android Studio a través de un plugin <a name="integracionJiraPlugin"></a>
Esta opción contempla el uso de un plugin de Android studio que permite gestionar las tareas de un proyecto de Jira, de manera que se podrá actualizar el estado de estas y asociarlas a ramas  de git concretas.

Por ello, se determinará que cada tarea de implementación estará asociada a una rama con el código de un caso de uso.

Para descargar el plugin, se debe acceder a la sección de plugins. Esto se puede realizar haciendo clic en la opción **Settings** de la pestaña **Files** y buscando en este dicha sección plugins.

<img src="https://i.imgur.com/TgFE5s2.png"/>

Esto abrirá una ventana con las opciones de configuración de Android Studio. 

<img src="https://i.imgur.com/I7i3DbC.png"/>

También es posible acceder a esta ventana a través del icono con forma de rueda situado en la parte superior derecha de Android Studio, pulsando posteriormente en la opción **plugins**.

<img src="https://i.imgur.com/cuz6tV3.png"/>

La ventana de plugins posee 2 pestañas, una para buscar un plugin dentro de todos aquellos que están instalados y otra para buscar todos los plugins y poder instalar nuevos.

En la pestaña de instalación de nuevos plugins (**Marketplace**) se debe buscar el plugin llamado **Jira Software**, haciendo clic en el botón **Install** de este y comenzando su instalación.

Una vez instalado, nos aparecerá en la parte inferior, en la cual si presionamos el botón de configuración nos aparecerá una ventana para conectarnos al servidor de Jira, la cual deberemos rellenar con los siguientes datos:
* **Server URL**: La url en la que se encuentra el servidor.
* **Username**: El nombre de usuario de la conexión que se va a realizar.
* **Password**: La contraseña asociada a dicho nombre de usuario.

<img src="https://i.imgur.com/pyzTJep.png"/>
Con esto ya podemos trabajar con Jira seleccionando la tarea que queramos realizar y mediante el botón de <strong>transit</strong>, seleccionando la tarea como en progreso:

<img src="https://i.imgur.com/wAvATbE.png"/>

Este plugin además nos da todas las opciones que podemos realizar a través de la web dentro de Android Studio, lo que nos permite prescindir del uso del navegador.

#### Ramas utilizadas en el proyecto <a name="ramas"></a>

En concreto, en este proyecto se utilizará una rama master que contendrá el código final de la aplicación, además de una rama develop. A partir de la develop, se crean las 16 ramas correspondientes a los 16 casos de uso.

**Importante**: durante el desarrollo de la práctica de GPS, inicialmente se crearon las ramas referentes a los primeros 4 casos de uso. Seguidamente se implementaron los 4 casos de usos con sus commits (ligados a las tareas de Jira) y se integraron en la rama develop. En este instante, nos percatamos de que se nos había olvidado crear el resto de ramas (cu05-cu16), de manera que estas ramas se crearon a partir de la integracion de los primeros casos de uso en la rama develop.

Inicialmente, la estructura de estas ramas era la siguiente:

* master
  * develop
    * cu01. (Equipo 1)
    * cu02
    * cu03
    * cu04
    * cu05. (Equipo 2)
    * cu06
    * cu07
    * cu08
    * cu09. (Equipo 3)
    * cu10
    * cu11
    * cu12
    * cu13. (Equipo 4)
    * cu14
    * cu15
    * cu16

## Integración continua <a name="integracionContinua"></a>

La integración continua en el desarrollo del proyecto es el conjunto de prácticas que consisten en hacer integraciones automáticas de compilación y ejecución de test, para detectar fallos lo antes posible. De acuerdo a las tareas de integración definidas en JIRA, se usa la tecnología GIT sobre la plataforma GitHub para completar la integración continua entre las ramas de los casos de uso CU01-CU16 con la rama develop, y entre la rama develop con la rama master.

La integración continua es una práctica moderna que facilita el trabajo a los desarrolladores sobre el código de un mismo proyecto. Algunas ventajas que presenta son las siguientes:

* Los desarrolladores pueden detectar y solucionar problemas de integración de forma continua, evitando el caos de última hora cuando se acercan las fechas de entrega.
* Disponibilidad constante de una versión para pruebas, demos o lanzamientos anticipados.
* Ejecución inmediata de las pruebas unitarias.
* Monitorización continua de las métricas de calidad del proyecto.

Esta disciplina consistirá en 2 tareas:

* Integración de cada subsistema o “Integrate each subsystem”
* Integración del sistema “Integrate the system”

## Definición de disciplinas

En este apartado se explicará el proceso que seguirá en cada disciplina relativa al desarrollo de la aplicación, siendo estas **Implementación** e **Integración y Testeo.**

### Implementación

Esta disciplina se divide en 2 tareas:

* “Implement components”
* “Test components”

Este proceso consistirá únicamente en la disciplina de <strong>“Implement components”</strong>
Esta corresponde a la implementación del caso de uso correspondiente utilizando Android Studio a quien tenga asignada dicha implementación según la planificación del Jira. 

Para ello, el rol asignado debe marcar en Jira la tarea correspondiente del estado **TO-DO** al estado **In Progress.** El código debe contener tanto las pantallas (Activitys y Fragments) que muestran el código, como los componentes de la lógica de negocio (clases), así como las posibles interfaces DAO que deban intervenir.

Todo el código deberá funcionar correctamente y contener toda la funcionalidad completa de ese caso de uso.

Una vez finalizada la implementación del código en Android Studio, se deberá marcar el estado de la tarea correspondiente a **DONE.** Confirman los cambios realizados en este desde el inicio de la implementación mediante el lanzamiento de un commit, que guardará los cambios realizados en el repositorio local.

Este commit se deberá enlazar con la tarea correspondiente en el jira, guardando los cambios realizados y relacionándolos con esta.

### Integración y Testeo

#### Integración de cada subsistema

La tarea **Integrate each subsystem** consistirá en recuperar el código depositado en el repositorio que está ubicado en la rama Develop a la rama correspondiente del caso de uso, permitiendo mediante la realización de un **Pull** trabajar sobre los cambios ya realizados en la rama Develop.

Este proceso también debe actualizar la tarea del Jira correspondiente marcando su estado según si es **TO-DO** (por realizar), **In Progress** (realizándose) o **DONE** (realizada).

Una vez finalizada la última tarea de implementación de un caso de uso y subido con un push a la rama remota “origin/CUxx”, siendo ‘xx’ el número del caso de uso, se procede a integrar dicho caso de uso con el resto del proyecto que se encuentra en la rama remota “origin/develop”. 

En primer lugar, se debe realizar un merge del estilo <origin/develop into “CUxx”> y resolver los conflictos que aparezcan. De esta forma, se pretende unificar el caso de uso implementado con el nuevo código subido por otro equipo a la rama remota “origin/develop”.

En este instante, se dispone del código de los subsistemas integrados en el último caso de uso implementado junto con el commit resultante del merge. Estas tareas de integración no contienen un commit adicional, por tanto, desde Android Studio se modifica el estado de la tarea de integración de subsistemas a ‘Hecho’ y el autor de la tarea coincide con el usuario logueado en el servidor de JIRA en Android Studio.

#### Integración del sistema

Por otra parte, la tarea **“Integrate the system”** consistirá subir en el repositorio remoto compartido por todos los integrantes el código del caso de uso ya completamente implementado mediante la realización de un **Push,** que lo publicará en la rama del repositorio correspondiente.

Una vez hecho esto en todas las ramas, se deben integrar todos los casos de uso de la ramas correspondientes en la rama Develop mediante la realización de un merge, que unificará todos los casos de uso realizados en la rama Develop, que posteriormente subirá todo el código integrado a la rama master.

Cabe destacar que también se debe relacionar este proceso con la tarea correspondiente en el Jira, modificando su estado como **TO-DO** (por realizar), **In Progress** (realizándose) o **DONE** (realizada).

Una vez finalizada la integración de cada subsistema, se procede a cometer la siguiente tarea de integración desbloqueada llamada integración del sistema. Primero, se hace un checkout de la rama “develop” para tenerla en local. En ella, se procede a hacer un nuevo merge del estilo  <“CUxx” into “develop”> para mantener en la rama local “develop” la integración del sistema, exenta de errores. Por último, queda hacer un push de la rama local “develop” en la remota “origin/develop” para finalizar la tarea de integración de sistema.

En este instante, si se comete una nueva tarea de integración de cada subsistema de otro caso de uso, el miembro del equipo responsable de dicho caso de uso tendrá que integrar su subsistema al resto de subsistemas, incluido el nuestro.

Por último, cuando todas las ramas de los 16 casos de uso se encuentren implementadas e integradas en la rama remota “develop”, sólo queda integrar la rama “develop” con la rama remota “master”, quedando así finalizado el desarrollo de la aplicación Android, a espera de futuras mejoras y pruebas.


# Implementación <a name="implementacion"></a>

En este apartado se documentará todo el proceso de **implementación** que se ha seguido en el proyecto, desde su planificación hasta las clases implementadas que componen la aplicación, pasando por decisiones de implementación como su sintaxis, patrones de diseño, etc.

Este se puede apreciar en el siguiente diagrama de clases, que contiene los principales componentes del modelo de datos:

<img src="https://i.imgur.com/6q2Uk6u.png"/>

En primera instancia, existe una entidad en la Room llamada **Usuario** que se encarga de almacenar las credenciales procedentes de un usuario durante el registro. Contiene los siguientes campos:

* 'idu' (int). Contiene el identificador de una tupla de Usuario en la base de datos.
* 'username' (String). Contiene el nombre de usuario introducido durante el registro.
* 'password' (String). Contiene la contraseña introducida durante el registro.
* 'conectado' (booleano). Almacena el valor ‘true’ si el usuario se encuentra conectado en la aplicación, ‘false’ en caso de no estar logueado.

El usuario puede crear eventos en la aplicación. Existen dos tipos de eventos: aquellos cuya ubicación se encuentra en un municipio y aquellos cuya ubicación se encuentra en una montaña. Sin embargo, se ha tomado la decisión de no almacenar las condiciones meteorológicas de la ubicación de un evento (atributo de tipo Weather que se detalla posteriormente) en la base de datos, puesto que el tiempo meteorológico es dinámico y cambia respecto pasan las horas o días. Como consecuencia de ello, en la base de datos no se hace diferencia respecto a los dos tipos de eventos, sino que sendos eventos se representan con una **única entidad Evento** en el modelo de la Room.

Esta clase contiene los siguientes atributos:

* 'ide' (int). Contiene el identificador de una de las muchas tuplas de Evento en la base de datos.
* 'titulo' (String). Contiene el título del evento introducido durante su creación.
* 'ubicacion' (String). Contiene una cadena relativa a la ubicación del evento. Si es un evento de municipio, contiene el nombre del municipio. En caso de ser un evento de montaña, contiene el nombre de la montaña.
* 'descripcion' (String). Contiene la descripción del evento introducida por el usuario durante la creación del evento.
* 'esMunicipio' (boolean). Valor booleano que sirve para diferenciar en la misma entidad si es un evento de municipio o de montaña.
* 'fecha' (Date). Contiene la fecha en la que se da el evento. Tiene un formato del estilo ‘dd/MM/yy’. No se opta por contener las horas, minutos ni segundos. Este atributo de la entidad es sumamente importante, a partir de él se realizará una llamada a la API del tiempo para obtener las condiciones meteorológicas del evento en ese día.

Se requiere de una clase que almacene las condiciones meteorológicas al hacer una llamada a la API del tiempo, independientemente del tipo de evento (Municipio o Montaña) y de la petición del tiempo de la ubicación actual. Esta clase es la llamada Weather y contiene los siguientes atributos:

* 'ciudad' (String). Contiene el nombre del municipio o montaña de la ubicación sobre la que se obtiene el tiempo.
* 'gifResource' (int). Contiene un código numérico referente al estado del tiempo (“Lluvia”, “Soleado”, etc). Este código se mapeará dinámicamente en un GIF para personalizar la interfaz relativa al tiempo meteorológico.
* Los atributos relativos a las condiciones meteorológicas:
  * 'temperatura' (int)
  * 'sensTermica' (int)
  * 'tempMinima' (int)
  * 'tempMaxima' (int)
  * 'presion' (int)
  * 'humedad' (int)
  * 'velocidadViento' (double)
  * 'estadoTiempo' (String)
  * 'descEstadoTiempo' (String)

Se ha mencionado que los eventos tienen asignado una ubicación de montaña o municipio según lo considere el usuario durante su creación, que junto con la búsqueda del tiempo en la ubicación actual del dispositivo, es necesario incluir en la aplicación un archivo JSON que contengan todos los **municipios** de España y otro archivo destinado a las **montañas** de España. 

* El JSON de municipios se ha obtenido de un archivo excel de la página oficial de AEMET. Como el excel incorporaba columnas innecesarias, se ha transformado para incluir el código de municipio: concatenación del código de provincia (3 dígitos)  + código de municipio (2 dígitos), el nombre del municipio y el nombre de la provincia a la que pertenece. Seguidamente, se manejó un conversor online XLS to JSON para obtener el JSON final para poseer todos los municipios listos para usarse en la app.

  [https://beautifytools.com/excel-to-json-converter.php](https://beautifytools.com/excel-to-json-converter.php)

* El JSON de montañas se ha creado manualmente (sólo existen 9 montañas en España) , como consecuencia de la API OpenWeather, la cual solo permite realizar una petición del tiempo de una montaña en base a sus coordenadas (longitud, latitud). Por lo tanto, siguiendo el mismo proceso que en el JSON de municipios, un objeto de montaña del JSON contiene la latitud, longitud y el nombre de la montaña.

Para convertir los objetos del JSON en objetos java y cargarlos en nuestra aplicación, se han diseñado dos clases java con la herramienta jsonSchema2Pojo, obteniendo las clases Montana y Municipio.

[https://www.jsonschema2pojo.org](https://www.jsonschema2pojo.org)

## Estructura del proyecto <a name="estructura"></a>

Se ha llevado a cabo una división de la estructura del proyecto en distintos módulos.

Dentro de la carpeta <strong>json</strong> se encuentran aquellos modelos de datos que no se guardan en la base de datos sino que almacenan en tiempo de ejecución los datos extraídos de los archivos con extensión json.

El módulo de <strong>Room</strong> contiene aquellas clases involucradas con la base de datos:
* **DAO**: Los archivos Dao
* **Javadb**: Herramientas utilizadas en la conversión de datos de los modelos.
* **Modelo**: Clases modelo que almacenan la información de cada entidad.

En el módulo <strong>utils</strong> se encuentran las dos clases que trabajan con la API.

En el módulo UI se encuentran aquellas actividades y fragmentos que interactuan con la interfaz de la aplicación:
* **Ajustes**: Actividad y fragmento de ajustes
* **Eventos**: Actividades y fragmentos correspondientes a las operaciones CRUD sobre las entidades de Eventos.
* **Inicio**: Fragmento de inicio de la aplicación
* **ListaEventos**: Contiene aquellas clases involucradas en mostrar y filtrar los eventos en el caso de uso de la lista.
* **Localizaciones**: Componentes relacionados con el caso de uso de filtrado y búsqueda de localizaciones
* **Perfil**: Actividades y fragmentos correspondientes a las operaciones CRUD sobre la entidad de usuario.

<img src="https://i.imgur.com/wROWjBQ.png"/>



## Detalles de implementación <a name="detallesImplementacion"></a>

En este apartado se describen aspectos esenciales de la implementación de la aplicación Android, así como patrones de diseños y aspectos novedosos dentro de ámbito de la asignatura ASEE.

### Patrones de Diseño <a name="patronesDiseño"></a>

A lo largo del proceso de desarrollo de este proyecto se han incluido una serie de Patrones de Diseño en su implementación, que expresan esquemas para definir estructuras de diseño (o sus relaciones) con las que construir sistemas de software. Facilitan la codificación, seguridad y consistencia a la aplicación durante su ejecución.
Los patrones de diseño utilizados se indican a continuación.

#### Patrón Singleton

El patrón de diseño Singleton es un patrón de diseño creacional que gestiona la creación de objetos de una clase concreta, de manera que solo pueda existir una única instancia en tiempo de ejecución.

<img src="https://i.imgur.com/CY12Ege.png"/>

Esto se consigue gracias a que la clase que implementa este patrón sigue las siguientes condiciones:

* Posee un atributo privado y estático del tipo de la clase, que será la única instancia en tiempo de ejecución.
* El constructor de la clase es de tipo privado.
* Posee un método público y estático getInstance que devolverá el atributo de la clase declarado como privado. De forma que si el atributo aún no está inicializado (atributo == null) previamente se creará mediante el constructor privado. Y si ya está inicializado, lo devolverá directamente.

De esta forma, cada vez que se tenga que utilizar un objeto de esta clase, se invocará utilizando llamando al método getInstance() de forma estática desde el nombre de la clase (Clase.getInstance()), que devolverá siempre la misma instancia del objeto que utiliza el patrón.

Se ha utilizado el Patrón singleton en la creación de la clase AppDatabase, que crea y gestiona la base de datos, ya que con este la clase sólo podrá tener una única instancia en tiempo de ejecución para no tener que inicializarla varias veces, y acceder siempre a la misma para modificar la base de datos.

Así mismo, también se ha utilizado en la creación de la clase JsonSingleton, que permite obtener todos los datos relativos al clima de las montañas y municipios cargándose de la API. De, esta forma, se pueda acceder a todos los municipios y montañas existentes junto con la información sobre su clima en cualquier parte del programa, permitiendo más facilmente la consulta de los datos de estos por el usuario o su asignación a eventos.

Ventajas del patrón Singleton
* La propia clase es responsable de crear la única instancia. Por medio de su método constructor.
* Permite el acceso global a dicha instancia mediante un método de clase.
* Declara el constructor de clase como privado para que no sea instanciable directamente.
* Al estar internamente autoreferenciada, en lenguajes como Java, el recolector de basura no actúa.
* Se puede ejercer un control preciso sobre cuándo y cómo se accede a él.

#### Patrón DAO

El patrón de diseño Data Access Object (DAO) es un patrón de diseño Arquitectónico que permite gestionar el desarrollo de una aplicación que utiliza bases de datos (persistencias de datos) al separar todos los componentes del sistema en 3 tipos bien definidos:

* Componentes relacionados con el **modelo de datos** y la lógica de negocio (clases del diagrama)
* Componentes destinados a la **transferencia de datos**, encargados de conectarse a la base de datos o modificarla. Implementan el patrón de diseño **Data Transference Object** (DTO).
* Componentes destinados al **acceso a datos**, conectados con los de transferencia de datos para enviar la información a la lógica de negocio, aislando los detalles de implementación. Se tratan de interfaces que son implementadas por los componentes de transferencia, permitiendo ocultar detalles concretos sobre la implementación de la conexión a la base de datos.

<img src="https://i.imgur.com/DoqeMVr.png"/>

Este patrón permite **separar la lógica de datos** de la forma de acceder a estos con conexiones a la base de datos, pues los componentes de acceso a datos son capaces de implementar varios tipos de componente de transferencia de datos, lo que permite **modificar** el tipo de acceso a la base de datos sin afectar la aplicación, pudiendo incluso **tener varios tipos de acceso a datos** al mismo tiempo.

Este patrón se ha utilizado durante la inclusión del servicio Room en Android Studio, ya que este utiliza las interfaces DAO creadas para implementar los componentes de transferencia de datos, que almacenarán la información en las clases de la lógica de negocio (declaradas como Entity), conectándose a la base de datos a través de la clase AppDatabase.

<img src="https://i.imgur.com/FhC2n0x.png"/>

Esta clase **AppDatabase**, que deberá ser abstracta, se utilizará para recuperar información y modificar la base de datos, pues devolverá las interfaces DAO que contienen la información y pueden manipular la base de datos.

A su vez, **las interfaces DAO** modificarán y accederán los valores de los componentes del modelo de datos a través de los métodos getters y setters definidos de estos. Así mismo, estos componentes DAO contarán con métodos que según como se marquen realizan distintas operaciones en la base de datos, siendo la inserción (Insert), modificación (Update), borrado (Delete) y consulta (Query).

Por otra parte, **los componentes de la lógica de negocio** serán las clases marcadas como Entity, que compondrán la estructura de la base de datos y almacenarán la información recuperada de esta.

Ventajas de utilizar el patrón DAO:
* Es fácil de implementar
* Permite separar por completo la lógica de acceso a datos en una capa separada y así solo trabajar con la lógica de negocio sin preocuparnos de donde viene los datos o los detalles técnicos para consultarlos o actualizarlos.
* Puede funcionar en conjunto con el patrón Repository.

### Refactorización <a name="refactorización "></a>

#### Patrón Repository
Se ha optado por unificar todas las fuentes de datos creando una sola instancia que permita acceder a todos los datos.

<img src="https://imgur.com/XH3atJm.png"/>

Para ello, se han creado una serie de Repositorios asociados a los objetos del modelo de datos que son almacenados en la base de datos y accedidos desde la app. 

La clase **EventRepository** permitirá acceder tanto a los datos procedentes de la api (APIManager) como a la información que se encuentra en la base de datos de Room (AppDatabase).  La clase de repositorio aísla las fuentes de datos del resto de la app, una capa intermedia entre la capa de dominio y la capa de acceso de datos. Usar una clase de repositorio garantiza que este código sea independiente de la clase ViewModel y es una práctica recomendada para la separación del código y su arquitectura.

Por demás,  un evento tiene asociado datos relacionados con el tiempo meteorológico proporcionados por la API. Si el usuario desea consultar los detalles de un evento consultado recientemente, **EventRepository** se encarga de cargar los datos de la Room (o caché). En el caso de consultar los detalles de un evento en un periodo de tiempo superior al umbral establecido, entonces se realiza una petición a la API OpenWeather y se actualiza la caché con los datos retornados de la API.

Así mismo, también se ha creado una clase **LocationRepository** la cual permitirá acceder a los datos de la API (APIManager) como fuente de datos externa y al modelo de Room (LocationDAO), en el que se manejan las localizaciones alojadas (municipios). De esta manera, el repositorio hará de capa intermedia entre la app (los ViewModels) y estas fuentes de datos.

Del mismo modo, se ha creado una clase **UserRepository** la cual permitirá acceder a los usuarios de Room. 

En el proceso de implementación de este patrón, se consideraron una serie de cambios relativos al modelo de datos de la aplicación propuesto en una versión temprana, con el objetivo de implementar la memoria caché.
* Para comprobar si se requiere una actualización del tiempo meteorológico de un evento, es conveniente almacenar la información del tiempo dentro del propio objeto Evento. Por ello, se ha modificado la entidad Evento incluyendo los atributos relativos al tiempo meteorológico, que anteriormente se encontraba en la clase Weather. 
* Por ende, al consultar los detalles de un evento, se comprueba si es necesario recuperar los datos asociados al tiempo de dicho evento desde la caché o actualizar la base de datos con los datos devueltos de la API.
* Creación de una clase Location, que almacena toda la información (tiempo) relativa a una ubicación concreta. Esta clase sustituye a la anterior Weather, que se introducirá dentro de la clase Evento.
* Creación de una interfaz dao LocationDAO relativa a la gestión de objetos Location en la base de datos. 

Tras todas estas modificaciones, el modelo de datos resultante utilizado en la base de datos sería el siguiente:

<img src="https://imgur.com/uMSEZGA.png"/>

**Ventajas de usar un repositorio**
Un módulo de repositorio controla operaciones de datos y te permite usar varios backends. En una app real típica, el repositorio implementa la lógica para decidir si debe recuperar datos de una red o usar resultados almacenados en caché de una base de datos local. 

Con un repositorio, puedes intercambiar los detalles de la implementación, como la migración a una biblioteca de persistencia diferente, sin afectar el código de llamada, como los modelos de vista. Esto también permite que tu código sea modular y se pueda probar. Puedes simular con facilidad el repositorio y probar el resto del código.

Un repositorio debe funcionar como una única fuente de verdad para una parte específica de los datos de tu app. Cuando se trabaja con varias fuentes de datos, como un recurso conectado en red y una caché sin conexión, el repositorio garantiza que los datos de la app sean lo más precisos y actualizados, lo que proporcionará la mejor experiencia posible incluso cuando la app esté sin conexión.

#### Patrón Model - View - ViewModel (MVVM)
Con el objetivo de incrementar la seguridad de la aplicación y gestionar los datos de forma más rápida y eficiente se ha implementado el patrón Model - View - ViewModel (MVVM).
 
Se han implementado los siguientes viewmodels:

* ListaEventosViewModel: Viewmodel que permite gestionar los datos de la lista de eventos del fragmento ListaEventosFragment.
* DetallesEventoViewModel: Viewmodel que gestiona los datos al mostrar los detalles de un evento en el fragmento DetallesEventoFragment.
* TiempoActualViewModel: Viewmodel que gestiona el tiempo actual mostrado en el fragmento de inicio InicioFragment.
* DetallesLocalizacionViewModel: Viewmodel que gestiona el tiempo de una ubicación concreta en la actividad DetalleLocalizacionActivity.
* IniciarSesionViewModel: Viewmodel que gestiona el inicio de sesión en la actividad InicioSesion.
* RegistrarseViewModel: Viewmodel que gestiona la pantalla de registro de usuario en la actividad Registrarse.
* PerfilViewModel: Viewmodel que gestiona la consulta y modificación del usuario en el fragmento PerfilFragment.
* BorrarPerfilViewModel: Viewmodel que permite eliminar el usuario en el fragmento DeleteDialogFragment.
* ModificarEventoViewModel: Viewmodel que gestiona los detalles relativos a la pantalla de modificar un evento del fragmento ModificarEventoFragment.
* mainUsuarioViewModel: Viewmodel que permite comprobar y cerrar la sesión del usuario en MainActivity.

Cabe mencionar que los ViewModels tienen una dependencia relacionada con un Repository específico. Para solventar la escalabilidad de código de nuestra aplicación respecto la adicción de nuevas dependencias a los ViewModel, se ha implementado el patrón de diseño Factory para crear instancias ViewModel de manera sencilla. Además, ante el crecimiento de dependencias de la app como los repositorios, AppDataBase y factories, entre otros; se han agrupado como atributos en una clase Singleton llamada AppContainer, la cual es instanciada por primera vez en una nueva clase llamada MyApplication que extiende Application. Para iniciar esta clase, se ha modificado el AndroidManifest incrustando un atributo android:name=”.MyApplication”.

El recurso de ViewModel destaca como el componente que se encargará de servir como puente entre la interacción de la Vista (View) y el Modelo (Model).

Entre sus ventajas encontramos:

* Su capacidad para separar de forma limpia la presentación de una aplicación determinada y la lógica del negocio de su interfaz de usuario. Lo que contribuye a abordar múltiples tipos de inconvenientes de desarrollo, prueba, mantenimiento y evolución del sistema.
* Permite que los desarrolladores creen pruebas unitarias para el Model View y el modelo, sin que sea necesario el uso de la vista.
* Los encargados del diseño y desarrollo de aplicaciones pueden ser capaces de trabajar de manera simultánea e independiente, cada uno en sus componentes durante los procesos de la app.
* ViewModel permite la conservación tanto en el estado que contiene un ViewModel como en las operaciones que esté activa. Este almacenamiento en caché significa que no necesitas recuperar datos mediante cambios de configuración comunes, como una rotación de pantalla.
* SaveStateHandle te permite conservar datos no solo a través de cambios de configuración, sino también durante la recreación de procesos. Es decir, te permite mantener el estado de la IU intacto, incluso cuando el usuario cierra la app y la abre más adelante.
* Reducción de la complejidad: al separar la lógica de presentación de la lógica de negocio en componentes distintos, el código de la aplicación se vuelve más fácil de entender y mantener.
* Mayor reutilización de código: debido a que la lógica de presentación y la lógica de negocio están separadas, se pueden reutilizar fácilmente en diferentes vistas y contextos.
* Mejora del rendimiento: el patrón MVVM permite que la vista se actualice automáticamente cuando los datos cambien en el modelo, lo que reduce la cantidad de código que se debe escribir y mejora el rendimiento de la aplicación.


### Aspectos novedosos y decisiones tomadas <a name="aspectosNovedosos"></a>

#### Reglas de Sintaxis <a name="reglasSintaxis"></a>

Para realizar la implementación del proyecto, previamente se han establecido una serie de reglas de sintaxis que deben seguir los elementos implementados en Android Studio. Estas son las siguientes:
* En lo referente a los identificadores (atributo **id**) de cada pantalla que se encuentra en los grafos de navegación, estos deberán comenzar con la cadena "nav_", representando que se tratan de las pantallas de navegación que conforman el proyecto.
* Cada actividad que se haya creado, deberá finalizar su nombre con la subcadena “Activity”, mientras que cada fragmento creado, deberá finalizar con la subcadena “Fragment”. Esto aporta más consistencia al proyecto.
* Dado que el nombre de cada layout debe ser en minúsculas, el layout (archivo .xml) de una Activity deberá comenzar por la cadena “activity_”, mientras que el layout de un Fragment deberá comenzar por la cadena “fragment_” y el layout que funciona como contenedor de otros fragmentos deberá comenzar por la cadena “content_”.

#### Gestión de la API <a name="gestionAPI"></a>

En primer lugar se ha decidido no hacer uso de **Retrofit** para la gestión y configuración de la API.

En su lugar, esta funcionalidad se encuentra en una sola clase **APIManager** que seguirá un patrón de delegación mediante una interfaz **APIManagerDelegate** la cual se añade como atributo de aquel componente que quiera hacer uso de la API y así poder implementar los métodos de esta interfaz cuando las llamadas a la API devuelven un resultado.

De esta forma todo el networking de la aplicación se encuentra en la misma clase, cuando a los métodos que hacen referencia a las distintas llamadas a la API. La llamada a la API se realiza mediante una petición asíncrona haciendo uso de la **librería AsyncHttpClient** ahorrándonos así la creación y gestión de un hilo.

#### Obtención de localización <a name="obtencionLocalizacion"></a>

Uno de los casos de uso de la aplicación, requiere de obtener las coordenadas (longitud y latitud) de la ubicación del dispositivo. Para ello es necesario comprobar que se tienen los permisos de **GPS**, los cuales se comentan en el siguiente apartado. Una vez se tienen los permisos mediante un **LocationManager** se obtienen del proveedor de internet dichas coordenadas.

#### Gestión de Permisos <a name="gestionPermisos"></a>

Este apartado detalla la solicitud de los permisos necesarios para el correcto funcionamiento de la aplicación.

Los permisos (que no se hayan concedido) siempre se piden al iniciar la aplicación mediante la clase **Launch**. En caso de no conceder los de GPS, puesto que forman parte de una funcionalidad básica y esencial de la aplicación, no se podrá acceder a la misma hasta que no se otorguen.

Una vez concedidos los permisos, la aplicación comprueba en todo momento que estos sigan estando concedidos antes de ejecutar alguna operación que los requiera. En caso de no estar otorgados porque el usuario los haya quitado mientras está usando la aplicación, esta gestionaría correctamente la ausencia de permisos sin generar errores.

En el hipotético caso de necesitar nuevos permisos en el desarrollo de la aplicación, el código ha sido modularizado de forma que únicamente habría que añadir el nombre de dichos permisos al vector de permisos de la clase **Launch** (deberían estar presentes en el archivo manifest).

#### Carga de municipios y montañas desde JSON <a name="cargaJSON"></a>

La lista de montañas necesaria para el spinner del caso de uso de Crear Evento de Montaña junto a sus coordenadas se encuentra almacenada en un archivo json. De igual forma para el caso de uso de filtrado de localizaciones se ha hecho uso de una lista de todos los municipios de España la cual también se encuentra almacenada en un archivo json.

Ambos archivos son cargados en un mapa de Java gestionado como una única instancia accesible desde cualquier lugar de la aplicación (Singleton) en la clase **JsonSingleton** al iniciar la aplicación por primera vez. Haciendo uso de la librería Gson obtenemos la información del json en los modelos **Municipio** y **Evento** que posteriormente se almacenarán en los mapas del singleton.


#### Menú de Hamburguesa <a name="menuHamburguesa"></a>

Hemos decidido la utilización de un **menú de hamburguesa** como métodos de navegación entre las pantallas principales de nuestra aplicación.

Este menú nos permite que el usuario pueda navegar entre las cuatro pantallas principales de la aplicación sin que esto ocupe espacio de pantalla, este menú contiene las pantallas **inicio**, **eventos**, **perfil** y **ajustes**, dejando para la barra de navegación la búsqueda de ubicaciones y el botón de cerrar sesión.

Para su implementación se ha utilizado la main activity como contenedora del menú de hamburguesa y de los diferentes fragmentos de inicio, eventos, perfil y ajustes.

De esta manera hemos conseguido que de una forma compacta todo lo que tiene relación con la navegación de la app.

#### Filtro de Eventos <a name="filtroEventos"></a>

Dentro de la pantalla de la lista de eventos hemos implementado un filtro que nos permite diferenciar los diferentes eventos que haya guardado el usuario, tanto por tipo de evento como teniendo en cuenta o bien el orden de creación del evento o la fecha de dicho evento.

Para los tipos de evento hemos decidido que la filtración se haga con un Tab, intercambiando entre los eventos de municipio y los eventos de montaña.

Para filtrar por orden de creación o de fecha de evento, hemos decidido crear un spinner que nos permite seleccionar entre las dos opciones.

Con esto conseguimos que se intercalan los dos tipos de filtrados que hacemos pudiendo obtener así cuatro configuraciones distintas:

1. Municipios ordenados por fecha de creación del evento
2. Municipios ordenados por fecha del evento
3. Montañas ordenadas por fecha de creación del evento
4. Montañas ordenadas por fecha del evento

De esta forma podemos darle todas las opciones que el usuario necesita para filtrar sus eventos de una manera cómoda y sencilla.

#### Usuario único <a name="usuarioUnico"></a>

En esta aplicación hemos implementado el usuario de tal forma que solamente existe un único usuario, esto se ha hecho así debido a que el usuario se guarda de manera local y no en remoto, y también a que no hemos concebido la aplicación para qué se guarden diferentes cuentas dentro de nuestra aplicación, sino como una lista local de eventos.

#### Implementación de Spinners en diversos campos <a name="spinners"></a>

Se han implementado campos con el tipo de Spinners en los **campos de Montaña** de las pantallas destinadas a crear un evento de Montaña (layout del fragmento CrearEventoMontana) y modificar un evento de montaña (layout del fragmento ModificarEventoMontana) con el objetivo de seleccionar una montaña existente del conjunto obtenido del JSON para crear o modificar un evento.

De esta forma, se asegura que tras seleccionar el nombre de la montaña en la creación o modificación de eventos, esta no sea errónea, pues se ha tenido que elegir un nombre existente entre las montañas cargadas, ahorrandole al usuario el hecho de probar hasta dar con el nombre exacto de la montaña.

Así mismo, también se ha implementado un campo de Spinner para especificar **el tipo de Ordenación** que se aplicará al filtrar todos los eventos, en la sección **Eventos**. Dicho campo con el tipo de ordenación permitirá organizar los eventos por orden de creación o por fecha.

#### Filtrado de localizaciones <a name="filtradoLocalizaciones"></a>

Una vez iniciada sesión, desde la pantalla principal se puede acceder a la funcionalidad de filtrado de localizaciones si se pulsa el icono de lupa de la ToolBar.

Se inicia una nueva actividad que se encarga de leer el **listado de municipios** de España desde la colección de tipo mapa instanciada en el SingletonJSON y se utiliza un **Adapter** como intermediario entre la obtención de los municipios con el layout. 

En el layout, se define un nuevo elemento **SearchView**, parecido a un input que permite actualizar en tiempo real la lista de municipios, de acuerdo a la cadena introducida por el usuario. 

En el código de la actividad **LocalizacionesActivity**, se define un listener para el SearchView, sobreescribiendo un método llamado **onQueryTextChange(String text)**. Dentro, se llama a una función filtradora llamada **filter(text)** y se le pasa la cadena del SearchView introducida por el usuario. En la función de filtrado, se inserta en una variable auxiliar (ArrayList) aquellos municipios que coinciden con la cadena introducida, mediante la función findWithPrefix(municipios, cadena). 

Por último, al disponer de la nueva colección de municipios filtrados, queda actualizar la lista de items del Adapter y notificar que se ha modificado para actualizar la interfaz con los nuevos municipios coincidentes.

Esto **permite** al usuario buscar una localidad sin necesidad de que este sepa su nombre exacto, el cual es necesario tanto para crear un evento como para ver el tiempo actual en una localidad.

#### Modo Oscuro <a name="modoOscuro"></a>

El modo oscuro es un ajuste de configuración que se encuentra en la sección “Ajustes” del menú hamburguesa. Se ha implementado con las **Preferencias** que nos ofrece la API de Android. Por defecto, el tema de la aplicación es el modo oscuro. 

Cuando se activa el **checkbox**, desde el fragmento “AjustesFragment” se modifica el valor relativo al nuevo tema de la aplicación en las **SharedPreferences** , gracias a su **editor**. A continuación, se realiza un callback a la actividad “MainActivity” que soporta el fragmento. La función del callback se encarga de leer el archivo SharedPreferences modificado y delega el cambio de tema de la aplicación al **AppCompat**, recreando de nuevo la actividad y sus fragmentos involucrados para que la interfaz se actualice en base al nuevo tema.

Por otro lado, se incluyen dos archivos en la carpeta de recursos de la aplicación llamados theme (uno con la configuración de la interfaz en modo claro y el otro en modo oscuro). En estos archivos theme, se definen unos estilos que serán intercambiados según la configuración de la aplicación.

En el resto de componentes de la aplicación, se realiza el mismo proceso. En el caso de las actividades sin fragmentos, en el **onResume()** se llama al método que se encarga de leer SharedPreferences y delegar el cambio de tema.

Entre las ventajas que existen a la hora de que nuestra aplicación tenga modo oscuro destacan las siguientes:

* Es saludable para los ojos: Ahorrándole al usuario molestias visuales.
* Se visualiza mejor en la oscuridad.
* Prolonga la vida de la batería: Utilizando menos brillo, o incluso con el apagado de los píxeles de la mayor parte de la pantalla en los paneles OLED.
* Mejora la accesibilidad: Muchas personas con diferentes problemas de vista pueden encontrar en esta opción una forma de visualizar mejor el contenido.

# Gestión de la calidad del Software <a name="gestionCalidadSoftware"></a>

En este apartado se describen las pruebas realizadas a la aplicación Android, así como el análisis del código para solventar problemas.
Pruebas

En primer lugar, se implementan los test **unitarios**, los cuales son más simples de implementar y suelen identificar un mayor número de bugs o problemas. Estos presentan una serie de características:
* Deben ser muy pequeños
* Deben estar centralizados en funcionalidades muy específicas.
* Se recomienda la realización de test locales
* Normalmente, no es necesario realizar test instrumentalizados.

Existen multitud de frameworks para implementar test unitarios como JUNIT, Cactus, Mockito, etc. Se ha elegido JUnit, un framework para escribir test unitarios repetibles que pueden ser fácilmente integrados en cualquier proyecto Java. Es uno de los frameworks más importantes para el desarrollo del concepto Test-Driven Development.

Se utiliza la librería JUnit para implementar los test unitarios asociados a las tareas “Test Components” de cada caso de uso. Para ello, en el build.gradle se incluyen las siguientes  librerías:

<code>testImplementation 'junit:junit:4.12'</code>
<br />
<code>testImplementation 'androidx.test:core:1.4.0'</code>
<br />
<code>androidTestImplementation 'androidx.test:core:1.4.0'</code>
<br /><br />
<code>androidTestImplementation 'androidx.test:runner:1.4.0'</code>
<br />
<code>androidTestImplementation 'androidx.test:rules:1.4.0'</code>
<br />
<code>androidTestImplementation 'androidx.test.espresso:espresso-core:3.4.0'</code>

Los test unitarios se almacenan en un paquete de pruebas llamado “test”. Los test son clases java con anotaciones de JUnit, que le indican al “Runner” por defecto del framework Android cómo se deben ejecutar las clases test. 

Respecto a los nombres de los test unitarios, estos deben describir el funcionamiento/objetivo del test, qué caso de uso se está testeando y deben incluir el sufijo <_UnitTest>.

Los test <strong>funcionales</strong> conllevan un mayor tiempo de implementación y de ejecución, aunque también proporcionan una mayor fiabilidad.
* Normalmente, evalúan las funcionalidades de la aplicación.
* Tests de secciones verticales de la aplicación. Estos test evalúan diferentes interacciones entre las capas.
* No es recomendado el uso de test locales.
* Se recomiendan tests instrumentalizados.

Probar las interacciones de usuario dentro de una sola app ayuda a garantizar que los usuarios no tengan resultados inesperados ni una mala experiencia cuando interactúen con la app. Para realizar los test de interfaz o funcionales, se utiliza la librería **Espresso**. 

Espresso está dirigido a desarrolladores, que creen que las pruebas automatizadas son una parte integral del ciclo de vida del desarrollo. Si bien Espresso se puede usar para pruebas de caja negra, quienes están familiarizados con la base de código bajo en modo de prueba pueden aprovecharlo al máximo.

En el build.gradle, se añade las dependencias necesarias de la librería:

<code>androidTestImplementation 'androidx.test.espresso:espresso-core:3.3.0'</code>
<br />
<code>androidTestImplementation 'androidx.test:runner:1.3.0'</code>
<br />
<code>androidTestImplementation 'androidx.test:rules:1.3.0'</code>

Además, como Espresso es un test instrumentado, hay que indicar en el build.gradle la clase que nos ayuda con la instrumentalización: AndroidJUnitRunner.

<code>testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"</code>

La grabadora de pruebas <strong>Espresso</strong> te permite crear pruebas de IU para tu app sin la necesidad de escribir código de prueba. Es imprescindible deshabilitar las animaciones de la app, para evitar fallos en la grabadora. Para ello, se accede a <i>Configuración - Opciones para desarrolladores</i> y desactiva todas las siguientes opciones:
* Escala de animación de ventana
* Escala de animación de transición
* Escala de duración de animador

## Pruebas implementadas <a name="pruebasImplementadas"></a>

En primera instancia, cada líder de los equipos de desarrollo han creado las ramas correspondientes a los casos de uso asignados a cada equipo. Estas nuevas ramas tienen como nombre TEST - CU<Número> y han sido creadas a partir de la rama “origin/develop” de la práctica de implementación.

A continuación, se engloba en una tabla la planificación por roles de las tareas de testeo:

<img src="https://imgur.com/tW23VWd.png" />

Cabe destacar que en esta tabla la tarea **Test Evl.** corresponde a la de la disciplina de test “Test and Evaluate”, mientras que la tarea denominada **AAM** corresponde a “Achieve Acceptable Mission” and Improve Test Assets”.

Una vez creadas las ramas de caso de uso para el testeo, cada líder liderará acerca de las tareas que deben realizar cada uno de los roles, así como las clases y componentes que deben ser evaluados para cada caso de uso.

## Equipo 1 (Señor Blanco) <a name="testEquipo1"></a>

### CU01 - Añadir Evento de Municipio <a name="testCU01"></a>

#### Test unitario <a name="testUnitarioCU01"></a>

Se crea un paquete en los “test” llamado **AñadirEventoMunicipio**. En él, se crean dos clases test unitarias: **EventoUnitTest** y **MunicipioUnitTest**, correspondientes a las clases del modelo de datos **Municipio** y **Evento**.

Respecto el modelo **Municipio**, se testean los métodos getter/setters. De la clase **Evento**, se testean los métodos getter/setters y el método compareTo(). 

#### Test funcional <a name="testFuncionalCU01"></a>

Se crea una clase <strong>CrearEventoMunicipioTest</strong> en el paquete AndroidTest para testear el funcionamiento de la Interfaz de usuario al crear un evento de municipio en la aplicación. Este método se ha creado a partir de la grabadora de Espresso, incorporada en Android Studio. 

Este test consiste en lo siguiente: primero se registra con una credenciales e inicia sesión en la aplicación. En la pantalla principal, se pulsa el floating button para crear un nuevo evento. Aparece una pantalla de elección del tipo de evento a crear, se elige el de tipo de evento llamado Municipio. 

Esto mostrará la pantalla de creación, donde se piden todos los datos del evento, en este caso se introducirá como nombre del evento “Futbol” y como localidad “Sevilla”.

Se rellenan todos los campos del formulario asociado al nuevo evento y se confirma la creación, apareciendo una pantalla de detalles. En este instante, se aplican <strong>asserts</strong> para enriquecer el test. 

A continuación, se presiona el botón “back” para comprobar que se ha incluido el nuevo evento en la lista de eventos, mediante un nuevo <strong>assert</strong>. Para que el test no dependa de otros, es necesario devolver la aplicación al estado de ejecución inicial (eliminando el evento creado y la cuenta de usuario).

### CU02 - Añadir Evento de Montaña <a name="testCU02"></a>

#### Test unitario <a name="testUnitarioCU02"></a>

Se crea un paquete en los “test” llamado **AñadirEventoMontana**, el cual requiere dos test unitarios: Montana y Evento. Sin embargo, el segundo se incorpora en el CU01. Por tanto, se crea una clase test unitaria: **MontanaUnitTest**, correspondientes a las clases del modelo de datos <strong>Montana</strong>.

Respecto el modelo **Montana**, se testean los métodos getter/setters.

#### Test funcional <a name="testFuncionalCU02"></a>

Se crea una clase <strong>CrearEventoMontanaTest</strong> en el paquete AndroidTest para testear el funcionamiento de la Interfaz de usuario al crear un evento de montaña en la aplicación. Este método se ha creado a partir de la grabadora de Espresso, incorporada en Android Studio. 

Este test consiste en lo siguiente: primero se registra con una credenciales e inicia sesión en la aplicación. En la pantalla principal, se pulsa el floating button para crear un nuevo evento. Aparece una pantalla de elección del tipo de evento a crear, se elige el de tipo de evento llamado Montaña. 

Esto mostrará la pantalla de creación, donde se piden todos los datos del evento, en este caso se introducirá como nombre del evento “Senderismo” y cómo localidad “Sierra nevada”.

Se rellenan todos los campos del formulario asociado al nuevo evento y se confirma la creación, apareciendo una pantalla de detalles. En este instante, se aplican <strong>asserts</strong> para enriquecer el test. 

A continuación, se presiona el botón “back” para comprobar que se ha incluido el nuevo evento en la lista de eventos, mediante un nuevo <strong>assert</strong>. Para que el test no dependa de otros, es necesario devolver la aplicación al estado de ejecución inicial (eliminando el evento creado y la cuenta de usuario).

### CU03 - Añadir Usuario <a name="testCU03"></a>

#### Test unitario <a name="testUnitarioCU03"></a>

Se crea un paquete en los “test” llamado **AñadirUsuario**. En él, se crea una clase test unitaria: <strong>UsuarioUnitTest</strong>, correspondiente a las clases del modelo de datos <strong>Usuario</strong>.

Respecto el modelo <strong>Usuario</strong>, se testean los métodos getter/setters. De la clase Usuario, se testean los métodos getter/setters y el método compareTo(). 

#### Test funcional <a name="testFuncionalCU03"></a>

Se crea una clase **AnadirUsuarioTest** en el paquete AndroidTest para testear el funcionamiento de la Interfaz de usuario al añadir una cuenta de usuario en la aplicación. Este método se ha creado a partir de la grabadora de Espresso, incorporada en Android Studio. 

Este test consiste en lo siguiente: primero se registra un nuevo usuario introduciendo en la pantalla de registro los datos relativos al nuevo usuario (nombre de usuario y contraseña) y confirmando la operación. En este caso, se ha introducido como nombre de usuario “Jorge” y como contraseña “1234”, se incorporan además <strong>asserts</strong> para comprobar que las credenciales son las esperadas. 

Una vez se ha registrado el usuario, se introducen sus credenciales en la pantalla de inicio sesión para acceder a las funcionalidades de la aplicación confirmando el inicio haciendo clic en el botón de “Iniciar sesión”, lo que llevará a la pantalla principal, donde es necesario devolver la aplicación al estado de ejecución inicial (eliminando la cuenta de usuario).

### CU04 - Añadir barra de búsqueda y filtrado de ubicaciones <a name="testCU04"></a>

#### Test unitario <a name="testUnitarioCU04"></a>

Los test unitarios de este caso de uso son Municipio (lo tiene implementado el test CU01) y Montana (lo tiene implementado el test CU02).

#### Test funcional <a name="testFuncionalCU04"></a>

Se crea una clase <strong>AnadirBarraBusquedaTest</strong> en el paquete AndroidTest para testear el funcionamiento de la Interfaz de usuario al realizar una búsqueda de una localización en la aplicación. Este método se ha creado a partir de la grabadora de Espresso, incorporada en Android Studio. 

Para llevar a cabo este test, primero se ha registrado un usuario en la aplicación, introduciendo en la pantalla de registro los datos relativos al nuevo usuario (nombre de usuario y contraseña) y confirmando la operación. En este caso, se ha introducido como nombre de usuario “Luis” y como contraseña “123456”.

Una vez se ha registrado el usuario, se introducen sus credenciales en la pantalla de inicio sesión para acceder a las funcionalidades de la aplicación confirmando el inicio haciendo clic en el botón de “Iniciar sesión”, lo que llevará a la pantalla principal.

Una vez se ha iniciado sesión, se accede a la barra de búsqueda haciendo clic en el icono de la lupa colocado en la parte superior de barra de navegación (appbar) y se coloca una cadena de texto para comprobar que existen ubicaciones con el nombre de la cadena introducida.

En este caso, se escribirá la cadena “Sevilla”, lo que deberá mostrar una lista de ubicaciones en pantalla con al menos una de ellas llamada Sevilla, esto se comprobará con un **assert** que se realizará sobre un item encontrado del recyclerview que deberá contener esta cadena.

Finalmente, tras comprobar esto, se procede a borrar el usuario accediendo a la pantalla de “Perfil” del propio usuario y seleccionar la funcionalidad de eliminar el usuario registrado haciendo clic en el botón, lo que borrará el usuario de la base de datos y cerrará sesión.

## Equipo 2 (Señor Marrón) <a name="testEquipo2"></a>

### CU05 - Añadir preferencias desde el menú AppBar <a name="testCU05"></a>

#### Test unitario <a name="testUnitarioCU05"></a>

En este caso de uso no se requiere ningún test unitario.

#### Test funcional <a name="testFuncionalCU05"></a>

Se crea una clase **MenuTest** en el paquete AndroidTest para testear el funcionamiento del panel lateral de navegación de la aplicación. Este método se ha creado a partir de la grabadora de Espresso, incorporada en Android Studio. 

Para llevar a cabo este test, primero se ha registrado un usuario en la aplicación, introduciendo en la pantalla de registro los datos relativos al nuevo usuario (nombre de usuario y contraseña) y confirmando la operación. En este caso, se ha introducido como nombre de usuario “pepe” y como contraseña “pepe”.

Una vez se ha registrado el usuario, se introducen sus credenciales en la pantalla de inicio sesión para acceder a las funcionalidades de la aplicación confirmando el inicio haciendo clic en el botón de “Iniciar sesión”, lo que llevará a la pantalla principal.

Tras llegar a la pantalla principal, se procede a navegar a través de todas las pantallas que se encuentran en el menú lateral, recorriendo las pantallas de Lista de filtrado de eventos, perfil, ajustes y finalmente de nuevo Inicio.

Finalmente, tras comprobar esto, se procede a borrar el usuario accediendo a la pantalla de “Perfil” del propio usuario y seleccionar la funcionalidad de eliminar el usuario registrado haciendo clic en el botón, lo que borrará el usuario de la base de datos y cerrará sesión.

### CU06 - Consultar tiempo detallado de una ubicación <a name="testCU06"></a>

#### Test unitario <a name="testUnitarioCU06"></a>

Se crea un paquete en los “test” llamado **ConsultarTiempoDetalladoUbicacion**. En él, se crea una clase test unitaria: <strong>WeatherUnitTest</strong>, en referencia a la clase del modelo <strong>Weather</strong>, sobre la cual se testean los métodos getter/setters.

#### Test funcional <a name="testFuncionalCU06"></a>

Se crea una clase **DetallesLocalizacionTest** en el paquete AndroidTest para testear el funcionamiento de la Interfaz de usuario al consultar los detalles (tiempo) de una localización en la aplicación. Este método se ha creado a partir de la grabadora de Espresso, incorporada en Android Studio. 

Para llevar a cabo este test, primero se ha registrado un usuario en la aplicación, introduciendo en la pantalla de registro los datos relativos al nuevo usuario (nombre de usuario y contraseña) y confirmando la operación. En este caso, se ha introducido como nombre de usuario “Luis” y como contraseña “123456”.

Una vez se ha registrado el usuario, se introducen sus credenciales en la pantalla de inicio sesión para acceder a las funcionalidades de la aplicación confirmando el inicio haciendo clic en el botón de “Iniciar sesión”, lo que llevará a la pantalla principal.

Tras iniciar sesión, se accede a la barra de búsqueda haciendo clic en el icono de la lupa colocado en la parte superior de barra de navegación (appbar) y se coloca una cadena de texto para acceder a una ubicación con el nombre de la cadena introducida.

En este caso, se escribirá la cadena “Sevilla”, lo que muestra una lista de ubicaciones que contienen este nombre, y se hace clic en la ubicación que contiene el nombre igual a la cadena “Sevilla”, lo que llevará a la pantalla de detalles de la localización.

Esto deberá mostrar una pantalla con la información de la localidad “Sevilla”, comprobando mediante <strong>assert</strong> que existen cadenas en la pantalla relativas a esta ubicación dado que no son igual a las cadenas determinadas por defecto.

Finalmente, tras comprobar esto, se procede a borrar el usuario accediendo a la pantalla de “Perfil” del propio usuario y seleccionar la funcionalidad de eliminar el usuario registrado haciendo clic en el botón, lo que borrará el usuario de la base de datos y cerrará sesión.

### CU07 - Modificar un evento <a name="testCU07"></a>

#### Test unitario <a name="testUnitarioCU07"></a>

El test unitario de este caso de uso es el del modelo **Evento**, el cual ha sido implementado en el CU01.

#### Test funcional <a name="testFuncionalCU07"></a>

Se crea una clase **ModificarEventoTest** en el paquete AndroidTest para testear el funcionamiento de la Interfaz de usuario al modificar un evento en la aplicación. Este método se ha creado a partir de la grabadora de Espresso, incorporada en Android Studio.

Este test consiste en lo siguiente: primero se registra un nuevo usuario introduciendo en la pantalla de registro los datos relativos al nuevo usuario (nombre de usuario y contraseña) y confirmando la operación. En este caso, se ha introducido como nombre de usuario “a” y como contraseña “a”, se incorporan además <strong>asserts</strong> para comprobar que las credenciales son las esperadas. 

Una vez se ha registrado el usuario, se introducen sus credenciales en la pantalla de inicio sesión para acceder a las funcionalidades de la aplicación confirmando el inicio haciendo clic en el botón de “Iniciar sesión”, lo que llevará a la pantalla principal. En ella, se crea un nuevo evento de municipio pulsando en el floating button situado en la parte inferior derecha. Se rellenan los campos del formulario y se confirma la creación. En la siguiente pantalla de detalles, se pulsa en el botón “Modificar” y se modifican los datos del evento. Se cambia el título “padel” por “padelcomida” y se localiza el evento en Madrid. Se incorporan <strong>asserts</strong> para enriquecer el test y comprobar que los campos se han modificado correctamente. Con el objetivo de que otros test no dependan de éste, se elimina el nuevo evento modificado.

Se sigue el mismo proceso explicado anteriormente para un evento de tipo montaña, incorporando <strong>asserts</strong> correspondientes a los valores del evento modificado. Del mismo modo, al modificar el evento, se elimina de la aplicación.

Finalmente, tras comprobar esto, se procede a borrar el usuario accediendo a la pantalla de “Perfil” del propio usuario y seleccionar la funcionalidad de eliminar el usuario registrado haciendo clic en el botón, lo que borrará el usuario de la base de datos y cerrará sesión.

### CU08 - Eliminar un evento <a name="testCU08"></a>

#### Test unitario <a name="testUnitarioCU08"></a>

El test unitario de este caso de uso es el del modelo **Evento**, el cual ha sido implementado en el CU01.

#### Test funcional <a name="testFuncionalCU08"></a>

Se crea una clase **EliminarEventoTest** en el paquete AndroidTest para testear el funcionamiento de la Interfaz de usuario al eliminar un evento en la aplicación. Este método se ha creado a partir de la grabadora de Espresso, incorporada en Android Studio. 

Este test consiste en lo siguiente: primero se registra un nuevo usuario introduciendo en la pantalla de registro los datos relativos al nuevo usuario (nombre de usuario y contraseña) y confirmando la operación. En este caso, se ha introducido como nombre de usuario “Jorge” y como contraseña “1234”, se incorporan además <strong>asserts</strong> para comprobar que las credenciales son las esperadas. 

Una vez se ha registrado el usuario, se introducen sus credenciales en la pantalla de inicio sesión para acceder a las funcionalidades de la aplicación confirmando el inicio haciendo clic en el botón de “Iniciar sesión”, lo que llevará a la pantalla de inicio.

Tras llegar a la pantalla principal, se pulsa el floating button para crear un nuevo evento. Aparece una pantalla de elección del tipo de evento a crear, se elige el de tipo de evento llamado Municipio. 

Esto mostrará la pantalla de creación, donde se piden todos los datos del evento, en este caso se introducirá como nombre del evento “Futbol”, como localidad “Sevilla” y como descripción “Con amigos”.

Se rellenan todos los campos del formulario asociado al nuevo evento y se confirma la creación, apareciendo una pantalla de detalles. En este instante, se aplican <strong>asserts</strong> para enriquecer el test. 

A continuación, se presiona el botón “back” para comprobar que se ha incluido el nuevo evento en la lista de eventos, mediante un nuevo <strong>assert</strong>. 

Posteriormente, se vuelve a acceder a la pantalla de detalles del evento creado haciendo clic en el item del evento del recycler View.

Esto llevará a la pantalla para consultar este, donde se pulsará el botón para eliminar el evento, comprobando que tras esto lleva a la lista de eventos y que dicha lista está vacía mediante un <strong>assert</strong>.

Posteriormente, se pulsa el floating button para crear un nuevo evento. Aparece una pantalla de elección del tipo de evento a crear, se elige el de tipo de evento llamado Montaña. 

Esto mostrará la pantalla de creación, donde se piden todos los datos del evento, en este caso se introducirá como nombre del evento “Senderismo” y cómo localidad “Sierra nevada”.

Se rellenan todos los campos del formulario asociado al nuevo evento y se confirma la creación, apareciendo una pantalla de detalles. En este instante, se aplican <strong>asserts</strong> para enriquecer el test. 

A continuación, se presiona el botón “back” para comprobar que se ha incluido el nuevo evento en la lista de eventos, mediante un nuevo <strong>assert</strong>.

Más tarde, se vuelve a acceder a la pantalla de detalles del evento creado haciendo clic en el item del evento del recycler View.

Esto llevará a la pantalla para consultar este, donde se pulsará el botón para eliminar el evento, comprobando que tras esto lleva a la lista de eventos y que dicha lista está vacía mediante un <strong>assert</strong>.

Finalmente, tras comprobar esto, se procede a borrar el usuario accediendo a la pantalla de “Perfil” del propio usuario y seleccionar la funcionalidad de eliminar el usuario registrado haciendo clic en el botón, lo que borrará el usuario de la base de datos y cerrará sesión.

## Equipo 3 (Señor Naranja) <a name="testEquipo3"></a>

### CU09 - Consultar tiempo meteorológico en la ubicación actual <a name="testCU09"></a>

#### Test unitario <a name="testUnitarioCU09"></a>

El test unitario de este caso de uso es el del modelo **Weather**, el cual ha sido implementado en el CU06.

#### Test funcional <a name="testFuncionalCU09"></a>

Se crea una clase <strong>TiempoActualTest</strong> en el paquete AndroidTest para testear el funcionamiento de la Interfaz de usuario al mostrar el tiempo de la localización actual en la aplicación. Este método se ha creado a partir de la grabadora de Espresso, incorporada en Android Studio. 

Para llevar a cabo este test, primero se ha registrado un usuario en la aplicación, introduciendo en la pantalla de registro los datos relativos al nuevo usuario (nombre de usuario y contraseña) y confirmando la operación. En este caso, se ha introducido como nombre de usuario “Luis” y como contraseña “123456”.

Una vez se ha registrado el usuario, se introducen sus credenciales en la pantalla de inicio sesión para acceder a las funcionalidades de la aplicación confirmando el inicio haciendo clic en el botón de “Iniciar sesión”, lo que llevará a la pantalla de inicio.

Al llegar a la pantalla principal, se comprueba que el tiempo actual se muestra correctamente en esta (en la parte superior de la pantalla) comprobando mediante **asserts** que los valores que se encuentran en el cuadro del tiempo actual son distintos de los valores por defecto.

Finalmente, tras comprobar esto, se procede a borrar el usuario accediendo a la pantalla de “Perfil” del propio usuario y seleccionar la funcionalidad de eliminar el usuario registrado haciendo clic en el botón, lo que borrará el usuario de la base de datos y cerrará sesión.

### CU10 - Modificar idioma y tema a modo oscuro <a name="testCU10"></a>

#### Test unitario <a name="testUnitarioCU10"></a>

En este caso de uso no se ha implementado ningún test unitario.

#### Test funcional <a name="testFuncionalCU10"></a>

Se crea una clase <strong>ModoOscuroTest</strong> en el paquete AndroidTest para testear el funcionamiento del modo oscuro o claro en la aplicación. Este método se ha creado a partir de la grabadora de Espresso, incorporada en Android Studio. 

Para llevar a cabo este test, primero se ha registrado un usuario en la aplicación, introduciendo en la pantalla de registro los datos relativos al nuevo usuario (nombre de usuario y contraseña) y confirmando la operación. En este caso, se ha introducido como nombre de usuario “pepe” y como contraseña “pepe”.

Una vez se ha registrado el usuario, se introducen sus credenciales en la pantalla de inicio sesión para acceder a las funcionalidades de la aplicación confirmando el inicio haciendo clic en el botón de “Iniciar sesión”, lo que llevará a la pantalla de inicio.

Tras iniciar sesión, se accede a la pestaña de ajustes a través del panel lateral de navegación para cambiar el tema modo claro, navegando posteriormente a la pestaña de Perfil del panel lateral de navegación, regresando después a la pestaña de ajustes para cambiar de nuevo el tema a modo oscuro.
Finalmente, tras comprobar esto, se procede a borrar el usuario accediendo a la pantalla de “Perfil” del propio usuario y tras comprobar mediante un **assert** que el color del nombre de usuario es el del valor del azul oscuro (R.color.Azul_osc), selecciona la funcionalidad de eliminar el usuario registrado haciendo clic en el botón, lo que borrará el usuario de la base de datos y cerrará sesión.

### CU11 - Consultar lista de eventos <a name="testCU11"></a>

#### Test unitario <a name="testUnitarioCU11"></a>

El test unitario de este caso de uso es el del modelo **Evento**, el cual ha sido implementado en el CU01.

#### Test funcional <a name="testFuncionalCU11"></a>

Se crea una clase **ListarEventosTest** en el paquete AndroidTest para testear el funcionamiento de la Interfaz de usuario al realizar una búsqueda de una localización en la aplicación. Este método se ha creado a partir de la grabadora de Espresso, incorporada en Android Studio. 

Para llevar a cabo este test, en primer lugar se han creado 4 eventos accediendo al eventoDAO de la base de datos, siendo los nombres de estos “cena1”, “cena2”, “cena3” y “cena4”, con “Madrid” como localizaciones y con “Cañas” como descripciones, insertando estos eventos en la base de datos.

Posteriormente se ha registrado un usuario en la aplicación, introduciendo en la pantalla de registro los datos relativos al nuevo usuario (nombre de usuario y contraseña) y confirmando la operación. En este caso, se ha introducido como nombre de usuario “Miguel” y como contraseña “miguel”.

Una vez se ha registrado el usuario, se introducen sus credenciales en la pantalla de inicio sesión para acceder a las funcionalidades de la aplicación confirmando el inicio haciendo clic en el botón de “Iniciar sesión”, lo que llevará a la pantalla de inicio.

Tras llegar a la pantalla principal, se comprueba mediante <strong>asserts</strong> que todos los eventos creados se muestran en la pantalla de inicio, siendo estos 4 eventos de municipio.

Finalmente, tras comprobar esto, se procede a borrar el usuario accediendo a la pantalla de “Perfil” del propio usuario y seleccionar la funcionalidad de eliminar el usuario registrado haciendo clic en el botón, lo que borrará el usuario de la base de datos y cerrará sesión.

### CU12 - Consultar un evento <a name="testCU12"></a>

#### Test unitario <a name="testUnitarioCU12"></a>

El test unitario de este caso de uso es el del modelo **Evento**, el cual ha sido implementado en el CU01.

#### Test funcional <a name="testFuncionalCU12"></a>

Se crea una clase <strong>ConsultarEventoTest</strong> en el paquete AndroidTest para testear el funcionamiento de la Interfaz de usuario al consultar los detalles de un evento en la aplicación. Este método se ha creado a partir de la grabadora de Espresso, incorporada en Android Studio. 

Para llevar a cabo este test, primero se ha registrado un usuario en la aplicación, introduciendo en la pantalla de registro los datos relativos al nuevo usuario (nombre de usuario y contraseña) y confirmando la operación. En este caso, se ha introducido como nombre de usuario “Jorge” y como contraseña “1234”.

Una vez se ha registrado el usuario, se introducen sus credenciales en la pantalla de inicio sesión para acceder a las funcionalidades de la aplicación confirmando el inicio haciendo clic en el botón de “Iniciar sesión”, lo que llevará a la pantalla de inicio.

Se crea un nuevo evento en la aplicación de tipo Municipio, con el título “Futbol” y localizado en Sevilla, siendo la descripción del evento “con amigos”. Al confirmar la creación, se realizan asserts para comprobar que los campos que se han rellenado en el test son correctos. En última instancia de este evento, se elimina para limpiar la aplicación.

A continuación, se realiza el mismo proceso para los eventos de tipo Montaña. Se rellena el formulario asociado al nuevo evento y se comenten **asserts**, para enriquecer el test. En última instancia de este evento, se elimina para limpiar la aplicación.

Finalmente, tras comprobar esto, se procede a borrar el usuario accediendo a la pantalla de “Perfil” del propio usuario y seleccionar la funcionalidad de eliminar el usuario registrado haciendo clic en el botón, lo que borrará el usuario de la base de datos y cerrará sesión.

## Equipo 4 (Señor Azul) <a name="testEquipo4"></a>

### CU13 - Iniciar sesión <a name="testCU13"></a>

#### Test unitario <a name="testUnitarioCU13"></a>

El test unitario de este caso de uso es el del modelo **Usuario**, el cual ha sido implementado en el CU03.

#### Test funcional <a name="testFuncionalCU13"></a>

Se crea una clase **IniciarSesionTest** en el paquete AndroidTest para testear el funcionamiento de la Interfaz de usuario al iniciar sesión en la aplicación. Este método se ha creado a partir de la grabadora de Espresso, incorporada en Android Studio. 

Para llevar a cabo este test, primero se ha registrado un usuario en la aplicación, introduciendo en la pantalla de registro los datos relativos al nuevo usuario (nombre de usuario y contraseña) y confirmando la operación. En este caso, se ha introducido como nombre de usuario “Jorge” y como contraseña “1234”.

Una vez se ha registrado el usuario, se introducen sus credenciales en la pantalla de inicio sesión para acceder a las funcionalidades de la aplicación confirmando el inicio haciendo clic en el botón de “Iniciar sesión”, lo que llevará a la pantalla de inicio.
Finalmente, tras comprobar esto, se procede a borrar el usuario accediendo a la pantalla de “Perfil” del propio usuario y seleccionar la funcionalidad de eliminar el usuario registrado haciendo clic en el botón, lo que borrará el usuario de la base de datos y cerrará sesión.

### CU14 - Cerrar sesión <a name="testCU14"></a>

#### Test unitario <a name="testUnitarioCU14"></a>

El test unitario de este caso de uso es el del modelo **Usuario**, el cual ha sido implementado en el CU03.

#### Test funcional <a name="testFuncionalCU14"></a>

Se crea una clase **CerrarSesionTest** en el paquete AndroidTest para testear el funcionamiento de la Interfaz de usuario al cerrar la sesión actual en la aplicación. Este método se ha creado a partir de la grabadora de Espresso, incorporada en Android Studio. 

Este test consiste en lo siguiente: primero se registra un nuevo usuario con una credenciales,  y se inicia sesión en la aplicación. En la pantalla principal, en el AppBar (barra de opciones situada en la parte superior de la pantalla) se pulsa en el icono “Cerrar Sesión” situado en la esquina superior derecha, cerrándose la sesión y retornando en la pantalla de inicio de sesión.

Para que el test no dependa de otros, finalmente se procede a borrar el usuario accediendo a la pantalla de “Perfil” del propio usuario y seleccionar la funcionalidad de eliminar el usuario registrado haciendo clic en el botón, lo que borrará el usuario de la base de datos y cerrará sesión.

### CU15 - Modificar usuario <a name="testCU15"></a>

#### Test unitario <a name="testUnitarioCU15"></a>

El test unitario de este caso de uso es el del modelo **Usuario**, el cual ha sido implementado en el CU03.

#### Test funcional <a name="testFuncionalCU15"></a>

Se crea una clase <strong>ModificarUsuarioTest</strong> en el paquete AndroidTest para testear el funcionamiento de la Interfaz de usuario al modificar el usuario en la aplicación. Este método se ha creado a partir de la grabadora de Espresso, incorporada en Android Studio. 

Este test consiste en lo siguiente: primero se registra un nuevo usuario con una credenciales,  y se inicia sesión en la aplicación. 

En la pantalla principal, se navega por el menú de hamburguesa a la opción “Perfil”. Dentro de ella, aparece un formulario con los campos asociados a las credenciales de la cuenta de usuario con la sesión iniciada. Por defecto, el campo asociado al “username” queda cargado por el valor actual que tenga la cuenta y se modifica por el usuario “juan”. A continuación, se añade la contraseña actual “pepe” y se incorpora una nueva contraseña llamada “juan”. Se pulsa en el botón “Modificar” y aparece la pantalla principal. Para comprobar que la modificación se ha realizado correctamente, se vuelve a los ajustes de perfil en el menú hamburguesa y se incorpora un **assert** para comprobar que el usuario se ha modificado correctamente.

Finalmente, tras comprobar esto, se procede a borrar el usuario accediendo a la pantalla de “Perfil” del propio usuario y seleccionar la funcionalidad de eliminar el usuario registrado haciendo clic en el botón, lo que borrará el usuario de la base de datos y cerrará sesión.

### CU16 - Eliminar usuario <a name="testCU16"></a>

#### Test unitario <a name="testUnitarioCU16"></a>

El test unitario de este caso de uso es el del modelo **Usuario**, el cual ha sido implementado en el CU03.

#### Test funcional <a name="testFuncionalCU16"></a>

Se crea una clase **EliminarUsuarioTest** en el paquete AndroidTest para testear el funcionamiento de la Interfaz de usuario al eliminar el usuario en la aplicación. Este método se ha creado a partir de la grabadora de Espresso, incorporada en Android Studio. 

Este test consiste en lo siguiente: primero se registra un nuevo usuario con una credenciales,  y se inicia sesión en la aplicación. En la pantalla principal, se navega por el menú de hamburguesa a la opción “Perfil”. Dentro de ella, se pulsa el botón “Eliminar” para eliminar la cuenta de usuario. 

Para comprobar que la eliminación se ha realizado correctamente, se busca iniciar sesión con las mismas credenciales del usuario borrado, sin tener ningún efecto, comprobando así que el caso de uso funciona correctamente.

## Arreglo de errores <a name="arregloErrores"></a>
A partir de la implementación y observación de los test, se han cometido los siguientes arreglos:
* Se ha incluido un constructor por defecto, no parametrizado en la clase Evento, Municipio, Usuario y Montana.
* Al eliminar una cuenta de usuario, se ha incorporado el borrado de todos sus eventos asociados.
* Se ha modificado en el layout fragment_crear_evento_montana.xml un atributo del EditText de la fecha llamado focusable. Incorporaba un fallo puesto que al querer elegir la fecha de un nuevo evento, se tenía que pulsar dos veces en el EditText. Por tanto, se le ha asociado el valor “false” al focusable.
Se ha arreglado un error del CU Modificar Evento, específicamente en la clase ModificarEventoMunicipioFragment. Se actualiza la vista en un Thread secundario, cuando sólo se puede modificar en el hilo principal. Por tanto, se ha incorporado un requireActivity().runOnUiThread() para solventar el problema.
* Se ha modificado el acceso público  a los atributos de la clase Weather, restringiendo el acceso a privado. Este arreglo ha supuesto unas pequeñas modificaciones en 4 componentes software (fragmentos y actividades, entre ellos), debido a la incorporación de los getter/setters en la clase Weather.

# Análisis de la calidad <a name="gestionCalidad"></a>
En este apartado se ha realizado un proceso de análisis y gestión de calidad del proyecto desarrollado a lo largo de todas estas entregas, de manera que se compruebe si la calidad de este proyecto es aceptable, así como corregir el proyecto para mejorarla en caso contrario.

Para ello se utilizará la herramienta <strong>SonarQube</strong>, que permite detectar e identificar posibles fallos para mejorar la calidad de un proyecto, así como si esta es aceptable o no, o en su defecto <strong>SonarCloud</strong>, que consiste en su versión online.

En concreto, se debe utilizar esa herramienta para realizar un análisis de la calidad de la versión actual del proyecto e identificar los posibles fallos que pueda presentar esta, tratando de mejorar la calidad corrigiendo 2 de los fallos indicados por cada uno de los integrantes del grupo.

Posteriormente, se publicarán las versiones con fallos corregidos en nuevas ramas (una por cada incidencia) y se integrarán estas, de manera que se compilar de nuevo el repositorio y comprobar que los los fallos se han solucionado.

De esta forma, se demuestra que la herramienta permite realizar correctamente un análisis de calidad del proyecto para identificar correctamente los fallos de calidad y corregirlos.

En este caso, se empleará la herramienta de SonarCloud, utilizándola de forma online a través de las Github Actions.

## Características de SonarCloud <a name="caracteristicasSonarCloud"></a>

SonarCloud es una plataforma en línea creada por SonarSource que ofrece análisis de código y herramientas de colaboración para desarrolladores de software. 

Ayuda a los equipos de desarrollo a mejorar la calidad del código y a identificar problemas de seguridad y de cumplimiento normativo, entre otras cosas. También ofrece integraciones con diferentes herramientas de desarrollo y sistemas de control de versiones para facilitar su uso en el flujo de trabajo de un equipo.

## Pasos para gestionar la calidad <a name="pasosGestionCalidad"></a>

Para realizar esta práctica, se seguirán los siguientes pasos:
* Compilar la rama actual sobre la que se encuentra la última versión del proyecto desde github (utilizando github Actions), para analizar la calidad del proyecto y comprobar si tiene errores.
* Tras el análisis, seleccionar 2 puntos de mejora de calidad indicados por SonarCloud para cada integrante del grupo y tratar de mejorarlos, implementando dichas mejoras en una rama por cada corrección.
* Integrar las ramas correspondientes a develop, y a su vez develop en la rama main.
* Tras aplicar las correcciones implementadas al proyecto, comprobar si estas han solucionado los fallos de calidad que presentaba este compilando de nuevo la rama del proyecto utilizando SonarCloud.

De esta forma, se espera que las correcciones implementadas solucionen los fallos detectados por SonarCloud y que el nuevo análisis realizado refleje esto.

## Repositorios utilizados <a name="repositoriosUtilizados"></a>
Para llevar a cabo el análisis de calidad, se ha utilizado el repositorio con el código del proyecto (ubicado en Github) cuyo enlace es el siguiente: <a href="https://github.com/UniExtremadura/proyecto-gps-asee-2022-23-ga04">https://github.com/UniExtremadura/proyecto-gps-asee-2022-23-ga04</a>.

Este se ha añadido al repositorio de SonarCloud con el nombre de “app”, que se puede encontrar en el siguiente enlace: <a href="https://sonarcloud.io/project/overview?id=UniExtremadura_proyecto-gps-asee-2022-23-ga04">https://sonarcloud.io/project/overview?id=UniExtremadura_proyecto-gps-asee-2022-23-ga04</a> 

## Detección de fallos <a name="calidadGestionFallos"></a>

En esta primera fase se llevará a cabo un análisis inicial de la calidad del proyecto, realizando un proceso de compilación del proyecto en la página oficial de SonarCloud (<a href="https://sonarcloud.io/">https://sonarcloud.io/</a>).

<img src="https://i.imgur.com/0mwXLC8.png" />

Para ello, en primer lugar es necesario añadir el proyecto a SonarCloud para poder hacer el análisis. Cabe destacar que para que se pueda importar el proyecto es necesario que el repositorio sea público y ser el administrador del mismo, sincronizando SonarCloud con la cuenta correspondiente de GitHub del administrador. 

<img src="https://i.imgur.com/kGiPfuw.png" />

## Problemas solventados <a name="problemasSolventados"></a>

Cada miembro del equipo se ha encargado de resolver dos incidencias en base al análisis de calidad de código completado mediante las Github Actions, las cuales utilizan gradle y java para enviar los resultados del análisis a SonarCloud.

### Análisis del Sr. Blanco <a name="calidadSrBlanco"></a>

El análisis base sobre el que se parte para resolver las dos incidencias del <strong>Sr. Blanco</strong> es el siguiente:

<img src="https://i.imgur.com/oXWyfx4.png" />

Se puede observar cómo existen 580 Code Smells o incidencias de mantenibilidad. Las dos incidencias resueltas por el Sr. Blanco son las siguientes:

<img src="https://i.imgur.com/I02kTea.png" />

Una vez incorporados los dos commits de las dos incidencias a la rama develop y hecha la integración a la rama main, se lanzan las github actions para enviar el análisis a SonarCloud con las dos incidencias resueltas. El análisis resultante al resolver las dos incidencias son las siguientes:

<img src="https://i.imgur.com/JlzhG8T.png" />

### Análisis del Sr. Marrón <a name="calidadSrMarron"></a>

Análisis Previo a resolver las incidencias:
<img src="https://i.imgur.com/GCHi0Az.png" />

Mi integración de las dos incidencias resueltas se realizó en dos fases (<strong>push</strong>) a main, pues fui el primero del equipo en aprender a utilizar Sonar. Por eso aparecen dos análisis, en los cuales se observa que se ha resuelto una incidencia en cada uno.

<img src="https://i.imgur.com/p7OlZM0.png" />

Análisis Posterior a la resolución de las incidencias:
<img src="https://i.imgur.com/NkK83MN.png" />

Se observa que hay dos incidencias menos de Mantenibilidad.

### Análisis del Sr. Azul <a name="calidadSrAzul"></a>

El análisis base sobre el que se parte para resolver las dos incidencias del <strong>Sr. Azul</strong> es el siguiente:

<img src="https://imgur.com/KHZnYpV.png" />

Se puede observar cómo existen 576 Code Smells o incidencias de mantenibilidad. Las dos incidencias resueltas por el **Sr. Azul** son las siguientes: 

<img src="https://imgur.com/h7Fc8CL.png" />

Una vez incorporados los dos commits de las dos incidencias a la rama develop y hecha la integración a la rama main, se lanzan las github actions para enviar el análisis a SonarCloud con las dos incidencias resueltas.

<img src="https://imgur.com/vkSGeFZ.png" /> 
<img src="https://imgur.com/LViIRvI.png" /> 

El análisis resultante al resolver las dos incidencias son las siguientes:

<img src="https://imgur.com/qdZptfO.png" /> 

Se puede observar que el análisis de calidad muestra 574 Code Smells o incidencias de mantenibilidad, indicando que se han podido resolver correctamente las dos anteriores.

### Análisis del Sr. Naranja <a name="calidadSrNaranja"></a>

El análisis base sobre el que se parte para resolver las dos incidencias del **Sr. Naranja** es el siguiente:

<img src="https://i.imgur.com/LZMvmB7.png" />

Se puede observar cómo existen 578 Code Smells o incidencias de mantenibilidad. Las dos incidencias resueltas por el Sr. Blanco son las siguientes:

<img src="https://i.imgur.com/ekn2bDg.png" />

Tras esto, una vez incorporados los dos commits de las dos incidencias a la rama develop y hecha la integración a la rama main, se lanzan las github actions para enviar el análisis a SonarCloud con las dos incidencias resueltas. El análisis resultante al resolver las dos incidencias son las siguientes:

<img src="https://i.imgur.com/62naat1.png" />

Se puede observar que el análisis de calidad muestra 576 Code Smells o incidencias de mantenibilidad, indicando que se han podido resolver correctamente las anteriores.

# Reflexión <a name="reflexion"></a>    
Desarrollar una aplicación Android es un proyecto muy interesante y desafiante que puede proporcionar gran satisfacción al ver tu trabajo en uso en dispositivos móviles. Consideramos que tanto la asignatura de ASEE como GPS son las primeras de la carrera que nos han proporcionado un método realista para nuestro futuro laboral en el desarrollo de aplicaciones Android y gestión de proyectos.

ASEE nos ha brindado una nueva perspectiva de programación diferente a la que veníamos acostumbrados. Android Studio es un framework con infinidad de configuraciones y es muy flexible a las necesidades del programador. Además, nos hemos visto empapados de la tecnología Git durante el desarrollo de la app. A pesar de conocer el controlador de versiones de cursos anteriores, es recomendable recordar y afianzar conceptos de Git asiduamente. 

No nos podemos olvidar de GPS, un conjunto de conocimientos que hemos adquirido sobre la gestión y metodología de desarrollo de un proyecto. Junto con Android Studio, se suman herramientas populares como JIRA, Slack, Github Actions, SonarCloud, JUnit, Espresso, Mokito, etc. Aun cuando las asignaturas han significado una de las más intensas y extensas cargas de trabajo en todo el grado de ingeniería informática, estamos en lo cierto que todo el esfuerzo dedicado ha merecido la pena, aunque siempre se puede dedicar un poco más de tiempo a perfeccionar las ideas de la aplicación (en referencia a la interfaz).

En resumen, desarrollar una aplicación Android es un proyecto que requiere de mucho esfuerzo, tiempo y dedicación, pero puede ser muy gratificante echar la vista atrás y ver el proceso seguido para crear la versión final.