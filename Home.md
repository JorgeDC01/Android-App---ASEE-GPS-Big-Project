# Autores
* Luis Alfonso Huertas Delgado
* Miguel Jara Arroyo
* Pedro del Castillo G√≥mez
* Jorge del Castillo G√≥mez
# √çndice
- [√çndice](#√≠ndice)
- [Introduccion <a name="introduction"></a>](#introduccion-)
- [Propuesta inicial <a name="propuestaInicial"></a>](#propuesta-inicial-)
  - [Descripci√≥n de la idea <a name="descripcionDeLaIdea"></a>](#descripci√≥n-de-la-idea-)
    - [P√∫blico objetivo <a name="publicoObjetivo"></a>](#P√∫blico-objetivo-)
- [Funcionalidades principales <a name="funcionalidadesprincipales"></a>](#funcionalidades-principales-)
- [An√°lisis <a name="analisis"></a>](#an√°lisis-)
  - [Casos de uso estructurales <a name="casosdeusoestructurales"></a>](#casos-de-uso-estructurales-)
  - [Casos de uso no estructurales <a name="casosdeusonoestructurales"></a>](#casos-de-uso-no-estructurales-)
  - [Conjuntos de casos de uso <a name="conjuntosdecasosdeuso"></a>](#conjuntos-de-casos-de-uso-)
  - [Requisitos no funcionales <a name="requisitosNoFuncionales"></a>](#Requisitos-no-funcionales-)
- [Metodolog√≠as de desarrollo <a name="metodologiasdedesarrollo"></a>](#metodolog√≠as-de-desarrollo-)
  - [Proceso de desarrollo <a name="procesodedesarrollo"></a>](#proceso-de-desarrollo-)
  - [Planificaci√≥n del proyecto <a name="planificaciondelproyecto"></a>](#planificaci√≥n-del-proyecto-)
    - [Proceso de planificaci√≥n <a name="procesodeplanificacion"></a>](#proceso-de-planificaci√≥n-)
    - [Distribuci√≥n de casos de uso <a name="distribuciondecasosdeuso"></a>](#distribuci√≥n-de-casos-de-uso-)
    - [An√°lisis de la distribuci√≥n <a name="analisisdeladistribucion"></a>](#an√°lisis-de-la-distribuci√≥n-)
    - [Planificaci√≥n del proyecto <a name="planificaciondelproyecto2"></a>](#planificaci√≥n-del-proyecto--1)
    - [An√°lisis de la planificaci√≥n <a name="analisisdelaplanificacion"></a>](#an√°lisis-de-la-planificaci√≥n-)
      - [Camino Cr√≠tico <a name="caminocritico"></a>](#camino-cr√≠tico-)
  - [Configuraci√≥n del seguimiento de la planificaci√≥n <a name="configSeguimientoPlan"></a>](#Configuraci√≥n-del-seguimiento-de-la-planificaci√≥n-)
    - [Se√±or Blanco (Equipo 1) <a name="se√±orBlanco"></a>](#se√±or-blanco-equipo-1-)
      - [Proceso seguido <a name="procesoSeguidoBlanco"></a>](#proceso-seguido-)
      - [An√°lisis del progreso <a name="analisisProgresoBlanco"></a>](#an√°lisis-del-progreso-)
    - [Se√±or Marr√≥n (Equipo 2) <a name="se√±orMarron"></a>](#se√±or-marr√≥n-equipo-2-)
      - [Proceso seguido <a name="procesoSeguidoMarron"></a>](#proceso-seguido--1)
      - [An√°lisis del progreso <a name="analisisProgresoMarron"></a>](#an√°lisis-del-progreso--1)
    - [Se√±or Naranja (Equipo 3) <a name="se√±orNaranja"></a>](#se√±or-naranja-equipo-3-)
      - [Proceso seguido <a name="procesoSeguidoNaranja"></a>](#proceso-seguido--2)
      - [An√°lisis del progreso <a name="analisisProgresoNaranja"></a>](#an√°lisis-del-progreso--2)
      - [Proporci√≥n de √âpicas, Tareas y Subtareas <a name="analisisGraficoNaranja"></a>](#proporci%C3%B3n-de-%C3%A9picas-tareas-y-subtareas--1)
    - [Se√±or Azul (Equipo 4) <a name="se√±orAzul"></a>](#se√±or-azul-equipo-4-)
      - [Proceso seguido <a name="procesoSeguidoAzul"></a>](#proceso-seguido--3)
      - [An√°lisis del progreso <a name="analisisProgresoAzul"></a>](#an√°lisis-del-progreso--3)
      - [Proporci√≥n de tareas por caso de uso <a name="analisisGraficoAzul"></a>](#proporci%C3%B3n-de-tareas-por-caso-de-uso-)
    - [Proporci√≥n de √âpicas, Tareas y Subtareas <a name="analisisGraficoNaranja"></a>](#proporci%C3%B3n-de-%C3%A9picas-tareas-y-subtareas--1)
    - [Proporci√≥n de tareas por caso de uso <a name="analisisGraficoAzul"></a>](#proporci%C3%B3n-de-tareas-por-caso-de-uso-)
    - [Contribuci√≥n de los l√≠deres de equipo <a name="contribucionBlanco"></a>](#contribuci%C3%B3n-de-los-l%C3%ADderes-de-equipo-)
  - [Progreso del proyecto <a name="desarrolloProgreso"></a>](#Progreso-del-proyecto-)
    - [S√≠ntesis de la planificaci√≥n por roles <a name="sintesisPlanificacion"></a>](#S√≠ntesis-de-la-planificaci√≥n-por-roles-)
    - [Proceso seguido del Equipo 1 (Sr. Blanco) <a name="desarrolloEquipo1"></a>](#Proceso-seguido-del-Equipo-1-Sr-Blanco-)
    - [Proceso seguido del Equipo 2 (Sr. Marr√≥n) <a name="desarrolloEquipo2"></a>](#Proceso-seguido-del-Equipo-2-Sr-Marr√≥n-)
    - [Proceso seguido del Equipo 3 (Sr. Naranja) <a name="desarrolloEquipo3"></a>](#Proceso-seguido-del-Equipo-3-Sr-Naranja-)
    - [Proceso seguido del Equipo 4 (Sr. Azul) <a name="desarrolloEquipo4"></a>](#Proceso-seguido-del-Equipo-4-Sr-Azul-)
    - [An√°lisis del progreso <a name="analisisProgreso2"></a>](#An√°lisis-del-progreso--4)
- [Dise√±o de la interfaz de usuario <a name="dise√±oInterfazUsuario"></a>](#Dise√±o-de-la-interfaz-de-usuario-)
  - [Mapa de Navegaci√≥n: pantallas, patrones y diagrama <a name="mapaNavegacion"></a>](#Mapa-de-Navegaci√≥n-pantallas-patrones-y-diagrama-)
    - [Diagrama de casos de uso <a name="diagramaCasosdeUso"></a>](#Diagrama-de-casos-de-uso-)
    - [Diagrama de navegaci√≥n <a name="diagramadeNavegacion"></a>](#Diagrama-de-navegaci√≥n-)
    - [Mockup <a name="Mockup"></a>](#Mockup-)
    - [Grafo de navegaci√≥n <a name="grafodeNavegacion"></a>](#Grafo-de-navegaci√≥n-)
    - [Patrones de navegaci√≥n aplicados <a name="patronesNavegacion"></a>](#Patrones-de-navegaci√≥n-aplicados-)
- [Dise√±o arquitect√≥nico <a name="dise√±oArquitectonico"></a>](#Dise√±o-arquitect√≥nico-)
  - [Diagrama e interacci√≥n de componentes <a name="diagramaComponentes"></a>](#Diagrama-e-interacci√≥n-de-componentes-)
  - [Patrones arquitect√≥nicos <a name="patronesArquitectonicos"></a>](#Patrones-arquitect√≥nicos-)
- [Gesti√≥n del entorno <a name="gestionEntorno"></a>](#Gesti√≥n-del-entorno-)
  - [Gesti√≥n de la configuraci√≥n <a name="gestionConfiguracion"></a>](#Gesti√≥n-de-la-configuraci√≥n-)
    - [Entorno utilizado <a name="entornoUtilizado"></a>](#Entorno-utilizado-)
      - [Herramienta de implementaci√≥n: Android Studio <a name="androidStudio"></a>](#Herramienta-de-implementaci√≥n-Android-Studio-)
      - [Estructura de un proyecto en Android Studio <a name="estructuraProyecto"></a>](#Estructura-de-un-proyecto-en-Android-Studio-)
      - [Componentes de la interfaz de Android Studio <a name="componentesInterfaz"></a>](#Componentes-de-la-interfaz-de-Android-Studio-)
      - [Funcionamiento de una App en Android Studio <a name="funcionamientoApp"></a>](#Funcionamiento-de-una-App-en-Android-Studio-)
      - [Compilaci√≥n en Gradle <a name="compilacionGradle"></a>](#Compilaci√≥n-en-Gradle-)
      - [Integraci√≥n de Jira en Android Studio <a name="integracionContextJira"></a>](#integraci%C3%B3n-de-jira-en-android-studio-)
        - [Integraci√≥n de Jira en Android Studio a trav√©s de la herramienta de contexto <a name="integracionContextJira"></a>](#integraci%C3%B3n-de-jira-en-android-studio-a-trav%C3%A9s-de-la-herramienta-de-contexto-)
        - [Integraci√≥n de Jira en Android Studio a trav√©s de un plugin <a name="integracionPluginJira"></a>](#integraci%C3%B3n-de-jira-en-android-studio-a-trav%C3%A9s-de-un-plugin-)
      - [Ramas utilizadas en el proyecto <a name="ramas"></a>](#Ramas-utilizadas-en-el-proyecto-)
  - [Integraci√≥n continua <a name="integracionContinua"></a>](#Integraci√≥n-continua-)
- [Implementaci√≥n <a name="implementacion"></a>](#Implementaci√≥n-)
  - [Estructura del proyecto <a name="estructura"></a>](#Estructura)
  - [Modelo de datos <a name="modeloDatos"></a>](#Modelo-de-datos-)
  - [Detalles de implementaci√≥n <a name="detallesImplementacion"></a>](#Detalles-de-implementaci√≥n-)
    - [Patrones de Dise√±o <a name="patronesDise√±o"></a>](#Patrones-de-Dise√±o-)
    - [Refactorizaci√≥n <a name="refactorizaci√≥n "></a>](#Refactorizaci√≥n-)
    - [Aspectos novedosos y decisiones tomadas <a name="aspectosNovedosos"></a>](#Aspectos-novedosos-y-decisiones-tomadas-)
      - [Gesti√≥n de la API <a name="gestionAPI"></a>](#Gesti√≥n-de-la-API-)
      - [Obtenci√≥n de localizaci√≥n <a name="obtencionLocalizacion"></a>](#Obtenci√≥n-de-localizaci√≥n-)
      - [Gesti√≥n de Permisos <a name="gestionPermisos"></a>](#Gesti√≥n-de-Permisos-)
      - [Carga de municipios y monta√±as desde JSON <a name="cargaJSON"></a>](#Carga-de-municipios-y-monta√±as-desde-JSON-)
      - [Men√∫ de Hamburguesa <a name="menuHamburguesa"></a>](#Men√∫-de-Hamburguesa-)
      - [Filtro de Eventos <a name="filtroEventos"></a>](#Filtro-de-Eventos-)
      - [Usuario √∫nico <a name="usuarioUnico"></a>](#Usuario-√∫nico-)
      - [Implementaci√≥n de Spinners en diversos campos <a name="spinners"></a>](#Implementaci√≥n-de-Spinners-en-diversos-campos-)
      - [Filtrado de localizaciones <a name="filtradoLocalizaciones"></a>](#Filtrado-de-localizaciones-)
      - [Modo Oscuro <a name="modoOscuro"></a>](#Modo-Oscuro-)
- [Gesti√≥n de la calidad del Software <a name="gestionCalidadSoftware"></a>](#Gesti√≥n-de-la-calidad-del-Software-)
  - [Pruebas implementadas <a name="pruebasImplementadas"></a>](#Pruebas-implementadas-)
    - [Equipo 1 (Se√±or Blanco) <a name="testEquipo1"></a>](#Equipo-1-Se√±or-Blanco-)
    - [Equipo 2 (Se√±or Marr√≥n) <a name="testEquipo2"></a>](#Equipo-2-Se√±or-Marr√≥n-)
    - [Equipo 3 (Se√±or Naranja) <a name="testEquipo3"></a>](#Equipo-3-Se√±or-Naranja-)
    - [Equipo 4 (Se√±or Azul) <a name="testEquipo4"></a>](#Equipo-4-Se√±or-Azul-)
    - [Arreglo de errores <a name="arregloErrores"></a>](#Arreglo-de-errores-)
  - [An√°lisis de la calidad <a name="gestionCalidad"></a>](#An√°lisis-de-la-calidad-)
    - [Caracter√≠sticas de SonarCloud <a name="caracteristicasSonarCloud"></a>](#Caracter√≠sticas-de-SonarCloud-)
    - [Pasos para gestionar la calidad <a name="pasosGestionCalidad"></a>](#Pasos-para-gestionar-la-calidad-)
    - [Repositorios utilizados <a name="repositoriosUtilizados"></a>](#Repositorios-utilizados-)
    - [Detecci√≥n de fallos <a name="calidadGestionFallos"></a>](#Detecci√≥n-de-fallos-)
    - [Problemas solventados <a name="problemasSolventados"></a>](#Problemas-solventados-)
      - [An√°lisis del Sr. Blanco <a name="calidadSrBlanco"></a>](#An√°lisis-del-Sr-Blanco-)
      - [An√°lisis del Sr. Marr√≥n <a name="calidadSrMarron"></a>](#An√°lisis-del-Sr-Marr√≥n-)
      - [An√°lisis del Sr. Azul <a name="calidadSrAzul"></a>](#An√°lisis-del-Sr-Azul-)
      - [An√°lisis del Sr. Naranja <a name="calidadSrNaranja"></a>](#An√°lisis-del-Sr-Naranja-)
- [Reflexi√≥n <a name="reflexion"></a>](#Reflexi√≥n-)      

# Introduccion <a name="introduction"></a>

**Motivaci√≥n**

<p>

En los √∫ltimos a√±os, la plataforma Android ha gobernado notablemente el mercado m√≥vil, de tal manera que iOS nunca ha sido capaz de recuperar el status con el que se inici√≥ en el ‚Äúmundillo‚Äù tecnol√≥gico. Adem√°s, junto con el crecimiento exponencial del ‚ÄúBig Data‚Äù, apareci√≥ un nuevo formato de aplicaciones m√≥viles que acced√≠an a grandes cantidades de datos. Como consecuencia,  los servicios que proporcionaban grandes fuentes de datos deb√≠an incorporar la forma de brindar datos con un acceso libre y seguro, conocido como ‚ÄúOpen Data‚Äù. 
</p>

<p>
En cuanto al nicho de mercado, apenas existen propuestas novedosas de aplicaciones meteorol√≥gicas, puesto que la mayor√≠a de dispositivos Android incorporan estas aplicaciones de f√°brica. Del mismo modo, los usuarios no parecen ser tan exigentes con este tipo de aplicaciones al ser conformistas con lo que disponen. 
</p>

<p>
Hoy en d√≠a, las aplicaciones m√≥viles no se centran √∫nicamente en una tarea, sino que aglutinan diversas funcionalidades relacionadas entre s√≠. Por otro lado, el hardware m√≥vil ha evolucionado hasta tal punto en que los desarrolladores tienen un gran abanico de opciones para desarrollar una IU con una alta usabilidad y accesibilidad.
</p>


**Objetivos**

<p>

El prop√≥sito del equipo de desarrollo es afianzar conocimientos: c√≥mo utilizar Android Studio, c√≥mo tratar el gran flujo de informaci√≥n devuelto por la API y la forma en la que se presentan los datos al usuario.  Asimismo, se va a focalizar en el dise√±o de la interfaz de usuario, haci√©ndola atractiva, novedosa y cumpliendo los requisitos de usabilidad y accesibilidad. Se pretende aportar al mercado un servicio de buena calidad a primera vista.
</p>


**Resumen**
<p>

En los siguientes apartados, hablaremos de la propuesta inicial del proyecto con una descripci√≥n y su funcionalidad inicial. A continuaci√≥n, se detalla el marco de desarrollo, en otras palabras, la planificaci√≥n y el proceso seguido para cumplir con los objetivos propuestos. La metodolog√≠a empleada por el equipo es el ‚ÄúProceso Unificado‚Äù, un marco de desarrollo iterativo e incremental basado en casos de uso y centrado en la arquitectura del sistema.  Por √∫ltimo, se presentar√° el funcionamiento interno de la aplicaci√≥n, as√≠ como los mockup (interfaz de usuario primigenia) y la navegaci√≥n entre las diferentes pantallas.
</p>

<p>&nbsp;</p>


# Propuesta inicial <a name="propuestaInicial"></a>


## Descripci√≥n de la idea <a name="descripcionDeLaIdea"></a>
<p>
El objetivo principal de este trabajo es el desarrollo de una aplicaci√≥n m√≥vil Android llamada <b>KikoGaku (en japones, Climatolog√≠a)</b> centrada en la visualizaci√≥n del tiempo meteorol√≥gico de una localizaci√≥n en Espa√±a, dicha informaci√≥n proporcionada por la API de AEMET. 
</p>
</p>El usuario puede crear eventos personalizados ligados a una ubicaci√≥n, los cuales tendr√°n asignado las condiciones meteorol√≥gicas a tiempo real en dicha localizaci√≥n. De igual importancia, se favorece la interacci√≥n de los usuarios con el medio ambiente, permiti√©ndoles crear eventos tanto en municipios como en monta√±as.
<p>


### P√∫blico objetivo <a name="publicoObjetivo"></a>
En este apartado, se especifica a qu√© p√∫blico va dirigida nuestra aplicaci√≥n mediante estudios y gr√°ficas. Antes de adentrarnos en el ‚Äúquid‚Äù de la cuesti√≥n, cabe destacar el motivo por el que se ha elegido Android como plataforma sobre la que se implementa la aplicaci√≥n. Seg√∫n [StatCounter](https://statcounter.com/), Android ha dominado el 70% de la cuota de mercado por delante de iOS en creces, como se muestra en la siguiente gr√°fica:

<img src="https://i.imgur.com/WW9jHmJ.png"/>

Asimismo, no es una sorpresa que Android gobierne el mercado de dispositivos m√≥viles. Seg√∫n Google, el n√∫mero de usuarios con dispositivos Android ha aumentado notablemente. En la siguiente tabla, se especifica la evoluci√≥n de los usuarios activos durante los √∫ltimos a√±os en billones como unidad.

<img src="https://i.imgur.com/m1Ke0H4.png"/>


**¬øA qui√©n va dirigido?**

La  categor√≠a  de  apps  del tiempo  son  el  0,4%  del  total, con m√°s de 11.500 disponibles y  un  promedio  de  valoraci√≥n de 4,0 (frente al 4,1 del resto de categor√≠as  contando  solo  las apps  con  m√°s  de  100  valoraciones). El 12% de las apps del tiempo se han descargado m√°s de 50.000 veces (9,5% de media  para  el  resto  de  apps).

Adem√°s dentro de la tienda Play Store de Google, la aplicaciones del tiempo estando dentro de las categor√≠as m√°s usadas, es la que atrae al menor n√∫mero de usuarios, como se puede ver en el siguiente enlace,  el 32% de los usuarios se descarga una aplicaci√≥n climatol√≥gica:
[Estad√≠sticas para este 2022 en la tienda de Google Play](https://appsrentables.com/estadisticas-tienda-google-play/)

Esto es debido a que la totalidad de los dispositivos android ya vienen instalados con una aplicaci√≥n climatol√≥gica, esto deriva en que solo los usuarios que quieren una experiencia mejor que a la que les dan sus dispositivos buscan una alternativa a la aplicaci√≥n preinstalada, estos usuarios no buscan una aplicaci√≥n que les diga el tiempo sin m√°s, sino que adem√°s buscan funcionalidades extras y podr√≠amos decir que son un tipo de usuarios que buscan una aplicaci√≥n climatol√≥gica m√°s espec√≠fica.

Es por esto que el **prototipo de usuario** al que ya he dirigido nuestra aplicaci√≥n ser√° fundamentalmente una persona mayor de edad, entre los 18 y 50 a√±os, la cual realice actividades o eventos de una manera regular, y que sea importante para dichos eventos conocer la situaci√≥n meteorol√≥gica de la ubicaci√≥n en la que se producen, como por ejemplo eventos deportivos, bodas y banquetes al aire libre, etc.

# Funcionalidades principales <a name="funcionalidadesprincipales"></a>


<p>
Para poder utilizar las diferentes funcionalidades de la aplicaci√≥n, un usuario debe registrarse con unas credenciales. Una vez se registre e inicie sesi√≥n, podr√° :

<ul>
    <li>En la pantalla principal, visualizar el tiempo meteorol√≥gico de la ubicaci√≥n actual del dispositivo.
    </li>
    <li>Visualizar el listado de eventos en municipios o monta√±as  creados por el usuario.
    </li>
    <li>Gestionar un evento, as√≠ como su creaci√≥n, edici√≥n y borrado, mediante las preferencias (fecha, nombre, descripci√≥n, color, ubicaci√≥n, etc).
    </li>
    <li>Consultar en detalle el tiempo meteorol√≥gico de una ubicaci√≥n espec√≠fica.
    </li>
    <li>Editar los datos personales y borrar la cuenta de usuario.
    </li>
</ul>
</p>
<p>&nbsp;</p>

# An√°lisis <a name="analisis"></a>
En este apartado, se profundiza sobre aspectos esenciales de la propuesta inicial del proyecto, as√≠ como los requisitos funcionales y no funcionales. 


## Casos de uso estructurales <a name="casosdeusoestructurales"></a>

<ul>
    <li>CU-01: A√±adir Evento de Municipio.
    </li>
    <li>CU-02: A√±adir Evento de Ruta Monta√±a.
    </li>
    <li>CU-03: A√±adir Usuario.
    </li>
    <li>CU-04: A√±adir una barra de b√∫squeda y filtrado de ubicaciones.
    </li>
    <li>CU-05: A√±adir preferencias desde el men√∫ de AppBar (ajustes ‚Ä¶)
    </li>
</ul>


## Casos de uso no estructurales <a name="casosdeusonoestructurales"></a>

<ul>
    <li>CU-06: Consultar el tiempo detallado de una ubicaci√≥n.
    </li>
    <li>CU-07: Modificar un evento.
    </li>
    <li>CU-08: Eliminar un evento.
    </li>
    <li>CU-09: Consultar tiempo meteorol√≥gico en la ubicaci√≥n actual
    </li>
    <li>CU-10: Modificar idioma y tema a modo oscuro
    </li>
    <li>CU-11: Consultar lista de eventos.
    </li>
    <li>CU-12: Consultar un evento.
    </li>
    <li>CU-13: Iniciar sesi√≥n.
    </li>
    <li>CU-14: Cerrar sesi√≥n.
    </li>
    <li>CU-15: Modificar usuario.
    </li>
    <li>CU-16: Eliminar usuario.
    </li>
</ul>

## Conjuntos de casos de uso <a name="conjuntosdecasosdeuso"></a>

| ID | Nombre | Descripci√≥n | 
|----|---|---|
|CU-01|A√±adir Evento de Municipio.|El usuario podr√° a√±adir un nuevo evento de municipio en una fecha determinada, estando asignado a una condici√≥n meteorol√≥gica en tiempo real de la ubicaci√≥n del municipio.|
|CU-02|A√±adir Evento de Ruta Monta√±a.|El usuario podr√° a√±adir un nuevo evento de monta√±a en una fecha determinada, estando asignado a una condici√≥n meteorol√≥gica en tiempo real de la ubicaci√≥n de la monta√±a.|
|CU-03|A√±adir Usuario.|El sistema permite al usuario registrarse con unas credenciales.|
|CU-04|A√±adir una barra de b√∫squeda y filtrado de ubicaciones.|El sistema deber√° incorporar una barra de b√∫squeda para buscar una ubicaci√≥n con su tiempo meteorol√≥gico asignado.|
|CU-05|A√±adir preferencias desde el men√∫ de AppBar (ajustes ‚Ä¶)|El sistema deber√° incorporar un apartado de configuraci√≥n que permite al usuario personalizar su experiencia con la aplicaci√≥n, as√≠ como el modo oscuro, preferencias, etc.|
|CU-06|Consultar el tiempo detallado de una ubicaci√≥n.|El usuario podr√° visualizar el tiempo meteorol√≥gico de una ubicaci√≥n espec√≠fica en tiempo real.|
|CU-07|Modificar un evento.|El usuario podr√° modificar los datos de un evento, as√≠ como su nombre, descripci√≥n, fecha y ubicaci√≥n.|
|CU-08|Eliminar un evento.|El usuario podr√° borrar un evento creado y configurado previamente en la lista de eventos.|
|CU-09|Consultar el tiempo meteorol√≥gico en la ubicaci√≥n actual.|El usuario podr√° consultar los detalles del tiempo asociado a la localizaci√≥n/municipio m√°s cercano.|
|CU-10|Modificar idioma y tema a modo oscuro.|El usuario podr√° realizar una serie de modificaciones en la aplicaci√≥n para configurar esta a su gusto como cambiar el idioma, el tema a modo oscuro, etc.|
|CU-11|Consultar lista de eventos.|El usuario podr√° visualizar el listado completo de eventos de municipios y monta√±as creados por su parte.|
|CU-12|Consultar un evento.|El usuario podr√° visualizar en detalle los datos pertinentes de un evento de municipio o monta√±a.|
|CU-13|Iniciar sesi√≥n.|El sistema permite iniciar sesi√≥n con las credenciales asociadas a su cuenta de usuario.|
|CU-14|Cerrar sesi√≥n.|El sistema permite cerrar sesi√≥n a un usuario.|
|CU-15|Modificar usuario.|El usuario podr√° modificar su nombre de usuario, contrase√±a asociadas a su cuenta en un apartado ‚Äúperfil‚Äù.| 
|CU-16|Eliminar usuario.|En el apartado ‚Äúperfil‚Äù, el usuario podr√° eliminar su cuenta de la aplicaci√≥n y cerrar sesi√≥n.|


## Requisitos no funcionales <a name="requisitosNoFuncionales"></a>
Los requisitos no funcionales son aquellos que no hacen referencia a las funciones espec√≠ficas del sistema, sino a las propiedades que este debe satisfacer. Suponen restricciones en su implementaci√≥n. Para su definici√≥n vamos a agruparlos en varias categor√≠as:

1. **Usabilidad**: Caracter√≠stica relacionada con el modo de interacci√≥n entre el usuario y la aplicaci√≥n. 
> * **RNF 1**: La aplicaci√≥n debe estar dise√±ada de manera que se adapte a la resoluci√≥n al tama√±o de pantalla de cualquier dispositivo m√≥vil.
> * **RNF 2**: Los usuarios habituados a las aplicaciones meteorol√≥gicas deben entender al instante el funcionamiento de la aplicaci√≥n. El tiempo para una persona no habituada no debe ser superior a 5 minutos. 
> * **RNF 3**: La aplicaci√≥n debe seguir los patrones establecidos por Google Material Design. 
> * **RNF 4**: El sistema proporcionar√° feedback constante al usuario durante el uso de la aplicaci√≥n, bien informando de un error o confirmando una acci√≥n realizada. 
> * **RNF 5**: Para aquellas tareas que no finalicen inmediatamente se deber√° mostrar una barra de progreso que informe de su estado actual. 
> * **RNF 6**: La aplicaci√≥n debe ser apta para usuarios de habla inglesa o espa√±ol, y permitir una f√°cil adaptaci√≥n a cualquier otro idioma.


2. **Eficiencia**: Capacidad para realizar adecuadamente una funci√≥n. 
> * **RNF 7**: La aplicaci√≥n no debe tardar m√°s de 3 segundos en iniciarse. 
> * **RNF 8**: No demorar m√°s de 6 segundos en la carga de informaci√≥n con las predicciones meteorol√≥gicas tras haber seleccionado una localidad, para que el usuario no se desespere. 


3. **Consistencia**: Caracter√≠stica que define a algo s√≥lido y estable. 
> * **RNF 9**: La aplicaci√≥n no debe bloquearse en ning√∫n momento mientras se est√© utilizando.


4. **Integridad**: Capacidad para mostrar algo sin ser distorsionado.
> * **RNF 10**: La informaci√≥n mostrada debe ser aut√©ntica y coherente con los datos que la Agencia Espa√±ola de Meteorolog√≠a nos proporciona a trav√©s de su API.


5. **Mantenibilidad**: Facilidad para ser modificado. 
> * **RNF 11**: El c√≥digo de la aplicaci√≥n debe estar bien estructurado, utilizando patrones arquitect√≥nicos, de modo que si hay que a√±adir o corregir alguna funcionalidad tardemos el menor tiempo posible en solucionarlo.


6. **Compatibilidad**: Cualidad de un elemento que le permite poder trabajar con otro correctamente. 
> * **RNF 12**: Se espera que la aplicaci√≥n sea compatible con el 85% de los dispositivos m√≥viles existentes que utilicen Android, para ello usar√° la versi√≥n de Android 6.0.


7. **Disponibilidad**: Probabilidad de que la aplicaci√≥n falle.
> * **RNF 13**: Se espera que la aplicaci√≥n se encuentre disponible al menos el 99,95% de las veces que sean utilizadas por los usuarios, teniendo una probabilidad de fallo de como m√°ximo un 0,05%.


8. **Seguridad**: Capacidad que tiene la aplicaci√≥n de proteger a sus usuarios.
> * **RNF 14**: Se espera que la aplicaci√≥n garantice la privacidad de los datos del usuario frente a amenazas externas de robo de datos o p√©rdida de estos gracias a mecanismos como el respaldo de estos mediante una copia de seguridad peri√≥dica y la restricci√≥n a su acceso a √∫nicamente el administrador.

<p>&nbsp;</p>

# Metodolog√≠as de desarrollo <a name="metodologiasdedesarrollo"></a>

## Proceso de desarrollo <a name="procesodedesarrollo"></a>

Para llevar a cabo la realizaci√≥n del proyecto se ha utilizado el m√©todo denominado como <b>Proceso Unificado</b> (SCRUM), que consiste en una metodolog√≠a √°gil gracias a la cual se pueden desarrollar proyectos pudiendo realizar modificaciones en este f√°cilmente.
As√≠ mismo, este proceso divide su desarrollo en <b>fases</b> utilizando el concepto de Casos de Uso para representar a los requisitos. Las fases se desarrollar√°n de forma incremental mediante una serie de <b>iteraciones</b>.
En este proceso, los <b>casos de uso</b> se crean e implementan a trav√©s de <b>cuatro fases</b>:
1. <b>Inicio</b>: Se especifica o declara el requisito en concreto, madurando dicha idea hasta un concepto m√°s s√≥lido.
2. <b>Elaboraci√≥n</b>: El requisito pasa por un proceso de an√°lisis y dise√±o, que ampl√≠an el concepto y c√≥mo se deber√≠a implementar.
3. <b>Construcci√≥n</b>: El requisito se implementa en c√≥digo software para ser utilizado en el programa.
4. <b>Transici√≥n</b>: Se prueba la versi√≥n final del requisito para saber si el c√≥digo software es correcto, y en caso afirmativo se integra este junto con el resto en el programa. 

## Planificaci√≥n del proyecto <a name="planificaciondelproyecto"></a>

### Proceso de planificaci√≥n <a name="procesodeplanificacion"></a>

En la planificaci√≥n de este proyecto, existir√°n <b>cuatro roles</b> que influyen de forma distinta la creaci√≥n de casos de uso. Estos roles son:
1. <b>Jefe de proyecto</b>: Es el encargado principal de gestionar el desarrollo del proyecto.
2. <b>Desarrollador de software Senior</b>: Es un programador de Software relativamente experimentado.
3. <b>Desarrollador de software Junior</b>: Es un programador de software que cuenta con poca experiencia.
4. <b>Arquitecto de software</b>: Es un experto en la Arquitectura de Software, el cual, adem√°s de trabajar en la creaci√≥n de la aplicaci√≥n, tambi√©n ayudar√° al jefe de proyecto con la gesti√≥n.

Cada uno de estos roles tendr√° que realizar una serie de tareas que les ser√°n asignadas al comienzo del proyecto, las cuales ocupan cierta cantidad de tiempo designada durante la planificaci√≥n.      

### Distribuci√≥n de casos de uso <a name="distribuciondecasosdeuso"></a>

[Excel Utilizado para la organizaci√≥n de los CASOS DE USO](https://docs.google.com/spreadsheets/d/1bhTUTApi7z-_fucTtovXuDvmLPavcS8W/edit?usp=sharing&ouid=101170322248995906530&rtpof=true&sd=true)
<p>
Para seguir este proceso, los casos de uso especificados se desarrollan e implementan a lo largo de una serie de iteraciones, las cuales duran una semana, en las que los cuatro roles distinguidos llevar√°n a cabo una las distintas disciplinas de desarrollo de los casos de uso, adem√°s de tareas de gesti√≥n del proyecto.
</p>

<p>
Estas disciplinas permitir√°n marcar la vida de desarrollo de los casos de uso, y estar√°n relacionados con las cuatro fases existentes en el m√©todo de Proceso Unificado. Las disciplinas son las siguientes:
</p>

* Modelado del negocio (Previa al inicio)
* Requisitos (Relacionada con la fase de inicio)
* An√°lisis y Dise√±o (Relacionada con la fase de elaboraci√≥n)
* Implementaci√≥n (Relacionada con la fase de construcci√≥n)
* Test e Integraci√≥n (Relacionada con la fase de transici√≥n)
* Despliegue (Posterior a la transici√≥n)

De esta forma, cada rol realiza las siguientes disciplinas:
* Jefe del proyecto: Realiza la disciplina de Modelado del negocio (BM) y tambi√©n tareas de gesti√≥n del proyecto.
* Arquitecto del software: Realiza las disciplinas Requisitos (R), An√°lisis y Dise√±o (A&D) e Implementaci√≥n (Imp). Tambi√©n colaborar√° en situaciones extraordinarias en la disciplina de Test e Integraci√≥n (T&I).
* Desarrollador de Software Junior: Realiza las disciplinas de Implementaci√≥n (Imp), Test e integraci√≥n (T&I) y Despliegue (D).
* Desarrollador de Software Senior: Realiza las disciplinas de Requisitos (R), An√°lisis y Dise√±o (A&D), Implementaci√≥n (Imp), Test e integraci√≥n (T&I) y Despliegue (D).

<p>Para resumir y poder visualizar mejor esto, realizamos la siguiente tabla:</p>
<img src="https://i.imgur.com/yItDb6b.png"/>

### An√°lisis de la distribuci√≥n <a name="analisisdeladistribucion"></a>

<p>
Para calcular el tiempo total que tendr√° disponible cada rol y cada caso de uso en n√∫mero de horas se tendr√° en cuenta una jornada laboral de 8 horas. Trabajando 5 d√≠as a la semana y teniendo en cuenta las 7 iteraciones (semanas), con lo que se obtiene la siguiente cantidad de tiempo:
</p>

<img src="https://i.imgur.com/nZJrXfF.png"/>

<p>
Esto nos da que la jornada laboral tiene 280 horas por semana, de las cuales, seg√∫n la implicaci√≥n de cada rol en el proyecto se obtiene el tiempo que emplean:

* Jefe del proyecto: **20%**
* Arquitecto del Software: **100%** 
* Desarrollador de software Senior: **100%** 
* Desarrollador de software Junior: **50%** 

Con esto, el tiempo total empleado en el proyecto es de **756 horas**.
</p>

Seg√∫n las investigaciones proporcionadas por el peri√≥dico 
[diarioSevilla](https://www.diariodesevilla.es/canalempleo/espanoles-productivos-jornada-laboral_0_1615338736.html) , en Espa√±a, existe una estimaci√≥n de productividad general de un 93% del tiempo trabajado.

<p>
<strong>Tiempo productivo en el proyecto: 93% de 756 h ‚âà 703,08 horas</strong>
</p>
<p>Con lo cual contamos con 703,08 horas de trabajo real, de las cuales el <b>15%</b> se dedica a <b>tareas de gesti√≥n del proyecto (Tareas de Project)</b>, y el resto del tiempo <b>(85%)</b> a la creaci√≥n de los casos de uso, por lo que tenemos <b>597,618 horas</b> para realizar todos los casos de uso.
</p>

<img src="https://i.imgur.com/nRQOaHS.png"/>

<p>En esta tabla se pueden observar los <b>porcentajes de tiempo</b> que se van a dedicar a cada uno de los <b>casos de uso</b>.

* Definici√≥n de requisitos: 10%
* An√°lisis y Dise√±o: 20%
* Implementaci√≥n: 45%
* Test e Integraci√≥n: 20%
* Despliegue: 5%
</p>

<p>
El tiempo que tenemos para cada caso de uso es calculado con: <b>Tiempo bruto total / N√∫mero de casos de uso</b>
</p>
<p>
De este tiempo, tanto el <b>Jefe del proyecto</b> como el <b>Arquitecto del software</b> emplear√°n tiempo para las <b>tareas de Modelado de Negocio</b>, lo cual se ha estimado que ocupar√° un <b>5%</b> del tiempo.

Por lo cual las <b>Tareas de Gesti√≥n + Modelado de negocio</b> ocupan un total de:

*105,46 + 29,89 = 135,35 horas.*

Con lo que nos quedan <b>47,31 horas</b> para realizar el resto de fases de los CU.

<img src="https://i.imgur.com/ns2n1ju.png"/>

En la tabla anterior podemos ver que los trabajadores disponen de <b>93 horas semanales</b> para realizar los casos de uso, as√≠ como las distintas cantidades de tiempo que dedicar√° cada rol en el proyecto.
</p>

### Planificaci√≥n inicial <a name="planificaciondelproyecto2"></a>
<p>
Se ha priorizado que sea el arquitecto de software el que tenga tiempo restante, como se puede ver en cada una de las siguientes tablas, para as√≠ dedic√°rselo a la gesti√≥n del proyecto.

El proyecto se desarrollar√° a lo largo de <b>7 iteraciones</b>, cada una de una semana de duraci√≥n, las cuales se organizar√° de la siguiente manera:
</p>

<p>
De esta forma, cada una de las iteraciones se han planificado en funci√≥n de las distintas <b>fases</b> que pueden realizar cada uno de los <b>roles</b>.
</p>

<p>Con lo cual la planificaci√≥n por iteraci√≥n quedar√≠a de la siguiente manera:
</p>
<p>&nbsp;</p>

üî∏ **Fase de Inicio**
<p>&nbsp;</p>
<img src="https://i.imgur.com/8yYq7dM.png"/>
<p>&nbsp;</p>

üî∏ **Fase de Elaboraci√≥n**
<p>&nbsp;</p>
<img src="https://i.imgur.com/ETmUXMZ.png"/>
<p>&nbsp;</p>

üî∏ **Fase de Construcci√≥n**
<p>&nbsp;</p>
<img src="https://i.imgur.com/KlCxGTv.png"/>

<img src="https://i.imgur.com/I0TNETc.png"/>

<img src="https://i.imgur.com/a7jpIUU.png"/>

<img src="https://i.imgur.com/9fi0OCW.png"/>
<p>&nbsp;</p>

üî∏ **Fase de Transici√≥n**
<p>&nbsp;</p>
<img src="https://i.imgur.com/bUhDX6l.png"/>

### Planificaci√≥n modificada <a name="planificaciondelproyecto3"></a>
Posteriormente, el **cliente** a√±adi√≥ cuatro casos de uso m√°s para un total de **diecis√©is** , **uno** de ellos **estructural** (CU-05), y los otros **tres no estructurales** (CU-14, CU-15 y CU-16). Puesto que no hay suficiente tiempo para realizar estas nuevas funcionalidades con la actual planificaci√≥n del proyecto,  se han a√±adido **2 iteraciones** m√°s en la fase de **transici√≥n**, las cuales han permitido solucionar esta falta de tiempo.

Esto da lugar a una planificaci√≥n compuesta por:
* Una iteraci√≥n en la fase de Inicio.
* Una iteraci√≥n en la fase de Elaboraci√≥n.
* Cinco iteraciones en la fase de Construcci√≥n.
* Dos iteraciones en la fase de Transici√≥n.

De esta forma, la planificaci√≥n por iteraci√≥n despu√©s de realizar las modificaciones ser√≠a:

<img src="https://i.imgur.com/auJmfHD.png"/>

Debido a que las cuatro primeras iteraciones tienen la misma planificaci√≥n que en la inicial, son las iteraciones de la IT5 a la IT9 las que deben ser realizadas de nuevo, dejando la planificaci√≥n modificada como la siguiente:
<p>&nbsp;</p>

üî∏ **Fase de Construcci√≥n**
<p>&nbsp;</p>
<img src="https://i.imgur.com/7NfxYXq.png"/>

<img src="https://i.imgur.com/m5JHWdZ.png"/>

<img src="https://i.imgur.com/y9oYT7m.png"/>
<p>&nbsp;</p>

üî∏ **Fase de Transici√≥n**
<p>&nbsp;</p>
<img src="https://i.imgur.com/uXOspdK.png"/>

<img src="https://i.imgur.com/PG2uIXk.png"/>
<p>&nbsp;</p>

Como podemos ver, en esta **√∫ltima iteraci√≥n** ha sido necesario que el **arquitecto** ayude a los dos roles de desarrolladores a realizar ciertas tareas de **test e integraci√≥n.**

Tambi√©n hay que tener en cuenta que todo el **tiempo que le sobra** al arquitecto es tiempo que dedica a **tareas de gesti√≥n Project** en conjunto con el jefe de proyecto.

Una vez finalizados todos los c√°lculos y cuadradas las horas del proyecto, se procede a **migrar el mismo a Microsoft Project**, una herramienta que nos permite detallar m√°s informaci√≥n acerca de fechas, horas laborales, planificaci√≥n, diagramas, tareas... etc.

Para ello, primero es necesario obtener la jornada laboral de cada uno de los roles bas√°ndose en su implicaci√≥n en el desarrollo. Esta es la siguiente:

<img src="https://i.imgur.com/ijWhNNq.png"/>
<p>&nbsp;</p>

* Jornada diaria del <b>Jefe de Proyecto</b>: 8 horas semanales / 5 d√≠as = 1.6h
* Jornada diaria del <b>Arquitecto Software</b>: 40 horas semanales / 5 d√≠as = 8h
* Jornada diaria del <b>Desarrollador Software Senior</b>: 40 horas semanales / 5 d√≠as = 8h
* Jornada diaria del <b>Desarrollador Software Junior</b>: 20 horas semanales / 5 d√≠as = 4h

A estas horas les aplicamos el porcentaje de productividad <b>93%</b> para calcular el tiempo que realmente le dedican al proyecto:

* <b>Jefe de Proyecto</b>: 1,488h
* <b>Arquitecto Software</b>: 7,44h
* <b>Desarrollador Software Senior</b>: 7,44h
* <b>Desarrollador Software Junior</b>: 3,72

En Microsoft Project  se han realizado **2 tipos de planificaciones**, una planificaci√≥n por **iteraciones** y una posterior planificaci√≥n por **casos de uso**.

<img src="https://i.imgur.com/bfOr6sr.png"/>
<p>&nbsp;</p>
Como se puede observar se ha planificado el proyecto bas√°ndose en la intervenci√≥n de los roles en cada iteraci√≥n.

Por ello, en cada iteraci√≥n se encuentran **2 secciones** dedicadas a:

* <b>Management disciplines</b>: Esta secci√≥n est√° dedicada para las tareas de gesti√≥n del proyecto, en ella trabajan tanto el jefe de proyecto como el arquitecto software, y se divide en 3 subsecciones, Project Management, Environment y Configuration & Change Management.
* <b>Use Cases Disciplines</b>: Esta secci√≥n est√° utilizada para las distintas fases de los casos de uso, en ella trabaja todo el equipo y sus posibles subsecciones son las siguientes:
   - <b>Business Modeling</b>: Esta secci√≥n se encarga por completo del jefe del proyecto, entrando dentro de lo que conocemos como el modelado del negocio.
   - <b>Requirements</b>: Esta secci√≥n corresponde con los requerimientos de cada caso de uso.
   - <b>Analysis and Design</b>: Esta secci√≥n corresponde con el an√°lisis y el dise√±o de cada caso de uso del proyecto.
   - <b>Implementation</b>: Esta subsecci√≥n corresponde con la implementaci√≥n de cada caso de uso
   - <b>Test y Integration</b>: En estas dos subsecciones corresponden con la fase de test e integraci√≥n del Excel
   - <b>Deployment</b>: Esta subsecci√≥n corresponde con el despliegue, y es la √∫ltima que se realiza antes de que el caso de uso est√© completamente desarrollado en la aplicaci√≥n.

Cada iteraci√≥n corresponde con una semana, por lo que en esta planificaci√≥n se han ido repartiendo las horas de cada trabajador en cada una de las tareas que hab√≠a que realizar para dicha integraci√≥n, de tal forma que la repartici√≥n de horas, en funci√≥n de los siguientes d√≠as y respetando su jornada laboral, se puede ver en la siguiente imagen:

<img src="https://i.imgur.com/o6TILqp.png"/>


Planificaci√≥n por casos de uso:

<img src="https://i.imgur.com/NnHGRz1.png"/>
<p>&nbsp;</p>
Para realizarla, se ha tenido en cuenta la planificaci√≥n previa por iteraciones y se han agrupado todas las intervenciones de los roles en esta por caso de uso.
En concreto, se compone de <b>3 secciones</b>:

* <b>Management</b>: Dedicada a la gesti√≥n del proyecto y el modelado de negocio, con las intervenciones del jefe del proyecto y el Arquitecto del Software
* <b>Use Cases</b>: Contiene las disciplinas realizadas de los casos de uso, en la fecha y hora que se realizaron y los roles que intervinieron.
* <b>Despliegues</b>: Contiene los despliegues de cada caso de uso, con la fecha y hora de su realizaci√≥n

### An√°lisis de la planificaci√≥n <a name="analisisdelaplanificacion"></a>
En primer lugar, la planificaci√≥n ha requerido <b>m√°s horas</b> de las que realmente se disponen para completarse, esto es debido a que en la planificaci√≥n inicial, los c√°lculos se realizaron en torno a <b>7 semanas y 12 casos de uso</b>, obteniendo un total de <b>41,23 horas</b> por cada caso de uso. Sin embargo, fue necesario modificar la planificaci√≥n del proyecto expandiendo 2 semanas su duracion. 

Se ha decidido que el <b>Arquitecto del Software</b> se encargar√° de aquellas tareas que no deb√≠a realizar por su cualificaci√≥n, pero que no se dispon√≠a del tiempo requerido para llevarlas a cabo. En este caso se trata de la disciplina de <b>Test e Integraci√≥n</b>, pues a lo largo de las <b>√∫ltimas iteraciones</b> era necesario completarla para llevar a cabo el despliegue.

Considerando la falta de horas para realizar todo el trabajo, el <b>arquitecto software</b> priorizar√° trabajar en las disciplinas dedicadas a los <b>casos de uso</b>, y tras su realizaci√≥n, dedicar√° el tiempo sobrante de cada iteraci√≥n en realizar <b>horas de gesti√≥n</b>. En la siguiente tabla se observan las <b>13,16</b> horas de gesti√≥n que realizar√° el arquitecto tras finalizar tu contribuci√≥n en las tareas dedicadas a los casos de uso.

<img src="https://i.imgur.com/sZuqyhH.png"/>


Respecto a la distribuci√≥n de horas de los distintos roles en las distintas disciplinas,  el <b>Jefe de proyecto</b> es el que se encarga de todo el tiempo de <b>Business Modeling</b>, tras ello, dedica sus horas restantes a la <b>gesti√≥n</b>.

El <b>arquitecto de software</b> por tanto se dedica a las disciplinas de Requisitos, An√°lisis y Dise√±o, Implementaci√≥n y extraordinariamente en la √∫ltima iteraci√≥n realizar√° Tests e Integraci√≥n. Como se coment√≥ previamente, invertir√° las horas restantes que tenga en cada iteraci√≥n en tareas de <b>gesti√≥n</b>.

El <b>desarrollador senior</b>, dedica todas sus horas a las siguientes disciplinas de los casos de uso: Requisitos, An√°lisis y Dise√±o, Implementaci√≥n, Test e Integraci√≥n y Despliegue. 

Finalmente el <b>desarrollador junior</b>, dedica sus horas a las siguientes disciplinas de los casos de uso: Implementaci√≥n, Test e Integraci√≥n y Despliegue.

A continuaci√≥n se muestra la distribuci√≥n de horas que se ha seguido en las disciplinas de los casos de uso para cada uno de los <b>roles</b>, exceptuando el jefe de proyecto:


Datos:

<img src="https://i.imgur.com/oMGRcTV.png"/>

<p>&nbsp;</p>
<img src="https://i.imgur.com/4TEkAy6.png"/>

<p>&nbsp;</p>
<img src="https://i.imgur.com/0DCVgGj.png"/>
<p>&nbsp;</p>


Gr√°ficos:

<img src="https://i.imgur.com/ZNHT4Gr.png"/>

<img src="https://i.imgur.com/b7LEifJ.png"/>

<img src="https://i.imgur.com/7gY8Ekp.png"/>

<img src="https://i.imgur.com/b29ITu5.png"/>

<img src="https://i.imgur.com/m0OfGct.png"/>

De esta forma, las <b>horas m√°ximas</b> que se han dedicado al proyecto respecto de las que se <b>disponen</b> en primer lugar son las siguientes:

<img src="https://i.imgur.com/gikVlbj.png"/>
<p>&nbsp;</p>

Con estos datos, se puede comprobar el **rendimiento** que se ha tenido por cada iteraci√≥n:

<img src="https://i.imgur.com/YXYwKox.png"/>

Se puede apreciar una bajada de trabajo en horas en la primera semana (semana 36), debido a que el desarrollador senior no puede trabajar en sus disciplinas por las dependencias de tareas. Respecto a las semanas posteriores, las horas de trabajo se mantienen constantes (100 horas).

A continuaci√≥n, se muestra una gr√°fica de coste de los recursos de la planificaci√≥n:

<img src="https://i.imgur.com/ruwHRHc.png"/>

El coste total del proyecto se acerca a los 28.000 ‚Ç¨, presupuesto que se desglosa seg√∫n los recursos humanos. El jefe del proyecto cobra 3.300 ‚Ç¨ durante 9 semanas desde el inicio del proyecto; El desarrollador junior gana en torno 3.300 ‚Ç¨, menos de la mitad del costo del desarrollador senior, el cual se encuentra cercano a los 10.000‚Ç¨. Por √∫ltimo, el presupuesto para cubrir el costo del arquitecto software es el m√°s alto, 11.000 ‚Ç¨.

Seguidamente, se muestra una descripci√≥n gr√°fica de las horas trabajadas por los roles en total durante toda la planificaci√≥n del proyecto. 

<img src="https://i.imgur.com/fYQTvAX.png"/>

En este informe se puede observar el trabajo restante que les queda por hacer a cada uno de los trabajadores desde la fecha de comienzo 31/08/20  hasta el 30/10/20 como esta es una fecha pasada, el trabajo previsto est√° a 0, pero aun as√≠, nos podemos hacer una idea de la carga de trabajo que soportar√° cada uno de los roles.



###  Camino Cr√≠tico <a name="caminocritico"></a>
Por √∫ltimo, dentro del an√°lisis de la planificaci√≥n nos encontramos ante el camino cr√≠tico. Este nos informar√° si hay alg√∫n punto cr√≠tico dentro del proyecto  ya sea por culpa de horas mal planificadas o sobrecarga de trabajo.

<img src="https://i.imgur.com/eKHPHmv.png"/>
<img src="https://i.imgur.com/rlrB8G1.png"/>

Como se puede ver en estas dos fotos anteriores, hay zonas cr√≠ticas debido a las horas, algunas acciones empiezan y acaban el mismo d√≠a (Business Modeling) la cual es predecesora de las disciplinas de los casos de usos.


# Configuraci√≥n del seguimiento de la planificaci√≥n <a name="configSeguimientoPlan"></a>

La planificaci√≥n del proyecto se ha trasladado a **Jira**, una herramienta centrada en la **gesti√≥n de proyectos**, seguimiento de errores y  del estado de desarrollo, la administraci√≥n de tareas y la gesti√≥n de requisitos.

As√≠ mismo, permite una profunda documentaci√≥n sobre seguimientos y errores que contendr√≠a el proyecto y gesti√≥n de workflows ideales para proyectos software √°giles, como SCRUM. Es una herramienta flexible que facilita la gesti√≥n de proyectos peque√±os, medianos o muy extensos.

Se ha decidido utilizar este software porque aporta un medio para la realizaci√≥n de la planificaci√≥n de un proyecto de forma compartida y en tiempo real gracias a la plataforma web online . As√≠ como porque presenta una interfaz relativamente sencilla e intuitiva. Adem√°s, los informes, las estad√≠sticas y los progresos se muestran en **tiempo real**. De este modo, todos los implicados est√°n siempre al d√≠a.

En cuanto a la sintaxis, cada caso de uso se ha creado como una **incidencia √©pica**, mientras que cada una de las tareas que se corresponden a cada caso de uso se han dise√±ado como tareas. Sin embargo, aquellas tareas que son compartidas por m√°s de un rol contienen una **subtarea** con la contribuci√≥n de cada rol.

Respecto a las iteraciones, estas vendr√°n definidas como un Sprint que contendr√° todas las tareas implicadas en el progreso de dicha iteraci√≥n. Por a√±adidura, todas las tareas de un caso de uso estar√°n enlazadas a la tarea √©pica del caso de uso susodicho y pertenecer√°n a un sprint concreto, correspondiente a una de las 9 iteraciones o semanas que durar√° el proyecto.

En la siguiente imagen se puede observar en detalle una tarea √©pica (caso de uso A√±adir Evento Municipio):

<p>&nbsp;</p>

<img src="https://i.imgur.com/6xKmLcR.png"/>

<p>&nbsp;</p>

En la pr√≥xima imagen se puede ver una Tarea (**Incidencia**) con atribuciones de los roles (**Subtareas**):

<p>&nbsp;</p>

<img src="https://i.imgur.com/fSwBcqe.png"/>

<p>&nbsp;</p>

En la imagen siguiente se puede ver una Iteraci√≥n (sprint) en la que se desarrollan tareas:

<p>&nbsp;</p>

<img src="https://i.imgur.com/ylNYQJG.png"/>

<p>&nbsp;</p>

Cada una de las incidencias (√©picas o de tipo tarea) tienen asociada una prioridad. Las incidencias de los casos de usos estructurales vendr√°n definidas con una prioridad **High**, mientras que las incidencias relativas a los casos de uso no estructurales **Medium**.

En lo referente al nombre/t√≠tulo de cada tarea, se especificar√° en JIRA con la siguiente sintaxis:

> _IT[N¬∫ de Iteraci√≥n] - UC[N¬∫ de caso de uso] - [fase de disciplina] - [Rol encargado]_

A partir del contexto anterior, es momento de especificar que equipos de desarrollo se han planificado para realizar el proyecto y qu√© tareas se han repartido en cada equipo. Adicionalmente, se informar√° en qu√© consisten dichas tareas y c√≥mo se realizan, estimando el tiempo que tienen el/los miembros del equipo asignados a hacerla a lo largo de las iteraciones.

Para llevar a cabo la planificaci√≥n de cada disciplina de los casos de uso, estas disciplinas se han descompuesto en tareas de la siguiente manera:

* **Definici√≥n de requisitos**:
    * An√°lisis del problema tratando de comprender a los Stakeholders.
    * Definici√≥n y redefinici√≥n de los requisitos del sistema.
* **An√°lisis y Dise√±o**:
    * Analizar el comportamiento y definir una arquitectura software candidata.
    * Dise√±ar la base de datos y los componentes del sistema.
* **Implementaci√≥n**:
    * Implementar los componentes.
    * Testear esos componentes (comprobar su funcionamiento).
* **Integraci√≥n y testeo**:
    * Integraci√≥n:
      * Integrar cada subsistema al completo.
      * Integrar todos los subsistemas al sistema.
    * Testeo:
      * Testear y evaluar el resultado.
      * Asegurarse de que el sistema proporcionado cumple con los objetivos establecidos y comprobar que los test son correctos.
* **Despliegue**:
    * Producir la Unidad de despliegue.
    * Gestionar las pruebas de instalaci√≥n del sistema en el sitio deseado.
    * Desarrollar material de soporte.

Estas  ser√°n codificadas como **tareas**, en el caso de ser compartidas por m√°s de un rol del equipo, contendr√°n unas **subtareas** con la contribuci√≥n de cada rol. Para aquellas tareas que representan de manera uniforme un caso de uso, se definen como **√©picas**.

En cuanto a las iteraciones, estas se contabilizar√°n con los **sprints**, que contendr√°n las distintas tareas que se realizar√°n dentro de dicha iteraci√≥n.

De esta forma, todas las tareas de un caso de uso ser√°n **asignadas a la Incidencia** correspondiente a dicho caso de uso, y pertenecer√°n a un sprint concreto, correspondiente a **una de las 9 iteraciones** que durar√° el proyecto.

Por tanto, dentro de Jira se ha seguido el siguiente procedimiento: 

1. Se crea una √©pica para el caso de uso que se est√© realizando

   1.1. Como nombre de √©pica se utiliza la nomenclatura CUXX.

   1.2. En el resumen se utiliza CUXX - Nombre_del_Caso.

   1.3. Se incluye una peque√±a descripci√≥n del caso de uso.

   1.4. Se a√±ade una etiqueta id√©ntica al nombre de la √©pica. 

2. Dentro de cada √©pica, se crea una incidencia de tipo tarea por cada tarea de proyect correspondiente al caso de uso

   2.1. Como resumen de la tarea se utiliza la nomenclatura ITXX - UCXX - Fase - Nombre_de_la_Tarea

   2.2. Se asignan las etiquetas correspondientes al caso de uso, la iteraci√≥n, la persona asignada a la tarea (en caso de que s√≥lo sea una), y la fase

   2.3. Se asigna al responsable de la tarea, en caso de que s√≥lo haya uno, y se a√±aden la cantidad de horas previstas. En caso de que la tarea no tenga un s√≥lo responsable, se crean las subtareas necesarias para asignar el tiempo y las personas necesarias a dicha tarea, siguiendo el mismo procedimiento que para las tareas.

3. Se revisa que las tareas y las √©picas est√°n creadas correctamente

   3.1. Se comprueba que las horas son las adecuadas.

   3.2. Se comprueba que la tarea est√° asignada a la persona correspondiente.

   3.3. Se revisan las etiquetas y el sprint asignado.

   
## Se√±or Blanco (Equipo 1) <a name="se√±orBlanco"></a>

### Proceso seguido <a name="procesoSeguidoBlanco"></a>

El se√±or blanco ha liderado al equipo 1, donde cada rol es interpretado por los siguientes miembros:

* Jefe del proyecto (JP): Sr. Blanco
* Arquitecto Software (AS): Sr. Marr√≥n
* Desarrollador Senior (DS): Sr. Naranja
* Desarrollador Junior (DJ): Sr.  Azul

El **Sr. Blanco** (JP) se encargar√° de las tareas de modelado de negocio (BM) y gesti√≥n del proyecto software, en otras palabras, se ocupar√° de asignar las tareas a realizar a cada rol. 

El **Sr. Marr√≥n** (AS) se ocupar√° de las disciplinas de Requisitos, an√°lisis y Dise√±o e Implementaci√≥n. El **Sr. Naranja** (DS) se centra en todas las disciplinas que abarcan el desarrollo completo de cada caso de uso; desde la Definici√≥n de Requisitos, An√°lisis y Dise√±o, Implementaci√≥n, Integraci√≥n y Test y Despliegue. Por √∫ltimo, el **Sr. Azul** (DJ) ejecuta las disciplinas de Implementaci√≥n, Test e Integraci√≥n y Despliegue.

* **CU01**: A√±adir Evento de Municipio.
* **CU02**: A√±adir Evento de Ruta Monta√±a.
* **CU03**: A√±adir Usuario.
* **CU04**: A√±adir una barra de b√∫squeda y filtrado de ubicaciones.

Por √∫ltimo, las incidencias relacionadas con los cinco casos de uso estructurales dispondr√°n de una prioridad alta (**High**). 

### An√°lisis del progreso <a name="analisisProgresoBlanco"></a>

En este apartado se detalla la distribuci√≥n de las tareas realizadas por cada rol a lo largo de las 9 iteraciones, seg√∫n las disciplinas que puedan realizar cada uno de ellos.

Antes de dar principio, es imprescindible aclarar que el tiempo inicial disponible del arquitecto software es de 37.20 horas semanales. En el caso de que realice sus tareas y quede tiempo sobrante, este se lo dedicar√° a tareas de gesti√≥n.

<p>&nbsp;</p>

 ‚åö **Planificaci√≥n tareas CU01 - A√±adir Evento de Municipio**

Es el primer caso de uso estructural del proyecto; el usuario podr√° a√±adir un nuevo evento de municipio en una fecha determinada, estando asignado a una condici√≥n meteorol√≥gica en tiempo real de la ubicaci√≥n del municipio. 

El desarrollo de este caso de uso comienza con su Definici√≥n de Requisitos (RE) en la **iteraci√≥n 1** y finaliza en la **iteraci√≥n 8**, con el despliegue del paquete de requisitos CU01, CU02 y CU03.

El encargado de realizar las tareas correspondientes a la **Definici√≥n de Requisitos** (RE) en la iteraci√≥n 1 es el Arquitecto software (Sr. Marr√≥n). 

En cuanto al **An√°lisis y Dise√±o** (A&D), esta disciplina comienza en la IT1 y es completada por el Desarrollador Senior (Sr. Naranja).

La **Implementaci√≥n** (Imp), como consecuencia de ser un caso de uso estructural, se realizar√° en la primera iteraci√≥n de elaboraci√≥n IT2. Los roles encargados de completar las tareas de esta disciplina son el Desarrollador Junior y el Desarrollador Senior (Sr. Azul y Sr. Naranja).

* La tarea de implementaci√≥n ‚ÄúImplementar los componentes‚Äù es compartida por los DJ y DS.

El **Test e Integraci√≥n** (T&I) se realiza en la iteraci√≥n IT4 por el Desarrollador Senior (Sr. Naranja).

En √∫ltima instancia, el **Despliegue** (D) se completa en la IT8 por el Desarrollador Junior (Sr. Azul) en el paquete de casos de uso CU01, CU02 y CU03.

En la siguiente tabla se puede ver la distribuci√≥n de manera resumida:

<img src="https://i.imgur.com/gPhoqxf.png"/>

<p>&nbsp;</p>

 ‚åö **Planificaci√≥n tareas CU02 - A√±adir Evento de Ruta Monta√±a**

Es el segundo caso de uso estructural del proyecto; El usuario podr√° a√±adir un nuevo evento de monta√±a en una fecha determinada, estando asignado a una condici√≥n meteorol√≥gica en tiempo real de la ubicaci√≥n de la monta√±a. 

El desarrollo de este caso de uso comienza con su Definici√≥n de Requisitos (RE) en la **iteraci√≥n 1** y finaliza en la **iteraci√≥n 8**, con el despliegue del paquete de requisitos CU01, CU02 y CU03.

El encargado de realizar las tareas correspondientes a la **Definici√≥n de Requisitos** (RE) en la iteraci√≥n 1 es el Arquitecto software (Sr. Marr√≥n).

En cuanto al **An√°lisis y Dise√±o** (A&D), esta disciplina comienza en la IT1 y es completada por el Desarrollador Senior (Sr. Naranja).

La **Implementaci√≥n** (Imp), como consecuencia de ser un caso de uso estructural, se realizar√° en la primera iteraci√≥n de elaboraci√≥n IT2. El rol encargado de completar las tareas de esta disciplina es el Desarrollador Senior (Sr. Naranja).

El **Test e Integraci√≥n** (T&I) se realiza en la iteraci√≥n IT4 por el Desarrollador Senior (Sr. Naranja).

En √∫ltima instancia, el **Despliegue** (D) se completa en la IT8 por el Desarrollador Junior (Sr. Azul) en el paquete de casos de uso CU01, CU02 y CU03.

En la siguiente tabla se puede ver la distribuci√≥n de manera resumida:

<img src="https://i.imgur.com/4HV2Z8U.png"/>

<p>&nbsp;</p>

 ‚åö **Planificaci√≥n tareas CU03 - A√±adir Usuario**

Es el tercer caso de uso estructural del proyecto; El sistema permite al usuario registrarse con unas credenciales, de forma que en la base de datos se inserta un nuevo objeto con la informaci√≥n relativa al nuevo perfil creado en la aplicaci√≥n. Con estas credenciales, el usuario podr√° utilizar la funcionalidad de la aplicaci√≥n.

El desarrollo de este caso de uso comienza con su Definici√≥n de Requisitos (RE) en la **iteraci√≥n 1** y finaliza en la **iteraci√≥n 8**, con el despliegue del paquete de requisitos CU01, CU02 y CU03.

El encargado de realizar las tareas correspondientes a la **Definici√≥n de Requisitos** (RE) en la iteraci√≥n 1 es el Arquitecto software (Sr. Marr√≥n).

En cuanto al **An√°lisis y Dise√±o** (A&D), esta disciplina comienza en la IT1 y es completada por el Desarrollador Senior (Sr. Naranja), en a√±adidura del Arquitecto Software (Sr. Marr√≥n) para completar las tareas.

* La tarea de An√°lisis y Dise√±o ‚ÄúAnalizar el comportamiento y definir una Arquitectura software candidata‚Äù es compartida por los AS y DS.

La **Implementaci√≥n** (Imp), como consecuencia de ser un caso de uso estructural, se realizar√° en la primera iteraci√≥n de elaboraci√≥n IT2. Los encargados de completar las tareas de esta disciplina son el Desarrollador Senior (Sr. Naranja) y el Arquitecto Software (Sr. Marr√≥n).

* La tarea de Implementaci√≥n ‚ÄúImplementar los componentes‚Äù es compartida por los AS y DS.

El **Test e Integraci√≥n** (T&I) se realiza en la iteraci√≥n IT4 por el Desarrollador Senior (Sr. Naranja).

En √∫ltima instancia, el **Despliegue** (D) se completa en la IT8 por el Desarrollador Junior (Sr. Azul) en el paquete de casos de uso CU01, CU02 y CU03.

En la siguiente tabla se puede ver la distribuci√≥n de manera resumida:

<img src="https://i.imgur.com/PA52KSN.png"/>

<p>&nbsp;</p>

 ‚åö **Planificaci√≥n tareas CU04 - A√±adir una barra de b√∫squeda y filtrado de ubicaciones**

Es el cuarto caso de uso estructural del proyecto; El sistema deber√° incorporar una barra de b√∫squeda para buscar una ubicaci√≥n con su tiempo meteorol√≥gico asignado. 

El desarrollo de este caso de uso comienza con su Definici√≥n de Requisitos (RE) en la **iteraci√≥n 1** y finaliza en la **iteraci√≥n 9**, con el despliegue del paquete de requisitos CU04‚Ä¶CU16.

El encargado de realizar las tareas correspondientes a la **Definici√≥n de Requisitos** (RE) en la iteraci√≥n 1 es el Arquitecto software (Sr. Marr√≥n). 

En cuanto al **An√°lisis y Dise√±o** (A&D), esta disciplina comienza en la IT1 y es completada por el Arquitecto Software (Sr. Marr√≥n).

La **Implementaci√≥n** (Imp), como consecuencia de ser un caso de uso estructural, se realizar√° en la primera iteraci√≥n de elaboraci√≥n IT3. Los encargados de completar las tareas de esta disciplina son el Desarrollador Senior (Sr. Naranja) y el Desarrollador Junior (Sr. Azul).

* La tarea de Implementaci√≥n ‚ÄúImplementar los componentes‚Äù es compartida por los DJ y DS.
* La tarea de Implementaci√≥n ‚ÄúTestear esos componentes (comprobar su funcionamiento)‚Äù es compartida por los DJ y DS.

El **Test e Integraci√≥n** (T&I) se realiza en la iteraci√≥n IT7 por el Desarrollador Junior (Sr. Azul).

En √∫ltima instancia, el **Despliegue** (D) se completa en la IT9 por el Desarrollador Junior (Sr. Azul) en el paquete de casos de uso CU01, CU02 y CU03.

En la siguiente tabla se puede ver la distribuci√≥n de manera resumida:

<img src="https://i.imgur.com/DuRwXEK.png"/>


## Se√±or Marr√≥n (Equipo 2) <a name="se√±orMarron"></a>

## Proceso seguido <a name="procesoSeguidoMarron"></a>

El se√±or marr√≥n ha liderado al equipo 2, donde cada rol es interpretado por los siguientes miembros:
* Jefe del proyecto (JP): Sr. Marr√≥n
* Arquitecto Software (AS): Sr. Naranja
* Desarrollador Senior (DS): Sr. Azul
* Desarrollador Junior (DJ): Sr.  Blanco

El **Sr. Marr√≥n(JP)** se encargar√° de las tareas de modelado de negocio (BM) y gesti√≥n del proyecto software, en otras palabras, se ocupar√° de asignar las tareas a realizar a cada rol. 

El **Sr. Naranja(AS)** se ocupar√° de las disciplinas de Requisitos, an√°lisis y Dise√±o e Implementaci√≥n. El Sr. Azul(DS) se centra en todas las disciplinas que abarcan el desarrollo completo de cada caso de uso; desde la Definici√≥n de Requisitos, An√°lisis y Dise√±o, Implementaci√≥n, Integraci√≥n y Test y Despliegue. Por √∫ltimo, el Sr. Blanco(DJ) ejecuta las disciplinas de Implementaci√≥n, Test e Integraci√≥n y Despliegue.

Respecto los casos de uso, el **equipo 2** se encarga de la totalidad de disciplinas de los siguientes casos de uso (en negrita, los estructurales):
* CU05: A√±adir preferencias desde el men√∫ de AppBar (ajustes‚Ä¶)
* CU06: Consultar el tiempo detallado de una ubicaci√≥n.
* CU07: Modificar un evento.
* CU08: Eliminar un evento..

Por √∫ltimo, las incidencias relacionadas con el caso de uso estructural (CU05) dispondr√°s de una prioridad alta (**High**). 

## An√°lisis del progreso <a name="analisisProgresoMarron"></a>
En este apartado se detalla la distribuci√≥n de las tareas realizadas por cada rol a lo largo de las 9 iteraciones, seg√∫n las disciplinas que puedan realizar cada uno de ellos.

Antes de dar principio, es imprescindible aclarar que el tiempo inicial disponible del arquitecto software es de 37.20 horas semanales. En el caso de que realice sus tareas y quede tiempo sobrante, este se lo dedicar√° a tareas de gesti√≥n.

<p>&nbsp;</p>

 ‚åö **Planificaci√≥n tareas CU05 - A√±adir preferencias desde el men√∫ de AppBar (ajustes‚Ä¶)**

Se trata de un caso de uso estructural; el sistema deber√° incorporar un apartado de configuraci√≥n que permite al usuario personalizar su experiencia con la aplicaci√≥n, as√≠ como el modo oscuro, preferencias‚Ä¶etc.

El desarrollo de este caso de uso comienza con su Definici√≥n de Requisitos (RE) en la **iteraci√≥n 5** y finaliza en la **iteraci√≥n 9**, con el despliegue del paquete de requisitos del CU04 al CU16.

El encargado de realizar las tareas correspondientes a la **Definici√≥n de Requisitos (RE)** en la iteraci√≥n 5 es el Desarrollador Senior (Sr. Azul). 

En cuanto al **An√°lisis y Dise√±o (A&D)**, esta disciplina comienza en la IT5 y es completada por el Desarrollador Senior (Sr. Azul).

La **Implementaci√≥n** (Imp), como consecuencia de ser un caso de uso estructural, se realizar√° cuanto antes posible, es decir, en la iteraci√≥n 6. Los roles encargados de completar las tareas de esta disciplina son el Desarrollador Junior y el Arquitecto Software (Sr. Blanco y Sr. Azul).
* Las tareas de implementaci√≥n ‚ÄúImplementar los componentes‚Äù y ‚ÄúTestear los componentes‚Äù  son compartidas por los DJ y AS.

El **Test e Integraci√≥n** (T&I) se realiza en la iteraci√≥n IT7 por el Desarrollador Senior (Sr. Azul).

En √∫ltima instancia, el **Despliegue** (D) se completa en la IT9 por el Desarrollador Senior (Sr. Azul) en el paquete de casos de uso CU04 al CU16.

En la siguiente tabla se puede ver la distribuci√≥n de manera resumida:

<img src="https://i.imgur.com/gLASWeG.png"/>

<p>&nbsp;</p>

 ‚åö **Planificaci√≥n tareas CU06 - Consultar el tiempo detallado de una ubicaci√≥n**

Es el primer caso de uso no estructural del proyecto; El usuario podr√° visualizar el tiempo meteorol√≥gico de una ubicaci√≥n espec√≠fica en tiempo real.

El desarrollo de este caso de uso comienza con su **Definici√≥n de Requisitos** (RE) en la **iteraci√≥n 1** y finaliza en la **iteraci√≥n 9**, con el despliegue del paquete de requisitos CU04‚Ä¶CU16.

El encargado de realizar las tareas correspondientes a la **Definici√≥n de Requisitos** (RE) en la iteraci√≥n 1 es el Desarrollador Senior (Sr. Azul). 

En cuanto al **An√°lisis y Dise√±o** (A&D), esta disciplina comienza en la IT2 y es completada por el Arquitecto Software (Sr. Naranja).

La **Implementaci√≥n** (Imp), se realizar√° en la segunda iteraci√≥n de construcci√≥n IT4. Los encargados de completar las tareas de esta disciplina son el Desarrollador Junior (Sr. Blanco) y el Arquitecto Software (Sr. Naranja).

* La tarea de Implementaci√≥n ‚ÄúImplementar los componentes‚Äù es compartida por los DJ y AS.

El **Test e Integraci√≥n** (T&I) se realiza en la iteraci√≥n IT7 por el Desarrollador Senior(Sr. Azul) y el Desarrollador Junior  (Sr. Blanco).
* Todas las tareas de esta disciplina son compartidas por los DS y DJ.

En √∫ltima instancia, el **Despliegue** (D) se completa en la IT9 por el Desarrollador Senior (Sr. Azul) en el paquete de casos de uso CU04‚Ä¶CU16.

En la siguiente tabla se puede ver la distribuci√≥n de manera resumida:

<img src="https://i.imgur.com/vkHZZCL.png"/>

<p>&nbsp;</p>

 ‚åö **Planificaci√≥n tareas CU07 - Modificar un evento**
En este caso de uso no estructural del proyecto; El usuario podr√° modificar los datos de un evento, as√≠ como su nombre, descripci√≥n, fecha y ubicaci√≥n.

El desarrollo de este caso de uso comienza con su Definici√≥n de Requisitos (RE) en la **iteraci√≥n 1** y finaliza en la **iteraci√≥n 9**, con el despliegue del paquete de requisitos CU04‚Ä¶CU16.

El encargado de realizar las tareas correspondientes a la **Definici√≥n de Requisitos** (RE) en la iteraci√≥n 1 es el Desarrollador Senior (Sr. Azul). 

En cuanto al **An√°lisis y Dise√±o** (A&D), esta disciplina comienza en la IT2 y es completada por el Arquitecto Software (Sr. Naranja).

La **Implementaci√≥n** (Imp), se realizar√° en la segunda iteraci√≥n de construcci√≥n IT4. El encargado de completar las tareas de esta disciplina es el Arquitecto Software (Sr. Naranja).

El **Test e Integraci√≥n** (T&I) se realiza en la iteraci√≥n IT8  por el Desarrollador Senior(Sr. Azul).

En √∫ltima instancia, el **Despliegue** (D) se completa en la IT9 por el Desarrollador Senior (Sr. Azul) en el paquete de casos de uso CU04‚Ä¶CU16.

En la siguiente tabla se puede ver la distribuci√≥n de manera resumida:

<img src="https://i.imgur.com/dprB7NY.png"/>

<p>&nbsp;</p>

 ‚åö **Planificaci√≥n tareas CU08 - Consultar el tiempo meteorol√≥gico en la ubicaci√≥n actual**
En este caso de uso no estructural del proyecto; El usuario podr√° consultar los detalles del tiempo asociado a la localizaci√≥n/municipio m√°s cercano.

El desarrollo de este caso de uso comienza con su Definici√≥n de Requisitos (RE) en la **iteraci√≥n 1** y finaliza en la **iteraci√≥n 9**, con el despliegue del paquete de requisitos CU04‚Ä¶CU16.

El encargado de realizar las tareas correspondientes a la **Definici√≥n de Requisitos** (RE) en la iteraci√≥n 1 es el Desarrollador Senior (Sr. Azul). 

En cuanto al **An√°lisis y Dise√±o** (A&D), esta disciplina comienza en la IT2 y es completada por el Arquitecto Software (Sr. Naranja).

La **Implementaci√≥n** (Imp), se realizar√° en la segunda iteraci√≥n de construcci√≥n IT4. Los encargados de completar las tareas de esta disciplina son el Desarrollador Senior (Sr. Azul) y el Arquitecto Software (Sr. Naranja).
* Ambas tareas de Implementaci√≥n son compartidas por los DS y AS.

El **Test e Integraci√≥n** (T&I) se realiza en la iteraci√≥n IT8  por el Desarrollador Senior(Sr. Azul).

En √∫ltima instancia, el **Despliegue** (D) se completa en la IT9 por el Desarrollador Senior (Sr. Azul) en el paquete de casos de uso CU04‚Ä¶CU16.

En la siguiente tabla se puede ver la distribuci√≥n de manera resumida:

<img src="https://i.imgur.com/uXfwUnr.png"/>

## Se√±or Naranja (Equipo 3) <a name="se√±orNaranja"></a>

## Proceso seguido <a name="procesoSeguidoNaranja"></a>
El se√±or naranja ha liderado al equipo 3, donde cada rol es interpretado por los siguientes miembros:
* Jefe del proyecto (JP): Sr. Naranja
* Arquitecto Software (AS): Sr. Azul
* Desarrollador Senior (DS): Sr. Blanco
* Desarrollador Junior (DJ): Sr. Marr√≥n

El **Sr. Naranja** (JP) se encargar√° de las tareas de modelado de negocio (BM) y gesti√≥n del proyecto software, en otras palabras, se ocupar√° de asignar las tareas a realizar a cada rol. 

El **Sr. Azul** (AS) se ocupar√° de las disciplinas de Requisitos, an√°lisis y Dise√±o e Implementaci√≥n. El **Sr. Blanco** (DS) se centra en todas las disciplinas que abarcan el desarrollo completo de cada caso de uso; desde la Definici√≥n de Requisitos, An√°lisis y Dise√±o, Implementaci√≥n, Integraci√≥n y Test y Despliegue. Por √∫ltimo, el **Sr. Marr√≥n** (DJ) ejecuta las disciplinas de Implementaci√≥n, Test e Integraci√≥n y Despliegue.

Respecto los casos de uso, el equipo 3 se encarga de la totalidad de disciplinas de los siguientes casos de uso:
* CU09: Consultar tiempo meteorol√≥gico en la ubicaci√≥n actual
* CU10: Modificar idioma y tema a modo oscuro
* CU11: Consultar lista de eventos.
* CU12: Consultar un evento.

Por √∫ltimo, las incidencias relacionadas con los cinco casos de uso estructurales dispondr√°n de una prioridad alta (High).

## An√°lisis del progreso <a name="analisisProgresoNaranja"></a>
En este apartado se detalla la distribuci√≥n de las tareas realizadas por cada rol a lo largo de las 9 iteraciones, seg√∫n las disciplinas que puedan realizar cada uno de ellos.

Antes de dar principio, es imprescindible aclarar que el tiempo inicial disponible del arquitecto software es de 37.20 horas semanales. En el caso de que realice sus tareas y quede tiempo sobrante, este se lo dedicar√° a tareas de gesti√≥n.

<p>&nbsp;</p>

 ‚åö **Planificaci√≥n tareas CU09 - Consultar tiempo meteorol√≥gico en la ubicaci√≥n actual**
<p>
Es el noveno caso de uso del proyecto; el usuario podr√° consultar los detalles del tiempo asociado a la localizaci√≥n/municipio m√°s cercano. Los roles que participar√°n en el desarrollo de este caso de uso son todos los miembros del equipo, exceptuando el Sr. Naranja (JP). 
</p>

El desarrollo de este caso de uso comienza con su Definici√≥n de Requisitos (RE) en la iteraci√≥n 3 y finaliza en la iteraci√≥n 9, con el despliegue del paquete de requisitos CU04‚Ä¶CU16.

El encargado de realizar las tareas correspondientes a la **Definici√≥n de Requisitos** (RE) en la **iteraci√≥n 3** es el Arquitecto software (Sr. Azul).

En cuanto al **An√°lisis y Dise√±o** (A&D), esta disciplina comienza en la **iteraci√≥n 3** y es completada por el Desarrollador Senior (Sr. Blanco).

La **Implementaci√≥n** (Imp), comienza en la **iteraci√≥n 5** y es realizada por el Desarrollador Senior y el Arquitecto Software (Sr. Blanco y Sr. Azul).

El **Test e Integraci√≥n** (T&I) se realiza en la **iteraci√≥n 8** por el Desarrollador Senior (Sr. Blanco).

En √∫ltima instancia, el **Despliegue** (D) se completa en la **iteraci√≥n 9** por el Desarrollador Senior (Sr. Blanco) en el paquete de casos de uso CU04 ‚Ä¶ CU16.

En la siguiente tabla se puede ver la distribuci√≥n de manera resumida:

<img src="https://i.imgur.com/24eBqsa.png"/>

 ‚åö **Planificaci√≥n tareas CU10 - Modificar idioma y tema a modo oscuro**
<p>
Es el d√©cimo caso de uso del proyecto; el usuario podr√° realizar una serie de modificaciones en la aplicaci√≥n para configurar esta a su gusto como cambiar el idioma, el tema a modo oscuro, etc.
</p>

El desarrollo de este caso de uso comienza con su **Definici√≥n de Requisitos** (RE) en la iteraci√≥n 3 y finaliza en la iteraci√≥n 9, con el **despliegue** del paquete de requisitos CU04-16.

El encargado de realizar las tareas correspondientes a la **Definici√≥n de Requisitos** (RE) en la **iteraci√≥n 3** es el Arquitecto software (Sr. Azul).

En cuanto al **An√°lisis y Dise√±o** (A&D), esta disciplina comienza en la **iteraci√≥n 3** y es completada por el Desarrollador Senior (Sr. Blanco).

La **Implementaci√≥n** (Imp), esta disciplina comienza en la **iteraci√≥n 5** y es realizada por el Arquitecto Software (Sr. Azul).

El **Test e Integraci√≥n** (T&I) se realiza en la iteraci√≥n **iteraci√≥n 8** por el Desarrollador Senior y el Desarrollador Junior (Sr. Blanco y Sr. Marr√≥n).

En √∫ltima instancia, el **Despliegue** (D) se completa en la **iteraci√≥n 9** por el Desarrollador Senior (Sr. Blanco) en el paquete de casos de uso CU04 ‚Ä¶ CU16.

En la siguiente tabla se puede ver la distribuci√≥n de manera resumida:

<img src="https://i.imgur.com/PYvgEx1.png"/>

 ‚åö **Planificaci√≥n tareas CU11 - Consultar lista de eventos**
<p>
Es el und√©cimo caso de uso del proyecto; el usuario podr√° visualizar el listado completo de eventos de municipios y monta√±as creados por su parte.
</p>

El desarrollo de este caso de uso comienza con su **Definici√≥n de Requisitos** (RE) en la iteraci√≥n 3 y finaliza en la iteraci√≥n 9, con el **despliegue** del paquete de requisitos CU04-16.

El encargado de realizar las tareas correspondientes a la **Definici√≥n de Requisitos** (RE) en la **iteraci√≥n 3** es el Arquitecto software (Sr. Azul).

En cuanto al **An√°lisis y Dise√±o** (A&D), esta disciplina comienza en la **iteraci√≥n 3** y es completada por el Desarrollador Senior (Sr. Blanco).

La **Implementaci√≥n** (Imp), esta disciplina comienza en la **iteraci√≥n 5** y es realizada por el Desarrollador Senior y el Arquitecto Software (Sr. Blanco y Sr. Azul).

El **Test e Integraci√≥n** (T&I) se realiza en la **iteraci√≥n 8** por el Desarrollador Junior (Sr. Marr√≥n).

En √∫ltima instancia, el **Despliegue** (D) se completa en la **iteraci√≥n 9** por el Desarrollador Senior (Sr. Blanco) en el paquete de casos de uso CU04 ‚Ä¶ CU16.

En la siguiente tabla se puede ver la distribuci√≥n de manera resumida:

<img src="https://i.imgur.com/KHBwNMY.png"/>

 ‚åö **Planificaci√≥n tareas CU12 - Consultar un evento**
<p>
Es el duod√©cimo caso de uso del proyecto; el usuario podr√° visualizar en detalle los datos pertinentes de un evento de municipio o monta√±a.
</p>

El desarrollo de este caso de uso comienza con su **Definici√≥n de Requisitos** (RE) en la iteraci√≥n 3 y finaliza en la iteraci√≥n 9, con el **despliegue** del paquete de requisitos CU04-16.

El encargado de realizar las tareas correspondientes a la **Definici√≥n de Requisitos** (RE) en la **iteraci√≥n 3** es el Arquitecto software (Sr. Azul).

En cuanto al **An√°lisis y Dise√±o** (A&D), esta disciplina comienza en la **iteraci√≥n 3** y es realizada por el Desarrollador Senior y el Arquitecto Software (Sr. Blanco y Sr. Azul).
* La tarea de An√°lisis y dise√±o ‚ÄúAnalizar el comportamiento y definir una Arquitectura software candidata‚Äù es compartida por los DS y AS.

La **Implementaci√≥n** (Imp), comienza en la **iteraci√≥n 6** y es realizada por el Desarrollador Senior (Sr. Blanco).

El **Test e Integraci√≥n** (T&I) se realiza en la **iteraci√≥n 9** por el Desarrollador Junior (Sr. Marr√≥n).

En √∫ltima instancia, el **Despliegue** (D) se completa en la **iteraci√≥n 9** por el Desarrollador Senior (Sr. Blanco) en el paquete de casos de uso CU04 ‚Ä¶ CU16.

En la siguiente tabla se puede ver la distribuci√≥n de manera resumida:

<img src="https://i.imgur.com/Rdmjam4.png"/>

## Se√±or Azul (Equipo 4) <a name="se√±orAzul"></a>

### Proceso seguido <a name="procesoSeguidoAzul"></a>

El se√±or azul ha liderado al equipo 4, donde cada rol es interpretado por los siguientes miembros:
* Jefe del proyecto (JP): Sr. Azul
* Arquitecto Software (AS): Sr. Blanco
* Desarrollador Senior (DS): Sr. Marr√≥n
* Desarrollador Junior (DJ): Sr.  Naranja

El **Sr. Azul** (JP) se encargar√° de las tareas de modelado de negocio (BM) y gesti√≥n del proyecto software, en otras palabras, se ocupar√° de asignar las tareas a realizar a cada rol. 

El **Sr. Blanco** (AS) se ocupar√° de las disciplinas de Requisitos, an√°lisis y Dise√±o e Implementaci√≥n. 

El **Sr. Marr√≥n** (DS) se centra en todas las disciplinas que abarcan el desarrollo completo de cada caso de uso; desde la Definici√≥n de Requisitos, An√°lisis y Dise√±o, Implementaci√≥n, Integraci√≥n y Test y Despliegue. Por √∫ltimo, 

El **Sr. Naranja** (DJ) ejecuta las disciplinas de Implementaci√≥n, Test e Integraci√≥n y Despliegue.
	
Respecto los casos de uso, el equipo 4 se encarga de la totalidad de disciplinas de los siguientes casos de uso:
* CU-13: Iniciar sesi√≥n.
* CU-14: Cerrar sesi√≥n.
* CU-15: Modificar usuario.
* CU-16: Eliminar usuario.


### An√°lisis del progreso <a name="analisisProgresoAzul"></a>
En este apartado se detalla la distribuci√≥n de las tareas realizadas por cada rol a lo largo de las 9 iteraciones, seg√∫n las disciplinas que puedan realizar cada uno de ellos.

Antes de empezar, es imprescindible aclarar que el tiempo inicial disponible del arquitecto software es de 37.20 horas semanales. En el caso de que realice sus tareas y quede tiempo sobrante, este se lo dedicar√° a tareas de gesti√≥n.

<p>&nbsp;</p>

 ‚åö **Planificaci√≥n tareas CU13 - Iniciar sesi√≥n**
<p>
En este caso de uso el usuario podr√° iniciar sesi√≥n dentro de la aplicaci√≥n, para lo cual deber√° haber creado previamente su usuario. 
Todos los roles participar√°n de manera conjunta para el desarrollo de este caso de uso. 
</p>

El desarrollo de este caso de uso comienza con su **Definici√≥n de Requisitos** (RE) en la iteraci√≥n 3 y finaliza en la iteraci√≥n 9, con el **despliegue** del paquete de requisitos **CU04-16**.

El encargado de la **Definici√≥n de Requisitos** (RE) en la **iteraci√≥n 3** es el Arquitecto software (Sr. Blanco). 

En cuanto al **An√°lisis y Dise√±o** (A&D), esta disciplina comienza en la **iteraci√≥n 3** y es completada por el Arquitecto software (Sr. Blanco).

La **Implementaci√≥n** (Imp) se realizar√° en la **iteraci√≥n 6**. Los roles encargados de completar las tareas de esta disciplina son el Desarrollador Senior (Sr. Marr√≥n) y el Arquitecto software (Sr. Blanco).

El **Test e Integraci√≥n** (T&I) se realiza en la **iteraci√≥n 9** y es completada por el Desarrollador Senior (Sr. Marr√≥n) y el Desarrollador junior (Sr. Naranja).

Por √∫ltimo, el **Despliegue** (D) se completa en la **iteraci√≥n 9** por el Desarrollador Senior (Sr. Marr√≥n) en el paquete de casos de uso CU04-16.

En la siguiente tabla se puede ver la distribuci√≥n de manera resumida:
<img src="https://i.imgur.com/S7OGneq.png"/>

<p>&nbsp;</p>

 ‚åö **Planificaci√≥n tareas CU14 - Cerrar sesi√≥n**
<p>
En este caso de uso el usuario podr√° cerrar su sesi√≥n dentro de la aplicaci√≥n, para lo cual deber√° haber iniciado previamente su sesi√≥n de usuario. 
Todos los roles participar√°n de manera conjunta para el desarrollo de este caso de uso. 
</p>

El desarrollo de este caso de uso comienza con su **Definici√≥n de Requisitos** (RE) en la iteraci√≥n 5 y finaliza en la iteraci√≥n 9, con el **despliegue** del paquete de requisitos **CU04-16**.

El encargado de la **Definici√≥n de Requisitos** (RE) en la **iteraci√≥n 5** es el Desarrollador Senior (Sr. Marr√≥n). 

En cuanto al **An√°lisis y Dise√±o** (A&D), esta disciplina comienza en la **iteraci√≥n 6** y es completada por el Arquitecto software (Sr. Blanco).

La **Implementaci√≥n** (Imp) se realizar√° en la **iteraci√≥n 7** y es completada por el Desarrollador Senior (Sr. Marr√≥n).

El **Test e Integraci√≥n** (T&I) se realiza en la **iteraci√≥n 9** y es completada por el Desarrollador Senior (Sr. Marr√≥n) y el Arquitecto software (Sr. Blanco).

Por √∫ltimo, el **Despliegue** (D) se completa en la **iteraci√≥n 9** por el Desarrollador Senior (Sr. Marr√≥n) en el paquete de casos de uso CU04-16.

En la siguiente tabla se puede ver la distribuci√≥n de manera resumida:
<img src="https://i.imgur.com/DpjKGVs.png"/>

 ‚åö **Planificaci√≥n tareas CU15 - Modificar usuario**
<p>
En este caso de uso el usuario podr√° modificar su perfil dentro de la aplicaci√≥n, para lo cual deber√° haber iniciado previamente su sesi√≥n de usuario. 
Todos los roles participar√°n de manera conjunta para el desarrollo de este caso de uso. 
</p>

El desarrollo de este caso de uso comienza con su **Definici√≥n de Requisitos** (RE) en la iteraci√≥n 5 y finaliza en la iteraci√≥n 9, con el **despliegue** del paquete de requisitos **CU04-16**.

El encargado de la **Definici√≥n de Requisitos** (RE) en la **iteraci√≥n 5** es el Desarrollador Senior (Sr. Marr√≥n). 

En cuanto al **An√°lisis y Dise√±o** (A&D), esta disciplina comienza en la **iteraci√≥n 6** y es completada por el Arquitecto software (Sr. Blanco).

La **Implementaci√≥n** (Imp) se realizar√° en la **iteraci√≥n 7** y es completada por el Desarrollador Senior (Sr. Marr√≥n) y el Arquitecto software (Sr. Blanco).

El **Test e Integraci√≥n** (T&I) se realiza en la **iteraci√≥n 9** y es completada por el Arquitecto software (Sr. Blanco).

Por √∫ltimo, el **Despliegue** (D) se completa en la **iteraci√≥n 9** por el Desarrollador Senior (Sr. Marr√≥n) en el paquete de casos de uso CU04-16.

En la siguiente tabla se puede ver la distribuci√≥n de manera resumida:
<img src="https://i.imgur.com/ei5FuEx.png"/>

 ‚åö **Planificaci√≥n tareas CU16 - Eliminar usuario**
<p>
En este caso de uso el usuario podr√° eliminar su perfil dentro de la aplicaci√≥n, para lo cual deber√° haber iniciado previamente su sesi√≥n de usuario. 
Todos los roles participar√°n de manera conjunta para el desarrollo de este caso de uso. 
</p>

El desarrollo de este caso de uso comienza con su **Definici√≥n de Requisitos** (RE) en la iteraci√≥n 5 y finaliza en la iteraci√≥n 9, con el **despliegue** del paquete de requisitos **CU04-16**.

El encargado de la **Definici√≥n de Requisitos** (RE) en la **iteraci√≥n 5** es el Desarrollador Senior (Sr. Marr√≥n). 

En cuanto al **An√°lisis y Dise√±o** (A&D), esta disciplina comienza en la **iteraci√≥n 6** y es completada por el Arquitecto software (Sr. Blanco).

La **Implementaci√≥n** (Imp) se realizar√° en la **iteraci√≥n 7** y es completada por el Arquitecto software (Sr. Blanco).

El **Test e Integraci√≥n** (T&I) se realiza en la **iteraci√≥n 9** y es completada por el Arquitecto software (Sr. Blanco).

Por √∫ltimo, el **Despliegue** (D) se completa en la **iteraci√≥n 9** por el Desarrollador Senior (Sr. Marr√≥n) en el paquete de casos de uso CU04-16.

En la siguiente tabla se puede ver la distribuci√≥n de manera resumida:
<img src="https://i.imgur.com/Fg0Egaz.png"/>


### Proporci√≥n de √âpicas, Tareas y Subtareas <a name="grafomarron"></a>
En el siguiente gr√°fico de tipo tarta se presenta la distribuci√≥n existente en el proyecto de los distintos tipos de incidencias: √©picas ( Casos de Uso), tareas y subtareas.

Se puede apreciar que la mayor parte del gr√°fico est√° compuesto por Tareas, seguido de un n√∫mero alto de Subtareas.

Podemos observar que hay 16 incidencias de tipo √âpica, las cuales referencian los casos de uso del proyecto.
<img src="https://i.imgur.com/0pmXF6h.png"/>

A continuaci√≥n se muestra el porcentaje de cada uno de estos tipos de incidencia:

<img src="https://i.imgur.com/uDYMGrD.png"/>


### Proporci√≥n de √âpicas, Tareas y Subtareas <a name="grafonaranja"></a>
En el siguiente gr√°fico de tipo tarta, se puede ver la distribuci√≥n de incidencias a lo largo de cada una de las iteraciones. 

Se puede apreciar que las iteraciones que m√°s incidencias contienen son las iteraciones 8 y 9 puesto que en ellas se realizan las tareas de despliegue de los casos de uso.

Las tareas que no est√°n asignadas a ninguna iteraci√≥n corresponden a las 16 tareas √âpicas que son los casos de uso.

<img src="https://i.imgur.com/gWbvTY5.png"/>

A continuaci√≥n se muestra una tabla con los porcentajes de cada iteraci√≥n:
<img src="https://i.imgur.com/BZvjK3M.png"/>


### Proporci√≥n de tareas por caso de uso <a name="grafoazul"></a>
En el siguiente informe de tipo tarta se puede observar la distribuci√≥n por casos de uso de las tareas. Cada caso de uso cuenta con el mismo n√∫mero de tareas pues todos tienen las mismas fases.

Se puede apreciar un gran n√∫mero de tareas no asignadas a ning√∫n caso de uso. Corresponden a las subtareas, las cuales heredan el caso de uso al que pertenecen de la tarea padre. Por lo que este grafico nos sirve para saber cu√°ntas tareas tiene cada **Caso de Uso** y el n√∫mero de subtareas del proyecto.

<img src="https://i.imgur.com/I1CbHxH.png"/>


### Contribuci√≥n de los l√≠deres de equipo <a name="contribucionBlanco"></a>

Por √∫ltimo, mediante los informas del Jira se va mostrar la **contribuci√≥n de cada usuario** a las tareas asignadas a cada caso de uso, adem√°s del tiempo estimado que se espera que tarden dichas tareas en realizarse.

* **Se√±or Blanco**:

<img src="https://i.imgur.com/ca0aZZ0.png"/>

* **Se√±or Marron**:

<img src="https://i.imgur.com/qzs3Vg7.png"/>

* **Se√±or Naranja**:

<img src="https://i.imgur.com/P01Ugy6.png"/>

* **Se√±or Azul**:

<img src="https://i.imgur.com/WPeRALn.png"/>

Hay que concretar que dentro de este informe no se tienen en cuenta las **subtareas**, ni el tiempo que estas ocupan en cada usuario, por lo que puede variar entre distintos usuarios.

# Progreso del proyecto <a name="desarrolloProgreso"></a>

**Importante**: durante el desarrollo de la pr√°ctica de GPS, inicialmente se crearon las ramas referentes a los primeros 4 casos de uso. Seguidamente se implementaron los 4 casos de usos con sus commits (ligados a las tareas de Jira) y se integraron en la rama develop. En este instante, nos percatamos de que se nos hab√≠a olvidado crear el resto de ramas (cu05-cu16), de manera que estas ramas se crearon a partir de la integracion de los primeros casos de uso en la rama develop.

## S√≠ntesis de la planificaci√≥n por roles <a name="sintesisPlanificacion"></a>

En este apartado se documentar√° la distribuci√≥n de los casos de uso, realizados teniendo en cuenta el punto de vista de los roles, que participan en cada uno de los equipos, a modo de s√≠ntesis del apartado de configuraci√≥n del seguimiento de planificaci√≥n. 
En concreto, estos roles siguen la siguiente planificaci√≥n:

<img src="https://imgur.com/dzITlYn.png"/>

Siendo cada uno de los roles el l√≠der de uno de los 4 equipos.

As√≠ mismo, la planificaci√≥n de los roles respecto de las disciplinas de Implementaci√≥n e Integraci√≥n y Testeo es:

<img src="https://imgur.com/koHJTPj.png"/>

Para comprobar que este reparto de tareas es equitativo entre los distintos roles, a continuaci√≥n se muestra el n√∫mero de tareas asignadas a cada rol, en la que cada disciplina compartida por 2 roles es ponderada con 0,5 en cada rol:

**Distribuci√≥n de implementaciones:**
| Encargado  | Casos de uso                                   | N√∫m |
| ---------- | ---------------------------------------------- | --- |
| Sr Blanco  | CU05, CU06, CU11, CU12, CU13, CU15, CU16       | 4,5 |
| Sr Marron  | CU03, CU09, CU13, CU14, CU15                   | 3   |
| Sr Naranja | CU01, CU02, CU03, CU04, CU05, CU06, CU07, CU08 | 5   |
| Sr Azul    | CU01, CU04, CU08, CU09, CU10, CU11             | 3,5 |

**Distribuci√≥n de integraciones:**
| Encargado  | Casos de uso                       | N√∫m |
| ---------- | ---------------------------------- | --- |
| Sr Blanco  | CU06, CU09, CU10, CU14, CU15, CU16 | 4,5 |
| Sr Marron  | CU10,  CU11, CU12, CU14            | 3   |
| Sr Naranja | CU01, CU02, CU03, CU13             | 4   |
| Sr Azul    | CU04, CU05, CU06, CU07, CU08       | 4,5 |

## Proceso seguido del Equipo 1 (Sr. Blanco) <a name="desarrolloEquipo1"></a>

En este apartado se documentar√° todo el proceso seguido por el Equipo 1 para realizar los casos de uso, desde la implementaci√≥n hasta la integraci√≥n final. Se detalla **qu√© archivos se han modificado** concretamente y **c√≥mo se ha realizado la integraci√≥n** de estos casos de uso.

El equipo 1 ser√° el encargado de llevar a cabo los casos de uso **CU01, CU02, CU03 y CU04.** A continuaci√≥n se explicar√°n las tareas de implementaci√≥n e integraci√≥n que se han realizado en cada uno de ellos.

### CU01 - A√±adir Evento de Municipio

Este caso de uso estructural permite al usuario a√±adir un nuevo evento de municipio en una fecha determinada, estando asignado a una condici√≥n meteorol√≥gica en tiempo real de la ubicaci√≥n del municipio.

#### Implementaci√≥n de CU01

Para realizar este caso de uso ha sido necesaria la creaci√≥n de la clase Evento perteneciente a la l√≥gica de negocio. Esta clase evento, adem√°s requiri√≥ emplear el servicio de Room para almacenar los eventos en la base de datos, por lo que tambi√©n ha sido necesaria la realizaci√≥n de una interfaz EventoDao. As√≠ mismo, en este caso de uso tambi√©n se ha creado la clase **AppDatabase** para conectarse a la base de datos.

As√≠ mismo, se han creado las clases necesarias para obtener todos los municipios existentes de Espa√±a, que se encuentran en un documento **municipios.json.** Dichas clases son JsonSingleton, que permite obtener los datos del documento, y Municipio, que representa cada municipio obtenido.

Esta disciplina ha sido realizada en conjunto por el **Sr. Naranja** y el **Sr. Azul.**

Por tanto, en la realizaci√≥n de este caso de uso se han creado las siguientes clases:
* La Activity correspondientes a la pantalla de crear un evento de Municipio (CrearEventoActivity) y sus fragmentos (CrearEvento y CrearEventoMunicipio), junto con los layout correspondiente a dichos componentes software
* La clase Evento
* Una Interfaz EventoDao
* La clase AppDatabase
* Las clases correspondientes para obtener los municipios de la API (JsonSingleton y Municipio)

#### Integraci√≥n de CU01

La integraci√≥n de este caso de uso √∫nicamente ha necesitado **la publicaci√≥n del c√≥digo terminado** lanzando una primitiva **Push** en la rama del repositorio correspondiente, pues no necesita la implementaci√≥n de ning√∫n otro caso de uso.

Esta disciplina ha sido realizada por el **Sr. Naranja.**

Una vez finalizada esta fase, se **integrar√° este caso de uso en la rama Develop** con todos los cambios de la rama correspondiente mediante un Merge, publicando despu√©s los cambios correspondientes en la rama Develop mediante la primitiva Push.

### CU02 - A√±adir Evento de Ruta Monta√±a

Este caso de uso estructural permite al usuario a√±adir un nuevo evento de monta√±a en una fecha determinada, estando asignado a una condici√≥n meteorol√≥gica en tiempo real de la ubicaci√≥n de la monta√±a.

#### Implementaci√≥n de CU02
Para realizar este caso de uso ha sido necesaria la implementaci√≥n del CU01 - Crear Evento de Municipio, que contiene las clases Evento y EventoDAO, utilizando tambi√©n la clase **AppDatabase.**

Esto ha implicado la creaci√≥n de un nuevo fragmento CrearEventoMontana en la actividad de creaci√≥n de un evento (CrearEventoActivity), que permite crear un evento de monta√±a concreto a partir de las monta√±as existentes.

Esta disciplina ha sido realizada por el **Sr. Naranja.**

Por tanto, la implementaci√≥n de este caso de uso ha supuesto la creaci√≥n de la siguiente clase:

* El fragmento CrearEventoMontana y su layout

#### Integraci√≥n de CU02

La integraci√≥n de este caso de uso ha necesitado la integraci√≥n previamente del caso de uso CU01, por lo que se ha realizado una primitiva **Merge** para trabajar sobre el c√≥digo con este caso de uso realizado.

Posteriormente, una vez que el caso de uso est√° implementado, **se ha realizado la publicaci√≥n del c√≥digo** terminado en la rama del repositorio correspondiente lanzando una primitiva **Push.** Esta tarea la ha realizado el **Sr. Naranja.**

Una vez finalizada esta fase, se **integrar√° este caso de uso en la rama Develop** con todos los cambios de la rama correspondiente mediante un Merge, publicando despu√©s los cambios correspondientes en la rama Develop mediante la primitiva Push.

### CU03 - A√±adir Usuario

Este caso de uso estructural permite al usuario registrarse con unas credenciales.

#### Implementaci√≥n de CU03

Para realizar este caso de uso ha sido necesaria la implementaci√≥n del CU02 - A√±adir Ruta de Monta√±a, que crea un evento de Monta√±a en la base de datos.

Este caso de uso contiene las clases Usuario y UsuarioDAO, utilizando tambi√©n la clase **AppDatabase.** 

Esta disciplina ha sido realizada en conjunto por el **Sr. Naranja** y el **Sr. Marr√≥n.**

Por tanto, la implementaci√≥n de este caso de uso ha supuesto la modificaci√≥n de la siguiente clase:

* La Activity Main

As√≠ mismo, ha supuesto la creaci√≥n de las siguientes clases:

* Las Activity correspondiente a la pantalla de registro (Registrarse) y su layout
* La clase del modelo de datos Usuario
* Una Interfaz UsuarioDao

#### Integraci√≥n de CU03

La integraci√≥n de este caso de uso ha necesitado la integraci√≥n previamente del caso de uso CU02 - A√±adir Evento de Ruta Monta√±a.

Posteriormente, una vez que el caso de uso est√° implementado, **se ha realizado la publicaci√≥n del c√≥digo** terminado en la rama del repositorio correspondiente lanzando una primitiva **Push.** Esta tarea la ha realizado el **Sr. Naranja.**

Una vez finalizada esta fase, se **integrar√° este caso de uso en la rama Develop** con todos los cambios de la rama correspondiente mediante un Merge, publicando despu√©s los cambios correspondientes en la rama Develop mediante la primitiva Push.

### CU04 - A√±adir una barra de b√∫squeda y filtrado de ubicaciones

Este caso de uso estructural consiste en la incorporaci√≥n de una barra de b√∫squeda para buscar una ubicaci√≥n con su tiempo meteorol√≥gico asignado.

#### Implementaci√≥n de CU04

Para realizar este caso de uso ha sido necesaria la implementaci√≥n del CU03 - A√±adir Usuario, que contiene las clases Usuario y UsuarioDAO, utilizando tambi√©n la clase AppDatabase.

Esta disciplina ha sido realizada en conjunto por el **Sr. Naranja** y el **Sr. Azul.**

La implementaci√≥n de este caso de uso se ha completado, mediante la modificaci√≥n de las siguientes clases:

* MainActivity. Incluye la incorporaci√≥n del icono que redirige al listado de ubicaciones
* AndroidManifest
* Layout del men√∫ main.xml

Adem√°s, se han a√±adido las siguientes clases:

* La actividad LocalizacionesActivity
* Clase APIManager y APIManagerDelegate

### Integraci√≥n de CU04

La integraci√≥n de este caso de uso ha necesitado la integraci√≥n previamente del caso de uso CU03, por lo que se ha realizado una primitiva **Merge** para trabajar sobre el c√≥digo con este caso de uso realizado.

Posteriormente, una vez que el caso de uso est√° implementado, **se ha realizado la publicaci√≥n del c√≥digo** terminado en la rama del repositorio correspondiente lanzando una primitiva **Push.** Esta tarea la ha realizado el **Sr Azul.**

Una vez finalizada esta fase, **se integrar√° este caso de uso en la rama Develop** con todos los cambios de la rama correspondiente mediante un Merge, publicando despu√©s los cambios correspondientes en la rama Develop mediante la primitiva Push.

## Proceso seguido del Equipo 2 (Sr. Marr√≥n) <a name="desarrolloEquipo2"></a>

En este apartado se documentar√° todo el proceso seguido por el Equipo 2 para realizar los casos de uso, desde la implementaci√≥n hasta la integraci√≥n final. Se detalla **qu√© archivos se han modificado** concretamente y **c√≥mo se ha realizado la integraci√≥n** de estos casos de uso.

El equipo 2 ser√° el encargado de llevar a cabo los casos de uso CU05, CU06, CU07 y CU08. A continuaci√≥n se explicar√°n las tareas de implementaci√≥n e integraci√≥n que se han realizado en cada uno de ellos.

### CU05 - A√±adir preferencias desde el men√∫ de AppBar (ajustes ‚Ä¶)

Este caso de uso estructural consiste en incorporar un apartado de configuraci√≥n que permite al usuario personalizar su experiencia con la aplicaci√≥n, as√≠ como el modo oscuro, preferencias, etc.

#### Implementaci√≥n de CU05

Para realizar este caso de uso ha sido necesaria la implementaci√≥n del caso de uso CU13 - Iniciar sesi√≥n, que contiene la clase IniciarSesion (Activity).

Esta disciplina ha sido realizada en conjunto por el **Sr. Naranja** y el **Sr. Blanco.**

La implementaci√≥n de este caso de uso se ha completado mediante la modificaci√≥n de las siguientes clases:

* Se ha modificado todos los archivos relativos al panel lateral de navegaci√≥n, drawer, etc.

Adem√°s, se han a√±adido las siguientes clases:

* AjustesFragment y su correspondiente layout

#### Integraci√≥n de CU05

La integraci√≥n de este caso de uso ha necesitado la integraci√≥n previamente del caso de uso CU13, por lo que se ha realizado una primitiva **Merge** para trabajar sobre el c√≥digo con este caso de uso realizado.

Posteriormente, una vez que el caso de uso est√° implementado, **se ha realizado la publicaci√≥n del c√≥digo** terminado en la rama del repositorio correspondiente lanzando una primitiva **Push.** Esta tarea la ha realizado el **Sr Azul.**

Una vez finalizada esta fase, se **integrar√° este caso de uso en la rama Develop** con todos los cambios de la rama correspondiente mediante un Merge, publicando despu√©s los cambios correspondientes en la rama Develop mediante la primitiva Push.

### CU06 - Consultar el tiempo detallado de una ubicaci√≥n

Este caso de uso no estructural permite al usuario visualizar el tiempo meteorol√≥gico de una ubicaci√≥n espec√≠fica en tiempo real.

#### Implementaci√≥n de CU06

Para realizar este caso de uso ha sido necesaria la implementaci√≥n del caso de uso CU04 - A√±adir una barra de b√∫squeda y filtrado de ubicaciones, el cual incluye las clases java necesarias para realizar peticiones a la API. Se ha necesitado crear una nueva actividad que gestione el detalle del tiempo de una ubicaci√≥n, de la lista de ubicaciones (municipios).

Esta disciplina ha sido realizada en conjunto por el **Sr. Naranja** y el **Sr. Blanco.**

La implementaci√≥n de este caso de uso se ha completado mediante la modificaci√≥n de las siguientes clases:

* Clase ListadoLocalizacionesActivity

Adem√°s, se han incluido la siguiente clase:

* DetalleLocalizaci√≥nActivity y su layout

#### Integraci√≥n de CU06

La integraci√≥n de este caso de uso ha necesitado la integraci√≥n previamente del caso de uso CU04, por lo que se ha realizado una primitiva **Merge** para trabajar sobre el c√≥digo con este caso de uso realizado.

Posteriormente, una vez que el caso de uso est√° implementado, **se ha realizado la publicaci√≥n del c√≥digo** terminado en la rama del repositorio correspondiente lanzando una primitiva **Push.**

Esta disciplina ha sido realizada en conjunto por el **Sr. Azul** y el **Sr. Blanco.**

Una vez finalizada esta fase, **se integrar√° este caso de uso en la rama Develop** con todos los cambios de la rama correspondiente mediante un Merge, publicando despu√©s los cambios correspondientes en la rama Develop mediante la primitiva Push.

### CU07 - Modificar un evento

Este caso de uso no estructural permite al usuario modificar los datos de un evento, as√≠ como su nombre, descripci√≥n, fecha y ubicaci√≥n.

#### Implementaci√≥n de CU07

Para realizar este caso de uso ha sido necesaria la implementaci√≥n del caso de uso CU06 - Consultar el tiempo detallado de una ubicaci√≥n, el cual incluye los componentes software de Android necesarios para elegir y ver las condiciones meteorol√≥gicas de una ubicaci√≥n espec√≠fica.

Esta disciplina ha sido realizada por el **Sr. Naranja.**

La implementaci√≥n de este caso de uso se ha completado mediante la modificaci√≥n de las siguientes clases:

* La clase DAO de los eventos llamada EventoDAO

Adem√°s, se han creado las siguientes clases:

* Los fragmentos ModificarEventoMontanaFragment y ModificarEventoMunicipioFragment y sus respectivos layouts.

#### Integraci√≥n de CU07

La integraci√≥n de este caso de uso ha necesitado la integraci√≥n previamente del caso de uso CU06, por lo que se ha realizado una primitiva **Merge** para trabajar sobre el c√≥digo con este caso de uso realizado.

Posteriormente, una vez que el caso de uso est√° implementado, **se ha realizado la publicaci√≥n del c√≥digo** terminado en la rama del repositorio correspondiente lanzando una primitiva **Push.**

Esta disciplina ha sido realizada por el **Sr. Azul.**

Una vez finalizada esta fase, **se integrar√° este caso de uso en la rama Develop** con todos los cambios de la rama correspondiente mediante un Merge, publicando despu√©s los cambios correspondientes en la rama Develop mediante la primitiva Push.

### CU08 - Eliminar un evento

Este caso de uso no estructural permite al usuario borrar un evento creado y configurado previamente en la lista de eventos.

#### Implementaci√≥n de CU08

Para realizar este caso de uso ha sido necesaria la implementaci√≥n del CU01 - Crear Evento de Municipio y el caso CU02 - Crear Evento de Monta√±a, que contiene las clases Evento y EventoDAO, utilizando tambi√©n la clase AppDatabase.

De esta forma se ha trabajado sobre el componente de detalles de un evento sobre el cual se ha a√±adido la funcionalidad de borrar el mismo. 

Por tanto, en la realizaci√≥n de este caso de uso se han creado la siguiente clase:

* La clase DeleteEventDialog

Esta disciplina ha sido realizada en conjunto por el Sr. Naranja y el Sr. Azul.

#### Integraci√≥n de CU08

La integraci√≥n de este caso de uso ha necesitado la integraci√≥n previamente de los casos de uso  CU06, por lo que se ha realizado una primitiva **Merge** para trabajar sobre el c√≥digo con este caso de uso realizado.

Posteriormente, una vez que el caso de uso est√° implementado, **se ha realizado la publicaci√≥n del c√≥digo** terminado en la rama del repositorio correspondiente lanzando una primitiva **Push.**

Esta disciplina ha sido realizada por el **Sr. Azul.**

Una vez finalizada esta fase, se **integrar√° este caso de uso en la rama Develop** con todos los cambios de la rama correspondiente mediante un Merge, publicando despu√©s los cambios correspondientes en la rama Develop mediante la primitiva Push.

## Proceso seguido del Equipo 3 (Sr. Naranja) <a name="desarrolloEquipo3"></a>

En este apartado se documentar√° todo el proceso seguido por el Equipo 3 para realizar los casos de uso, desde la implementaci√≥n hasta la integraci√≥n final. Se detalla **qu√© archivos se han modificado** concretamente y **c√≥mo se ha realizado la integraci√≥n** de estos casos de uso.

El equipo 3 ser√° el encargado de llevar a cabo los casos de uso CU09, CU10, CU11 y CU12. A continuaci√≥n se explicar√°n las tareas de implementaci√≥n e integraci√≥n que se han realizado en cada uno de ellos.

### CU09 - Consultar el tiempo meteorol√≥gico en la ubicaci√≥n actual

Este caso de uso no estructural permite al usuario consultar los detalles del tiempo asociado a la localizaci√≥n/municipio m√°s cercano.

#### Implementaci√≥n de CU09

Para realizar este caso de uso ha sido necesaria la implementaci√≥n del caso de uso CU08 - Eliminar un evento.

La implementaci√≥n de este caso de uso se ha llevado a cabo mediante la modificaci√≥n de los siguientes archivos:

* El fragmento InicioFragment

A su vez se han creado los siguientes nuevos archivos:

* Clase Weather
* Clase APIManager
* Clase APIManagerDelegate

Esta disciplina ha sido realizada en conjunto por el **Sr. Blanco** y el **Sr. Azul.**

#### Integraci√≥n de CU09

La integraci√≥n de este caso de uso ha necesitado la integraci√≥n previamente del caso de uso CU08, por lo que se ha realizado una primitiva **Merge** para trabajar sobre el c√≥digo con este caso de uso realizado.

Posteriormente, una vez que el caso de uso est√° implementado, **se ha realizado la publicaci√≥n del c√≥digo** terminado en la rama del repositorio correspondiente lanzando una primitiva **Push.**

Esta disciplina ha sido realizada por el **Sr. Blanco.**

Una vez finalizada esta fase, se **integrar√° este caso de uso en la rama Develop** con todos los cambios de la rama correspondiente mediante un Merge, publicando despu√©s los cambios correspondientes en la rama Develop mediante la primitiva Push.

### CU10 - Modificar idioma y tema a modo oscuro

Este caso de uso no estructural permite al usuario realizar una serie de modificaciones en la aplicaci√≥n para configurar esta a su gusto como cambiar el idioma, el tema a modo oscuro, etc.

#### Implementaci√≥n de CU10

Para la implementaci√≥n de este caso de uso se han modificado la mayor√≠a de actividades y fragmentos del proyecto.

Cabe mencionar la modificaci√≥n del fragmento AjustesFragment en el cual se ha a√±adido la opci√≥n de activar el modo oscuro en la aplicaci√≥n.

Finalmente todo el c√≥digo referido a las caracter√≠sticas de ambos modos (oscuro y claro) se encuentra en los dos archivos themes del layout.

Esta disciplina ha sido realizada por el **Sr. Azul.**

#### Integraci√≥n de CU10

La integraci√≥n de este caso de uso ha necesitado la integraci√≥n previamente del caso de uso CU09, por lo que se ha realizado una primitiva **Merge** para trabajar sobre el c√≥digo con este caso de uso realizado.

Posteriormente, una vez que el caso de uso est√° implementado, **se ha realizado la publicaci√≥n del c√≥digo** terminado en la rama del repositorio correspondiente lanzando una primitiva **Push.**

Esta disciplina ha sido realizada en conjunto por el **Sr. Blanco** y el **Sr. Marr√≥n.**

Una vez finalizada esta fase, **se integrar√° este caso de uso en la rama Develop** con todos los cambios de la rama correspondiente mediante un Merge, publicando despu√©s los cambios correspondientes en la rama Develop mediante la primitiva Push.

### CU11 - Consultar lista de eventos

Este caso de uso no estructural permite al usuario visualizar el listado completo de eventos de municipios y monta√±as creados por su parte.

#### Implementaci√≥n de CU11

Para realizar este caso de uso ha sido necesaria la implementaci√≥n del CU01 - Crear Evento de Municipio y el caso CU02 - Crear Evento de Monta√±a, que contiene las clases Evento y EventoDAO, utilizando tambi√©n la clase AppDatabase.

La implementaci√≥n de este caso de uso se ha completado mediante la creaci√≥n de las siguientes clases:

* Clase java PlaceholderItem
* Fragmento ConsultaEventosFragment
* Fragmento ListaEventosFragment

Esta disciplina ha sido realizada en conjunto por el **Sr. Blanco** y el **Sr. Azul.**

#### Integraci√≥n de CU11

La integraci√≥n de este caso de uso ha necesitado la integraci√≥n previamente del caso de uso CU10, por lo que se ha realizado una primitiva **Merge** para trabajar sobre el c√≥digo con este caso de uso realizado.

Posteriormente, una vez que el caso de uso est√° implementado, **se ha realizado la publicaci√≥n del c√≥digo** terminado en la rama del repositorio correspondiente lanzando una primitiva **Push.**

Esta disciplina ha sido realizada por el **Sr. Marr√≥n.**

Una vez finalizada esta fase, **se integrar√° este caso de uso en la rama Develop** con todos los cambios de la rama correspondiente mediante un Merge, publicando despu√©s los cambios correspondientes en la rama Develop mediante la primitiva Push.

### CU12 - Consultar un evento

Este caso de uso no estructural permite al usuario visualizar en detalle los datos pertinentes de un evento de municipio o monta√±a.

#### Implementaci√≥n de CU12

Para realizar este caso de uso ha sido necesaria la implementaci√≥n de los casos de uso CU01, CU02 y CU09 correspondientes con la creaci√≥n de eventos y obtenci√≥n de los datos metereol√≥gicos de una ubicaci√≥n.

La implementaci√≥n de este caso de uso se ha completado mediante la creaci√≥n de las siguientes clases:

* Interfaz fragment_detalles_evento
* Interfaz activity_detalles_localizaciones
* Fragmento DetallesEventoFragment
* Actividad DetallesEventoActivity

Esta disciplina ha sido realizada por el **Sr. Blanco.**

#### Integraci√≥n de CU12

La integraci√≥n de este caso de uso ha necesitado la integraci√≥n previamente del caso de uso CU11, por lo que se ha realizado una primitiva **Merge** para trabajar sobre el c√≥digo con este caso de uso realizado.

Posteriormente, una vez que el caso de uso est√° implementado, **se ha realizado la publicaci√≥n del c√≥digo** terminado en la rama del repositorio correspondiente lanzando una primitiva **Push.**

Esta disciplina ha sido realizada por el **Sr. Marr√≥n.**

Una vez finalizada esta fase, **se integrar√° este caso de uso en la rama Develop** con todos los cambios de la rama correspondiente mediante un Merge, publicando despu√©s los cambios correspondientes en la rama Develop mediante la primitiva Push.

## Proceso seguido del Equipo 4 (Sr. Azul) <a name="desarrolloEquipo4"></a>

En este apartado se documentar√° todo el proceso seguido por el Equipo 4 para realizar los casos de uso, desde la implementaci√≥n hasta la integraci√≥n final. Se detalla **qu√© archivos se han modificado** concretamente y **c√≥mo se ha realizado la integraci√≥n** de estos casos de uso.

El equipo 4 ser√° el encargado de llevar a cabo los casos de uso CU13, CU14, CU15 y CU16. A continuaci√≥n se explicar√°n las tareas de implementaci√≥n e integraci√≥n que se han realizado en cada uno de ellos.

### CU13 - Iniciar sesi√≥n

Este caso de uso no estructural permite al usuario iniciar sesi√≥n con las credenciales asociadas a su cuenta de usuario.

#### Implementaci√≥n de CU13

Para realizar este caso de uso ha sido necesaria la implementaci√≥n del caso de uso CU12 - Consultar un evento, el cual incluye las actividades y fragmentos DetallesEvento.

Esta disciplina ha sido realizada por el **Sr. Naranja.**

La implementaci√≥n de este caso de uso se ha completado mediante la modificaci√≥n de la siguiente clase:

* La clase MainActivity

Adem√°s, se han creado la siguiente clase:

* La actividad InicioSesion junto con su layout

#### Integraci√≥n de CU13

La integraci√≥n de este caso de uso ha necesitado la integraci√≥n previamente del caso de uso CU12, por lo que se ha realizado una primitiva **Merge** para trabajar sobre el c√≥digo con este caso de uso realizado.

Posteriormente, una vez que el caso de uso est√° implementado, **se ha realizado la publicaci√≥n del c√≥digo** terminado en la rama del repositorio correspondiente lanzando una primitiva **Push.**

Seg√∫n la planificaci√≥n de JIRA, esta disciplina la debe realizar tanto el Sr. Marr√≥n como el Sr. Naranja. Sin embargo, en la realidad s√≥lo la ha realizado el **Sr. Marr√≥n,** y la tarea de integraci√≥n del **Sr. Naranja** se ha puesto como estado a ‚ÄúHecho‚Äù.

Una vez finalizada esta fase, **se integrar√° este caso de uso en la rama Develop** con todos los cambios de la rama correspondiente mediante un Merge, publicando despu√©s los cambios correspondientes en la rama Develop mediante la primitiva Push.

### CU14 - Cerrar sesi√≥n

Este caso de uso no estructural permite al usuario cerrar sesi√≥n.

#### Implementaci√≥n de CU14

Para realizar este caso de uso ha sido necesaria la implementaci√≥n del caso de uso CU05 - A√±adir preferencias desde el men√∫ de AppBar (ajustes ‚Ä¶), el cual incluye el c√≥digo necesario para la implementaci√≥n de un apartado de Ajustes mediante la clase AjustesFragment.

Esta disciplina ha sido realizada por el **Sr. Marr√≥n.**

La implementaci√≥n de este caso de uso se ha completado mediante la modificaci√≥n de la siguiente clase:

* La clase MainActivity
* El layout main.xml correspondiente al men√∫

#### Integraci√≥n de CU14

La integraci√≥n de este caso de uso ha necesitado la integraci√≥n previamente del caso de uso CU05, por lo que se ha realizado una primitiva **Merge** para trabajar sobre el c√≥digo con este caso de uso realizado.

Posteriormente, una vez que el caso de uso est√° implementado, **se ha realizado la publicaci√≥n del c√≥digo** terminado en la rama del repositorio correspondiente lanzando una primitiva **Push.**

Seg√∫n la planificaci√≥n de JIRA, esta disciplina la debe realizar tanto el Sr. Marr√≥n como el Sr. Blanco. Sin embargo, en la realidad s√≥lo la ha realizado el  **Sr. Marr√≥n,** y la tarea de integraci√≥n del **Sr. Blanco** se ha puesto como estado a ‚ÄúHecho‚Äù.

Una vez finalizada esta fase, **se integrar√° este caso de uso en la rama Develop** con todos los cambios de la rama correspondiente mediante un Merge, publicando despu√©s los cambios correspondientes en la rama Develop mediante la primitiva Push.

### CU15 - Modificar usuario

Este caso de uso no estructural permite al usuario modificar su perfil de usuario, as√≠ como su nombre de usuario y contrase√±a.

#### Implementaci√≥n de CU15

Para realizar este caso de uso ha sido necesaria la implementaci√≥n del caso de uso CU14 - Cerrar sesi√≥n, el cual incluye el c√≥digo necesario para cerrar la sesi√≥n de usuario.

Esta disciplina ha sido realizada por el Sr. Marr√≥n y el Sr. Blanco.

Se ha modificado la clase EventoDAO, implementando la operaci√≥n de la base de datos de eliminaci√≥n de cuenta de usuario.

Adem√°s, se han creado la siguiente clase:

* El fragmento PerfilFragment y su layout

#### Integraci√≥n de CU15

La integraci√≥n de este caso de uso ha necesitado la integraci√≥n previamente del caso de uso CU14, por lo que se ha realizado una primitiva **Merge** para trabajar sobre el c√≥digo con este caso de uso realizado.

Posteriormente, una vez que el caso de uso est√° implementado, **se ha realizado la publicaci√≥n del c√≥digo** terminado en la rama del repositorio correspondiente lanzando una primitiva Push.

Esta disciplina la debe realizar el **Sr. Blanco.** 

Una vez finalizada esta fase, **se integrar√° este caso de uso en la rama Develop** con todos los cambios de la rama correspondiente mediante un Merge, publicando despu√©s los cambios correspondientes en la rama Develop mediante la primitiva Push.

### CU16 - Eliminar usuario

Este caso de uso no estructural permite al usuario modificar su perfil de usuario, as√≠ como su nombre de usuario y contrase√±a.

#### Implementaci√≥n de CU16

Para realizar este caso de uso ha sido necesaria la implementaci√≥n del caso de uso CU15, Modificar Usuario, el cual incluye la clase PerfilFragment.

Esta disciplina ha sido realizada por el **Sr. Blanco.**

Se ha modificado la clase EventoDAO, implementando la operaci√≥n de la base de datos de eliminaci√≥n de cuenta de usuario.

Adem√°s, se han creado la siguiente clase:

* El evento de di√°logo DeleteDialogFragment

#### Integraci√≥n de CU16

La integraci√≥n de este caso de uso ha necesitado la integraci√≥n previamente del caso de uso CU15, por lo que se ha realizado una primitiva **Merge** para trabajar sobre el c√≥digo con este caso de uso realizado.

Posteriormente, una vez que el caso de uso est√° implementado, **se ha realizado la publicaci√≥n del c√≥digo** terminado en la rama del repositorio correspondiente lanzando una primitiva Push.

Esta disciplina la debe realizar el **Sr. Blanco.** 

Una vez finalizada esta fase, **se integrar√° este caso de uso en la rama Develop** con todos los cambios de la rama correspondiente mediante un Merge, publicando despu√©s los cambios correspondientes en la rama Develop mediante la primitiva Push.

### An√°lisis del progreso <a name="analisisProgreso2"></a>

Informe de Seguimiento del Tiempo
<img src="https://imgur.com/SXYFi4i.png"/>

En este primer informe podemos ver el progreso que llevamos del proyecto en funci√≥n del tiempo que tenemos planeado dedicarle, dando como resultado que ya hemos hecho el **35%** de la carga del trabajo del proyecto quedando por tanto un **65% restante**.

Informe de gr√°fico de tarta en funci√≥n del estado
<img src="https://imgur.com/XB5XUe1.png"/>

El segundo informe nos indica todas las tareas que ya hemos realizado del total, d√°ndonos como que ya hemos realizado el 52% de las tareas y que quedan por hacer el 47%, en contraste con el informe anterior podemos ver que el porcentaje de tareas realizadas es mucho mayor que el de carga de trabajo, esto es porque las √∫ltimas tareas son las que m√°s tiempo consumen.

Gr√°fica de trabajo hecho
<img src="https://imgur.com/kd2CDeL.png"/>

En el tercer informe vemos una gr√°fica del trabajo realizado conforme al tiempo, en este informe podemos ver en qu√© instante del tiempo se han ido realizando las distintas tareas hasta el d√≠a de hoy.


# Dise√±o de la interfaz de usuario <a name="dise√±oInterfazUsuario"></a>

## Mapa de Navegaci√≥n: pantallas, patrones y diagrama <a name="mapaNavegacion"></a>

### Diagrama de casos de uso <a name="diagramaCasosdeUso"></a>
A continuaci√≥n se muestra el diagrama de casos de uso de la aplicaci√≥n, todos referentes a las acciones que puede realizar el usuario y el sistema.

<img src="https://i.imgur.com/sHvsqqx.png"/>

### Diagrama de navegaci√≥n <a name="diagramadeNavegacion"></a>
A continuaci√≥n se muestra un posible diagrama de navegaci√≥n que podr√≠a seguir la aplicaci√≥n:

<img src="https://imgur.com/MzHCzeg.png"/>

### Mockup <a name="Mockup"></a>
A continuaci√≥n se muestra un Mockup que contiene un conjunto de posibles pantallas del proyecto, a modo de prototipo que muestre las funcionalidades de la aplicaci√≥n:

<img src="https://imgur.com/Fulg3ve.png"/>
<img src="https://imgur.com/BxExdwr.png"/>

<p>&nbsp;</p>
Como se puede observar, para poder utilizar la aplicaci√≥n en primer lugar es necesario iniciar sesi√≥n contando con pantallas para iniciar sesi√≥n con una cuenta y otra para registrarse, pudiendo crear una cuenta nueva en caso de que esta no exista.

Una vez se ha iniciado sesi√≥n, la aplicaci√≥n consta principalmente de 4 pantallas, siendo estas las siguientes:

* Una **pantalla principal**, que muestra el tiempo que hace (temperatura, clima‚Ä¶) en la ubicaci√≥n actual del usuario, as√≠ como una lista con los eventos que ha creado, a trav√©s de la cual se pueden consultar los detalles (tiempo, entre otros) de este.

* Una pantalla destinada al **filtrado de eventos**, pudiendo buscar entre los distintos eventos creados por el usuario a trav√©s de una serie de filtros, como el tiempo actual que hace, lugar en el que se desarrolla el evento, etc.

* Una pantalla con el **perfil del usuario**, que muestra todos sus datos, pudiendo consultar o modificar estos, as√≠ como incluso borrar el usuario.

* Una pantalla de **ajustes**, que contiene los principales ajustes que se pueden aplicar a la app, como el tema claro/oscuro, notificaciones, etc.

Cabe destacar que tanto en la lista de todos los eventos ubicada en la pantalla principal como en las listas proporcionadas por la pantalla de filtrado de eventos, se pueden acceder a los datos de un evento tocando sobre estos, que mostrar√° una pantalla desde la que se pueden consultar sus datos (lugar, temperatura, clima, fecha, etc..) o incluso modificar algunos de ellos, pudiendo tambi√©n borrar dicho evento de la app.

As√≠ mismo, posee un panel lateral desplegable en la pantalla principal desde el que se pueden acceder a las principales funcionales de la aplicaci√≥n, siendo estas:

* **Inicio**: Un acceso a la propia pantalla principal.
* **Eventos**: Un acceso a la lista de eventos que ha creado el usuario para poder filtrarlos.
* **Perfil**: Un acceso al perfil del usuario.
* **Ajustes**: Un acceso a la pantalla con los principales ajustes de la aplicaci√≥n.

### Grafo de navegaci√≥n <a name="grafodeNavegacion"></a>

<img src="https://imgur.com/9r1yf8r.png"/>

### Patrones de navegaci√≥n aplicados <a name="patronesNavegacion"></a>  
   
En este apartado se muestran todos los patrones de navegaci√≥n que se han utilizado para la realizaci√≥n de la aplicaci√≥n, siendo estos los siguientes:

* Patr√≥n de lista y detalle.
* Patr√≥n de caj√≥n de navegaci√≥n.
* Patr√≥n de botones y objetivos sencillos.

A continuaci√≥n se detallar√°n cada uno de los patrones implementados.

üîπ Patr√≥n de lista y detalle

Para desplazarse por la aplicaci√≥n se ha utilizado un patr√≥n de lista y detalle referente a la pantalla de inicio, que mostrar√° los elementos de m√°s inter√©s para el usuario, en este caso una lista con todos los eventos que ha creado.

De la misma forma, en la pantalla de lista de eventos tambi√©n se ha aplicado este patr√≥n para buscar una lista de eventos concretos a trav√©s de la pantalla de filtrado de eventos.

As√≠ mismo, a trav√©s de estas listas, se puede acceder a una pantalla que permite consultar los detalles de un evento concreto tocando sobre dicho evento de la lista, que llevar√° a una pantalla que muestra sus datos.

<img src="https://i.imgur.com/Q3Fyb60.png"/>
<p>&nbsp;</p>

üîπ Patr√≥n de caj√≥n de navegaci√≥n

En lo referente a cada una de las funcionalidades, se utilizar√° un **patr√≥n de caj√≥n de navegaci√≥n**, creando un men√∫ lateral desplegable desde el que se puede navegar entre funcionalidad y funcionalidad, pudiendo cambiar r√°pidamente de pantalla a trav√©s de dicho men√∫ lateral.

üîπ Patr√≥n de botones y objetos sencillos

Finalmente, se ha aplicado el patr√≥n de botones y objetivos sencillos mostrando mediante botones con iconos intuitivos en ciertas funcionalidades, de manera que permitan a los usuarios acceder m√°s f√°cilmente a dichas funcionalidades.

<img src="https://i.imgur.com/jPea9kb.png"/>

# Dise√±o arquitect√≥nico <a name="dise√±oArquitectonico"></a>

## Diagrama e interacci√≥n de componentes <a name="diagramaComponentes"></a>

A continuaci√≥n se muestra un diagrama con todos los principales componentes que conforman el sistema:

<img src="https://i.imgur.com/0RFY7NO.jpg"/>

Estos componentes pueden clasificarse en 3 tipos:

* **Componentes de interfaz de usuario**: Son aquellos que interact√∫an directamente con el usuario, ofreci√©ndoles las diversas funcionalidades (crear un evento, consultar la lista de eventos, modificar estos, etc).

* **Repositorios**: Consisten en los componentes que hacen la funci√≥n de repositorios, utilizados en el patr√≥n Repository para obtener los datos de fuentes externas y son utilizados en otros componentes a trav√©s de los viewmodel. Se trata de los componentes EventRepository, UserRepository y LocationRepository.

* **Componentes que enlazan fuentes externas**: Se trata de los componentes que permiten acceder a  datos de fuentes externas, como la base de datos de Room (AppDatabase), los ficheros Json con municipios y monta√±as (JsonSingleton) o la api que obtiene la informaci√≥n del clima (ApiManager).

As√≠ mismo, entre los componentes presentados en el diagrama anterior existen las siguientes interacciones:

* El **usuario interact√∫a con la aplicaci√≥n** utilizando la interfaz de usuario (UI) definida por los componentes Android y sus layouts, agrupados en el paquete ‚ÄúInterfaz de usuario‚Äù. Esto se representa con la relaci√≥n entre el actor usuario y la interfaz ‚Äúoperaciones IU‚Äù.

* El componente **JsonSingleton** ofrece la interfaz ‚ÄúobtenerMunicipiosMonta√±as‚Äù, requerida por el componente CrearEvento.

* Los **componentes de la interfaz del usuario acceden**, a trav√©s de los distintos viewmodels, **a los diferentes repositorios** que existen dentro de AppContainer (UserRepository, LocationRepository y EventRepository) para almacenar y obtener datos de fuentes externas. Por ello, cada componente del patr√≥n repository ofrece interfaces ‚Äúviewmodel‚Äù que son utilizadas por los componentes de la interfaz de usuario.

* La agrupaci√≥n de componentes de tipo **Repository** (UserRepository, LocationRepository y EventRepository) hacen uso de las operaciones de la Room, a trav√©s de las interfaces DAO ofrecidas por el componente AppDataBase, para realizar operaciones en la base de datos.

* El componente **APIManager** proporciona las peticiones pertinentes a la API OpenWeather mediante la interfaz ‚ÄúobtenerTiempo‚Äù,  requerida por los repositorios EventRepository, donde cada evento tiene asociado el tiempo meteorol√≥gico seg√∫n la ubicaci√≥n; LocationRepository, donde cada localizaci√≥n (municipio) tiene asignado unas condiciones meteorol√≥gicas.

## Patrones arquitect√≥nicos <a name="patronesArquitectonicos"></a>

#### Patr√≥n Repository
Se ha optado por unificar todas las fuentes de datos creando una sola instancia que permita acceder a todos los datos.

<img src="https://imgur.com/XH3atJm.png"/>

Para ello, se han creado una serie de Repositorios asociados a los objetos del modelo de datos que son almacenados en la base de datos y accedidos desde la app. 

La clase **EventRepository** permitir√° acceder tanto a los datos procedentes de la api (APIManager) como a la informaci√≥n que se encuentra en la base de datos de Room (AppDatabase).  La clase de repositorio a√≠sla las fuentes de datos del resto de la app, una capa intermedia entre la capa de dominio y la capa de acceso de datos. Usar una clase de repositorio garantiza que este c√≥digo sea independiente de la clase ViewModel y es una pr√°ctica recomendada para la separaci√≥n del c√≥digo y su arquitectura.

Por dem√°s,  un evento tiene asociado datos relacionados con el tiempo meteorol√≥gico proporcionados por la API. Si el usuario desea consultar los detalles de un evento consultado recientemente, **EventRepository** se encarga de cargar los datos de la Room (o cach√©). En el caso de consultar los detalles de un evento en un periodo de tiempo superior al umbral establecido, entonces se realiza una petici√≥n a la API OpenWeather y se actualiza la cach√© con los datos retornados de la API.

As√≠ mismo, tambi√©n se ha creado una clase **LocationRepository** la cual permitir√° acceder a los datos de la API (APIManager) como fuente de datos externa y al modelo de Room (LocationDAO), en el que se manejan las localizaciones alojadas (municipios). De esta manera, el repositorio har√° de capa intermedia entre la app (los ViewModels) y estas fuentes de datos.

Del mismo modo, se ha creado una clase **UserRepository** la cual permitir√° acceder a los usuarios de Room. 

En el proceso de implementaci√≥n de este patr√≥n, se consideraron una serie de cambios relativos al modelo de datos de la aplicaci√≥n propuesto en una versi√≥n temprana, con el objetivo de implementar la memoria cach√©.
* Para comprobar si se requiere una actualizaci√≥n del tiempo meteorol√≥gico de un evento, es conveniente almacenar la informaci√≥n del tiempo dentro del propio objeto Evento. Por ello, se ha modificado la entidad Evento incluyendo los atributos relativos al tiempo meteorol√≥gico, que anteriormente se encontraba en la clase Weather. 
* Por ende, al consultar los detalles de un evento, se comprueba si es necesario recuperar los datos asociados al tiempo de dicho evento desde la cach√© o actualizar la base de datos con los datos devueltos de la API.
* Creaci√≥n de una clase Location, que almacena toda la informaci√≥n (tiempo) relativa a una ubicaci√≥n concreta. Esta clase sustituye a la anterior Weather, que se introducir√° dentro de la clase Evento.
* Creaci√≥n de una interfaz dao LocationDAO relativa a la gesti√≥n de objetos Location en la base de datos. 

Tras todas estas modificaciones, el modelo de datos resultante utilizado en la base de datos ser√≠a el siguiente:

<img src="https://imgur.com/uMSEZGA.png"/>

**Ventajas de usar un repositorio**
Un m√≥dulo de repositorio controla operaciones de datos y te permite usar varios backends. En una app real t√≠pica, el repositorio implementa la l√≥gica para decidir si debe recuperar datos de una red o usar resultados almacenados en cach√© de una base de datos local. 

Con un repositorio, puedes intercambiar los detalles de la implementaci√≥n, como la migraci√≥n a una biblioteca de persistencia diferente, sin afectar el c√≥digo de llamada, como los modelos de vista. Esto tambi√©n permite que tu c√≥digo sea modular y se pueda probar. Puedes simular con facilidad el repositorio y probar el resto del c√≥digo.

Un repositorio debe funcionar como una √∫nica fuente de verdad para una parte espec√≠fica de los datos de tu app. Cuando se trabaja con varias fuentes de datos, como un recurso conectado en red y una cach√© sin conexi√≥n, el repositorio garantiza que los datos de la app sean lo m√°s precisos y actualizados, lo que proporcionar√° la mejor experiencia posible incluso cuando la app est√© sin conexi√≥n.

#### Patr√≥n Model - View - ViewModel (MVVM)
Con el objetivo de incrementar la seguridad de la aplicaci√≥n y gestionar los datos de forma m√°s r√°pida y eficiente se ha implementado el patr√≥n Model - View - ViewModel (MVVM).
 
Se han implementado los siguientes viewmodels:

* ListaEventosViewModel: Viewmodel que permite gestionar los datos de la lista de eventos del fragmento ListaEventosFragment.
* DetallesEventoViewModel: Viewmodel que gestiona los datos al mostrar los detalles de un evento en el fragmento DetallesEventoFragment.
* TiempoActualViewModel: Viewmodel que gestiona el tiempo actual mostrado en el fragmento de inicio InicioFragment.
* DetallesLocalizacionViewModel: Viewmodel que gestiona el tiempo de una ubicaci√≥n concreta en la actividad DetalleLocalizacionActivity.
* IniciarSesionViewModel: Viewmodel que gestiona el inicio de sesi√≥n en la actividad InicioSesion.
* RegistrarseViewModel: Viewmodel que gestiona la pantalla de registro de usuario en la actividad Registrarse.
* PerfilViewModel: Viewmodel que gestiona la consulta y modificaci√≥n del usuario en el fragmento PerfilFragment.
* BorrarPerfilViewModel: Viewmodel que permite eliminar el usuario en el fragmento DeleteDialogFragment.
* ModificarEventoViewModel: Viewmodel que gestiona los detalles relativos a la pantalla de modificar un evento del fragmento ModificarEventoFragment.
* mainUsuarioViewModel: Viewmodel que permite comprobar y cerrar la sesi√≥n del usuario en MainActivity.

Cabe mencionar que los ViewModels tienen una dependencia relacionada con un Repository espec√≠fico. Para solventar la escalabilidad de c√≥digo de nuestra aplicaci√≥n respecto la adicci√≥n de nuevas dependencias a los ViewModel, se ha implementado el patr√≥n de dise√±o Factory para crear instancias ViewModel de manera sencilla. Adem√°s, ante el crecimiento de dependencias de la app como los repositorios, AppDataBase y factories, entre otros; se han agrupado como atributos en una clase Singleton llamada AppContainer, la cual es instanciada por primera vez en una nueva clase llamada MyApplication que extiende Application. Para iniciar esta clase, se ha modificado el AndroidManifest incrustando un atributo android:name=‚Äù.MyApplication‚Äù.

El recurso de ViewModel destaca como el componente que se encargar√° de servir como puente entre la interacci√≥n de la Vista (View) y el Modelo (Model).

Entre sus ventajas encontramos:

* Su capacidad para separar de forma limpia la presentaci√≥n de una aplicaci√≥n determinada y la l√≥gica del negocio de su interfaz de usuario. Lo que contribuye a abordar m√∫ltiples tipos de inconvenientes de desarrollo, prueba, mantenimiento y evoluci√≥n del sistema.
* Permite que los desarrolladores creen pruebas unitarias para el Model View y el modelo, sin que sea necesario el uso de la vista.
* Los encargados del dise√±o y desarrollo de aplicaciones pueden ser capaces de trabajar de manera simult√°nea e independiente, cada uno en sus componentes durante los procesos de la app.
* ViewModel permite la conservaci√≥n tanto en el estado que contiene un ViewModel como en las operaciones que est√© activa. Este almacenamiento en cach√© significa que no necesitas recuperar datos mediante cambios de configuraci√≥n comunes, como una rotaci√≥n de pantalla.
* SaveStateHandle te permite conservar datos no solo a trav√©s de cambios de configuraci√≥n, sino tambi√©n durante la recreaci√≥n de procesos. Es decir, te permite mantener el estado de la IU intacto, incluso cuando el usuario cierra la app y la abre m√°s adelante.
* Reducci√≥n de la complejidad: al separar la l√≥gica de presentaci√≥n de la l√≥gica de negocio en componentes distintos, el c√≥digo de la aplicaci√≥n se vuelve m√°s f√°cil de entender y mantener.
* Mayor reutilizaci√≥n de c√≥digo: debido a que la l√≥gica de presentaci√≥n y la l√≥gica de negocio est√°n separadas, se pueden reutilizar f√°cilmente en diferentes vistas y contextos.
* Mejora del rendimiento: el patr√≥n MVVM permite que la vista se actualice autom√°ticamente cuando los datos cambien en el modelo, lo que reduce la cantidad de c√≥digo que se debe escribir y mejora el rendimiento de la aplicaci√≥n.


# Gesti√≥n del entorno <a name="gestionEntorno"></a>

En este apartado se abordar√°n todos los detalles sobre el entorno en el que se ha llevado a cabo el proyecto, comprendiendo desde las caracter√≠sticas que poseen hasta los pasos que se han seguido para configurar dichos entornos.

## Gesti√≥n de la configuraci√≥n <a name="gestionConfiguracion"></a>

### Entorno utilizado <a name="entornoUtilizado"></a>

En concreto, para la realizaci√≥n de este proceso se han utilizado 2 herramientas, una para la **codificar la aplicaci√≥n** (y posteriormente ejecutar el c√≥digo implementado) y otra para **almacenar el c√≥digo creado por los integrantes del equipo**, pudiendo compartirse este y permitiendo integrarlo todo en un repositorio Git. A continuaci√≥n se explicar√°n cada una de estas herramientas.

#### Herramienta de implementaci√≥n: Android Studio <a name="androidStudio"></a>

Android Studio es una herramienta de codificaci√≥n y ejecuci√≥n de programas y aplicaciones para dispositivos Android basada en IntelliJ IDEA.

Este consiste en un software que permite programar en lenguajes como Java o Kotlin aplicaciones para posteriormente poder ser ejecutada en dispositivos con versiones de Android superiores a 3.0.

Adem√°s de ofrecer las mismas herramientas para desarrolladores de IntelliJ, Android Studio ofrece incluso m√°s funciones, entre otras:

* Un sistema de compilaci√≥n flexible basado en Gradle
* Un emulador r√°pido y cargado de funciones
* Un entorno unificado donde puedes desarrollar para todos los dispositivos Android
* Aplicaci√≥n de cambios para insertar cambios de c√≥digo y recursos a la app en ejecuci√≥n sin reiniciarla
* Integraci√≥n con GitHub y plantillas de c√≥digo para ayudarte a compilar funciones de apps comunes y tambi√©n importar c√≥digo de muestra
* Variedad de marcos de trabajo y herramientas de prueba
* Herramientas de Lint para identificar problemas de rendimiento, usabilidad y compatibilidad de versiones, entre otros
* Compatibilidad con C++ y NDK
* Compatibilidad integrada con [Google Cloud Platform](https://cloud.google.com/tools/android-studio/docs/?hl=es-419), que facilita la integraci√≥n con Google Cloud Messaging y App Engine

As√≠ mismo, ofrece la funcionalidad de acceso y manejo de bases de datos gracias al soporte con Room, as√≠ como la posibilidad de ejecutar un programa en un dispositivo con AVD que va desde tel√©fonos inteligentes de varios modelos y marcas, hasta tablets, televisiones y ordenadores, entre otros.

#### Estructura de un proyecto en Android Studio <a name="estructuraProyecto"></a>

En concreto, un proyecto en android studio se compone de las siguientes partes:

* **manifests**: consiste en un fichero llamado AndroidManifest.xml que contiene informaci√≥n adicional de la aplicaci√≥n como el nombre de la aplicaci√≥n, el icono que utilizar√° el launcher, qu√© actividad es la principal, los par√°metros del intent (intent-filters) por los que se puede filtrar la aplicaci√≥n, entre otros.
* **java**: contiene los archivos de c√≥digo fuente Java, incluido el c√≥digo de prueba de JUnit, este suele constar en clases y enumeraciones en Java, as√≠ como las diferentes actividades y fragmentos de los que se componen las interfaces de usuario.
* **res**: contiene todos los recursos sin c√≥digo, como dise√±os XML, strings de IU e im√°genes de mapa de bits, suele ofrecer todas las im√°genes y predise√±os que utilizar√°n los proyectos como recursos.

![](https://i.imgur.com/U2pox55.png)

A continuaci√≥n se muestran las diferentes vistas que componen la interfaz del programa.

#### Componentes de la interfaz de Android Studio <a name="componentesInterfaz"></a>

**Android Studio** ofrece una serie de vistas y componentes en su interfaz que ofrecen informaci√≥n sobre un proyecto. Dentro de una ventana, se encuentran los siguientes componentes:

![](https://i.imgur.com/LX57g2i.png)

* La **barra de herramientas** te permite realizar una gran variedad de acciones, como ejecutar tu app e iniciar las herramientas de Android.
* La **barra de navegaci√≥n** te ayuda a explorar tu proyecto y abrir archivos para editar. Proporciona una vista m√°s compacta de la estructura visible en la ventana Project.
* La **ventana del editor** es el √°rea en la que puedes crear y modificar c√≥digo. Seg√∫n el tipo de actividad actual, el editor puede cambiar. Por ejemplo, cuando ves un archivo de dise√±o, el editor muestra el Editor de dise√±o.
* La **barra de la ventana de herramientas** se encuentra afuera de la ventana del IDE y contiene los botones que te permiten expandir o contraer ventanas de herramientas individuales.
* Las **ventanas de herramientas** te brindan acceso a tareas espec√≠ficas, como la administraci√≥n de proyectos, la b√∫squeda, el control de versiones, entre otras. Puedes expandirlas y contraerlas.
* En la **barra de estado**, se muestra el estado de tu proyecto y el IDE, adem√°s de advertencias o mensajes.

#### Funcionamiento de una App en Android Studio <a name="funcionamientoApp"></a>

Este software utiliza las llamadas actividades (Activity) para ejecutarlas como pantallas individuales. Estas son archivos en c√≥digo Java que indican el funcionamiento de todos los eventos que suceden y las acciones que se realizan dentro de una pantalla de la aplicaci√≥n. 

Estas tienen el dise√±o indicado en el layout de dicha actividad, que consiste en un fichero xml que se encuentra en la carpeta res > layout, y que codifica c√≥mo se mostrar√° la pantalla y los elementos que compondr√°n la interfaz.

Adicionalmente existen los fragmentos (Fragment), que consisten en ficheros java que permiten contener el funcionamiento de una actividad en una pantalla, permitiendo existir varios fragmentos en una misma Activity. Estos se pueden intercambiar por otros en cualquier momento, permitiendo a la aplicaci√≥n un comportamiento m√°s din√°mico.

Una actividad se puede comunicar con otra a trav√©s de los llamados Intent, que son clases que permiten a una actividad llamar a otra. Cada instancia de la clase ‚Äúintent contiene la clase de la actividad que llama a la siguiente, la clase de la actividad llamada, y otros datos adicionales como informaci√≥n que se quiere pasar en la llamada.

Una aplicaci√≥n puede obtener los recursos como im√°genes o iconos a trav√©s de la carpeta drawable, dentro de res. Esta contiene los recursos que se utilizan referente a los iconos, im√°genes predeterminadas, etc.

Finalmente, cabe destacar el fichero strings.xml, que contiene todas las cadenas que se mostrar√°n en la aplicaci√≥n de forma din√°mica. Pudiendo cambiarse sin tener que acceder al c√≥digo. Esto dota de independencia al sistema de asignaci√≥n de cadenas ya que no necesitan modificar directamente el c√≥digo para cambiarse, teniendo que modificar √∫nicamente el fichero. Para acceder al archivo strings.xml debe escribirse la cadena @string/ seguido del identificador que se haya puesto en el campo name de la etiqueta <string> que identifica a la cadena que se quiere insertar.

En el siguiente apartado se explicar√° el funcionamiento del componente Gradle.

#### Compilaci√≥n en Gradle <a name="compilacionGradle"></a>

Android Studio usa Gradle como base del sistema de compilaci√≥n, y el [complemento de Android para Gradle](https://developer.android.com/studio/releases/gradle-plugin?hl=es-419) proporciona capacidades espec√≠ficas de Android. Este sistema de compilaci√≥n se ejecuta en una herramienta integrada desde el men√∫ de Android Studio, y lo hace independientemente de la l√≠nea de comandos. El prop√≥sito de las funciones del sistema de compilaci√≥n es el siguiente:

* Personalizar, configurar y extender el proceso de compilaci√≥n
* Crear varios APK para tu app; diferentes funciones usan el mismo proyecto y los mismos m√≥dulos
* Volver a usar c√≥digos y recursos en conjuntos de archivos fuente

Gracias a la flexibilidad de Gradle, se puede lograr sin modificar los archivos fuente de la aplicaci√≥n. Los archivos de compilaci√≥n de Android Studio se denominan build.gradle. Son archivos de texto sin formato que usan la sintaxis [Groovy](http://groovy-lang.org/) a fin de configurar la compilaci√≥n con elementos que proporciona el complemento de Android para Gradle. 

Cada proyecto tiene un archivo de compilaci√≥n de nivel superior para todo el proyecto y archivos de compilaci√≥n de nivel de m√≥dulo independientes para cada m√≥dulo. Cuando se importa un proyecto existente, Android Studio genera autom√°ticamente los archivos de compilaci√≥n necesarios.

#### Integraci√≥n de Jira en Android Studio <a name="integracionJira"></a>
Con el objetivo de poder informar sobre las tareas de implementaci√≥n o integraci√≥n que se realizan en el proyecto se ha optado por la sincronizaci√≥n del programa de **Android Studio** con el software **Jira**, de manera que a lo largo de la realizaci√≥n del proyecto se puedan actualizar el estado de las tareas a trav√©s del propio Android Studio.
 
Para llevar a cabo la integraci√≥n de Jira con el software de Android Studio se pueden seguir dos caminos:
* Utilizando la herramienta de contexto que viene predefinida dentro de Android Studio.
* Utilizando un plugin que nos permite interaccionar con Jira a trav√©s de Android Studio.

A continuaci√≥n se explica cada uno de estas opciones.

#### Integraci√≥n de Jira en Android Studio a trav√©s de la herramienta de contexto <a name="integracionJiraHerramienta"></a>
Lo primero que debemos hacer es configurar el servidor de Jira, para ello deberemos irnos a Tools > Tasks & Contexts > Configure Servers‚Ä¶, que se encuentra en la parte superior izquierda del programa.

<img src="https://i.imgur.com/7eqmC0F.png"/>

Una vez accedido a este apartado deber√≠a de aparecer una ventana de di√°logo como la siguiente.

<img src="https://i.imgur.com/hCr3Y9N.png"/>

Dentro de esta ventana deberemos seleccionar el bot√≥n de ‚Äú+‚Äù y seleccionar el tipo de Server al cual queremos acceder, en nuestro caso ser√° el Server de Jira.

<img src="https://i.imgur.com/Y1PyTWq.png"/>

Una vez seleccionado el servidor aparecer√°n los registros que deberemos de rellenar para acceder a este.

<img src="https://i.imgur.com/03vfufz.png"/>

Estos atributos son los siguientes:
* **Server URL**: La url en la que se encuentra el servidor.
* **Username**: El nombre de usuario de la conexi√≥n que se va a realizar.
* **Password**: La contrase√±a asociada a dicho nombre de usuario.
* **Search**: Corresponde a una serie de asignaciones de valores a ciertos par√°metros configuraci√≥n

Esta debe rellenarse con los datos de la conexi√≥n a nuestro proyecto de Jira en cuesti√≥n, siendo estos la url del servidor de Jira (http://jira.spilab.es:8080/), el nombre de uno de los usuarios del proyecto y su contrase√±a, como se muestra a continuaci√≥n:

<img src="https://i.imgur.com/yI2rKD4.png"/>

Una vez dado al bot√≥n ‚Äò**ok**‚Äô, y si los datos se han puesto de forma correcta se acceder√° a servidor de Jira.

Ahora podremos empezar a realizar tareas, para ello deberemos de acceder a la lista de tareas a trav√©s de Tools > Tasks & Contexts > Open Task‚Ä¶

<img src="https://i.imgur.com/TJmQFz0.png"/>

Una vez hecho esto podremos seleccionar la tarea de Jira que queremos empezar a desarrollar busc√°ndola dentro de la lista que nos aparece.

<img src="https://i.imgur.com/Xj1PuEE.png"/>

Al seleccionarla nos aparecer√° una ventana similar a la siguiente, en la cual deberemos de elegir en qu√© rama vamos a realizar dicha tarea.

<img src="https://i.imgur.com/8N8a8C7.png"/>

Una vez acabemos de trabajar, tan solo tendremos que realizar un **commit** en el cual indicamos el id de la tarea, su t√≠tulo y el autor que la realiza. Adem√°s de esto se pueden a√±adir m√°s cosas como un comentario o el tiempo dedicado a dicha tarea utilizando **Smart commits**, pero no es necesario.

#### Integraci√≥n de Jira en Android Studio a trav√©s de un plugin <a name="integracionJiraPlugin"></a>
Esta opci√≥n contempla el uso de un plugin de Android studio que permite gestionar las tareas de un proyecto de Jira, de manera que se podr√° actualizar el estado de estas y asociarlas a ramas  de git concretas.

Por ello, se determinar√° que cada tarea de implementaci√≥n estar√° asociada a una rama con el c√≥digo de un caso de uso.

Para descargar el plugin, se debe acceder a la secci√≥n de plugins. Esto se puede realizar haciendo clic en la opci√≥n **Settings** de la pesta√±a **Files** y buscando en este dicha secci√≥n plugins.

<img src="https://i.imgur.com/TgFE5s2.png"/>

Esto abrir√° una ventana con las opciones de configuraci√≥n de Android Studio. 

<img src="https://i.imgur.com/I7i3DbC.png"/>

Tambi√©n es posible acceder a esta ventana a trav√©s del icono con forma de rueda situado en la parte superior derecha de Android Studio, pulsando posteriormente en la opci√≥n **plugins**.

<img src="https://i.imgur.com/cuz6tV3.png"/>

La ventana de plugins posee 2 pesta√±as, una para buscar un plugin dentro de todos aquellos que est√°n instalados y otra para buscar todos los plugins y poder instalar nuevos.

En la pesta√±a de instalaci√≥n de nuevos plugins (**Marketplace**) se debe buscar el plugin llamado **Jira Software**, haciendo clic en el bot√≥n **Install** de este y comenzando su instalaci√≥n.

Una vez instalado, nos aparecer√° en la parte inferior, en la cual si presionamos el bot√≥n de configuraci√≥n nos aparecer√° una ventana para conectarnos al servidor de Jira, la cual deberemos rellenar con los siguientes datos:
* **Server URL**: La url en la que se encuentra el servidor.
* **Username**: El nombre de usuario de la conexi√≥n que se va a realizar.
* **Password**: La contrase√±a asociada a dicho nombre de usuario.

<img src="https://i.imgur.com/pyzTJep.png"/>
Con esto ya podemos trabajar con Jira seleccionando la tarea que queramos realizar y mediante el bot√≥n de <strong>transit</strong>, seleccionando la tarea como en progreso:

<img src="https://i.imgur.com/wAvATbE.png"/>

Este plugin adem√°s nos da todas las opciones que podemos realizar a trav√©s de la web dentro de Android Studio, lo que nos permite prescindir del uso del navegador.

#### Ramas utilizadas en el proyecto <a name="ramas"></a>

En concreto, en este proyecto se utilizar√° una rama master que contendr√° el c√≥digo final de la aplicaci√≥n, adem√°s de una rama develop. A partir de la develop, se crean las 16 ramas correspondientes a los 16 casos de uso.

**Importante**: durante el desarrollo de la pr√°ctica de GPS, inicialmente se crearon las ramas referentes a los primeros 4 casos de uso. Seguidamente se implementaron los 4 casos de usos con sus commits (ligados a las tareas de Jira) y se integraron en la rama develop. En este instante, nos percatamos de que se nos hab√≠a olvidado crear el resto de ramas (cu05-cu16), de manera que estas ramas se crearon a partir de la integracion de los primeros casos de uso en la rama develop.

Inicialmente, la estructura de estas ramas era la siguiente:

* master
  * develop
    * cu01. (Equipo 1)
    * cu02
    * cu03
    * cu04
    * cu05. (Equipo 2)
    * cu06
    * cu07
    * cu08
    * cu09. (Equipo 3)
    * cu10
    * cu11
    * cu12
    * cu13. (Equipo 4)
    * cu14
    * cu15
    * cu16

## Integraci√≥n continua <a name="integracionContinua"></a>

La integraci√≥n continua en el desarrollo del proyecto es el conjunto de pr√°cticas que consisten en hacer integraciones autom√°ticas de compilaci√≥n y ejecuci√≥n de test, para detectar fallos lo antes posible. De acuerdo a las tareas de integraci√≥n definidas en JIRA, se usa la tecnolog√≠a GIT sobre la plataforma GitHub para completar la integraci√≥n continua entre las ramas de los casos de uso CU01-CU16 con la rama develop, y entre la rama develop con la rama master.

La integraci√≥n continua es una pr√°ctica moderna que facilita el trabajo a los desarrolladores sobre el c√≥digo de un mismo proyecto. Algunas ventajas que presenta son las siguientes:

* Los desarrolladores pueden detectar y solucionar problemas de integraci√≥n de forma continua, evitando el caos de √∫ltima hora cuando se acercan las fechas de entrega.
* Disponibilidad constante de una versi√≥n para pruebas, demos o lanzamientos anticipados.
* Ejecuci√≥n inmediata de las pruebas unitarias.
* Monitorizaci√≥n continua de las m√©tricas de calidad del proyecto.

Esta disciplina consistir√° en 2 tareas:

* Integraci√≥n de cada subsistema o ‚ÄúIntegrate each subsystem‚Äù
* Integraci√≥n del sistema ‚ÄúIntegrate the system‚Äù

## Definici√≥n de disciplinas

En este apartado se explicar√° el proceso que seguir√° en cada disciplina relativa al desarrollo de la aplicaci√≥n, siendo estas **Implementaci√≥n** e **Integraci√≥n y Testeo.**

### Implementaci√≥n

Esta disciplina se divide en 2 tareas:

* ‚ÄúImplement components‚Äù
* ‚ÄúTest components‚Äù

Este proceso consistir√° √∫nicamente en la disciplina de <strong>‚ÄúImplement components‚Äù</strong>
Esta corresponde a la implementaci√≥n del caso de uso correspondiente utilizando Android Studio a quien tenga asignada dicha implementaci√≥n seg√∫n la planificaci√≥n del Jira. 

Para ello, el rol asignado debe marcar en Jira la tarea correspondiente del estado **TO-DO** al estado **In Progress.** El c√≥digo debe contener tanto las pantallas (Activitys y Fragments) que muestran el c√≥digo, como los componentes de la l√≥gica de negocio (clases), as√≠ como las posibles interfaces DAO que deban intervenir.

Todo el c√≥digo deber√° funcionar correctamente y contener toda la funcionalidad completa de ese caso de uso.

Una vez finalizada la implementaci√≥n del c√≥digo en Android Studio, se deber√° marcar el estado de la tarea correspondiente a **DONE.** Confirman los cambios realizados en este desde el inicio de la implementaci√≥n mediante el lanzamiento de un commit, que guardar√° los cambios realizados en el repositorio local.

Este commit se deber√° enlazar con la tarea correspondiente en el jira, guardando los cambios realizados y relacion√°ndolos con esta.

### Integraci√≥n y Testeo

#### Integraci√≥n de cada subsistema

La tarea **Integrate each subsystem** consistir√° en recuperar el c√≥digo depositado en el repositorio que est√° ubicado en la rama Develop a la rama correspondiente del caso de uso, permitiendo mediante la realizaci√≥n de un **Pull** trabajar sobre los cambios ya realizados en la rama Develop.

Este proceso tambi√©n debe actualizar la tarea del Jira correspondiente marcando su estado seg√∫n si es **TO-DO** (por realizar), **In Progress** (realiz√°ndose) o **DONE** (realizada).

Una vez finalizada la √∫ltima tarea de implementaci√≥n de un caso de uso y subido con un push a la rama remota ‚Äúorigin/CUxx‚Äù, siendo ‚Äòxx‚Äô el n√∫mero del caso de uso, se procede a integrar dicho caso de uso con el resto del proyecto que se encuentra en la rama remota ‚Äúorigin/develop‚Äù. 

En primer lugar, se debe realizar un merge del estilo <origin/develop into ‚ÄúCUxx‚Äù> y resolver los conflictos que aparezcan. De esta forma, se pretende unificar el caso de uso implementado con el nuevo c√≥digo subido por otro equipo a la rama remota ‚Äúorigin/develop‚Äù.

En este instante, se dispone del c√≥digo de los subsistemas integrados en el √∫ltimo caso de uso implementado junto con el commit resultante del merge. Estas tareas de integraci√≥n no contienen un commit adicional, por tanto, desde Android Studio se modifica el estado de la tarea de integraci√≥n de subsistemas a ‚ÄòHecho‚Äô y el autor de la tarea coincide con el usuario logueado en el servidor de JIRA en Android Studio.

#### Integraci√≥n del sistema

Por otra parte, la tarea **‚ÄúIntegrate the system‚Äù** consistir√° subir en el repositorio remoto compartido por todos los integrantes el c√≥digo del caso de uso ya completamente implementado mediante la realizaci√≥n de un **Push,** que lo publicar√° en la rama del repositorio correspondiente.

Una vez hecho esto en todas las ramas, se deben integrar todos los casos de uso de la ramas correspondientes en la rama Develop mediante la realizaci√≥n de un merge, que unificar√° todos los casos de uso realizados en la rama Develop, que posteriormente subir√° todo el c√≥digo integrado a la rama master.

Cabe destacar que tambi√©n se debe relacionar este proceso con la tarea correspondiente en el Jira, modificando su estado como **TO-DO** (por realizar), **In Progress** (realiz√°ndose) o **DONE** (realizada).

Una vez finalizada la integraci√≥n de cada subsistema, se procede a cometer la siguiente tarea de integraci√≥n desbloqueada llamada integraci√≥n del sistema. Primero, se hace un checkout de la rama ‚Äúdevelop‚Äù para tenerla en local. En ella, se procede a hacer un nuevo merge del estilo  <‚ÄúCUxx‚Äù into ‚Äúdevelop‚Äù> para mantener en la rama local ‚Äúdevelop‚Äù la integraci√≥n del sistema, exenta de errores. Por √∫ltimo, queda hacer un push de la rama local ‚Äúdevelop‚Äù en la remota ‚Äúorigin/develop‚Äù para finalizar la tarea de integraci√≥n de sistema.

En este instante, si se comete una nueva tarea de integraci√≥n de cada subsistema de otro caso de uso, el miembro del equipo responsable de dicho caso de uso tendr√° que integrar su subsistema al resto de subsistemas, incluido el nuestro.

Por √∫ltimo, cuando todas las ramas de los 16 casos de uso se encuentren implementadas e integradas en la rama remota ‚Äúdevelop‚Äù, s√≥lo queda integrar la rama ‚Äúdevelop‚Äù con la rama remota ‚Äúmaster‚Äù, quedando as√≠ finalizado el desarrollo de la aplicaci√≥n Android, a espera de futuras mejoras y pruebas.


# Implementaci√≥n <a name="implementacion"></a>

En este apartado se documentar√° todo el proceso de **implementaci√≥n** que se ha seguido en el proyecto, desde su planificaci√≥n hasta las clases implementadas que componen la aplicaci√≥n, pasando por decisiones de implementaci√≥n como su sintaxis, patrones de dise√±o, etc.

Este se puede apreciar en el siguiente diagrama de clases, que contiene los principales componentes del modelo de datos:

<img src="https://i.imgur.com/6q2Uk6u.png"/>

En primera instancia, existe una entidad en la Room llamada **Usuario** que se encarga de almacenar las credenciales procedentes de un usuario durante el registro. Contiene los siguientes campos:

* 'idu' (int). Contiene el identificador de una tupla de Usuario en la base de datos.
* 'username' (String). Contiene el nombre de usuario introducido durante el registro.
* 'password' (String). Contiene la contrase√±a introducida durante el registro.
* 'conectado' (booleano). Almacena el valor ‚Äòtrue‚Äô si el usuario se encuentra conectado en la aplicaci√≥n, ‚Äòfalse‚Äô en caso de no estar logueado.

El usuario puede crear eventos en la aplicaci√≥n. Existen dos tipos de eventos: aquellos cuya ubicaci√≥n se encuentra en un municipio y aquellos cuya ubicaci√≥n se encuentra en una monta√±a. Sin embargo, se ha tomado la decisi√≥n de no almacenar las condiciones meteorol√≥gicas de la ubicaci√≥n de un evento (atributo de tipo Weather que se detalla posteriormente) en la base de datos, puesto que el tiempo meteorol√≥gico es din√°mico y cambia respecto pasan las horas o d√≠as. Como consecuencia de ello, en la base de datos no se hace diferencia respecto a los dos tipos de eventos, sino que sendos eventos se representan con una **√∫nica entidad Evento** en el modelo de la Room.

Esta clase contiene los siguientes atributos:

* 'ide' (int). Contiene el identificador de una de las muchas tuplas de Evento en la base de datos.
* 'titulo' (String). Contiene el t√≠tulo del evento introducido durante su creaci√≥n.
* 'ubicacion' (String). Contiene una cadena relativa a la ubicaci√≥n del evento. Si es un evento de municipio, contiene el nombre del municipio. En caso de ser un evento de monta√±a, contiene el nombre de la monta√±a.
* 'descripcion' (String). Contiene la descripci√≥n del evento introducida por el usuario durante la creaci√≥n del evento.
* 'esMunicipio' (boolean). Valor booleano que sirve para diferenciar en la misma entidad si es un evento de municipio o de monta√±a.
* 'fecha' (Date). Contiene la fecha en la que se da el evento. Tiene un formato del estilo ‚Äòdd/MM/yy‚Äô. No se opta por contener las horas, minutos ni segundos. Este atributo de la entidad es sumamente importante, a partir de √©l se realizar√° una llamada a la API del tiempo para obtener las condiciones meteorol√≥gicas del evento en ese d√≠a.

Se requiere de una clase que almacene las condiciones meteorol√≥gicas al hacer una llamada a la API del tiempo, independientemente del tipo de evento (Municipio o Monta√±a) y de la petici√≥n del tiempo de la ubicaci√≥n actual. Esta clase es la llamada Weather y contiene los siguientes atributos:

* 'ciudad' (String). Contiene el nombre del municipio o monta√±a de la ubicaci√≥n sobre la que se obtiene el tiempo.
* 'gifResource' (int). Contiene un c√≥digo num√©rico referente al estado del tiempo (‚ÄúLluvia‚Äù, ‚ÄúSoleado‚Äù, etc). Este c√≥digo se mapear√° din√°micamente en un GIF para personalizar la interfaz relativa al tiempo meteorol√≥gico.
* Los atributos relativos a las condiciones meteorol√≥gicas:
  * 'temperatura' (int)
  * 'sensTermica' (int)
  * 'tempMinima' (int)
  * 'tempMaxima' (int)
  * 'presion' (int)
  * 'humedad' (int)
  * 'velocidadViento' (double)
  * 'estadoTiempo' (String)
  * 'descEstadoTiempo' (String)

Se ha mencionado que los eventos tienen asignado una ubicaci√≥n de monta√±a o municipio seg√∫n lo considere el usuario durante su creaci√≥n, que junto con la b√∫squeda del tiempo en la ubicaci√≥n actual del dispositivo, es necesario incluir en la aplicaci√≥n un archivo JSON que contengan todos los **municipios** de Espa√±a y otro archivo destinado a las **monta√±as** de Espa√±a. 

* El JSON de municipios se ha obtenido de un archivo excel de la p√°gina oficial de AEMET. Como el excel incorporaba columnas innecesarias, se ha transformado para incluir el c√≥digo de municipio: concatenaci√≥n del c√≥digo de provincia (3 d√≠gitos)  + c√≥digo de municipio (2 d√≠gitos), el nombre del municipio y el nombre de la provincia a la que pertenece. Seguidamente, se manej√≥ un conversor online XLS to JSON para obtener el JSON final para poseer todos los municipios listos para usarse en la app.

  [https://beautifytools.com/excel-to-json-converter.php](https://beautifytools.com/excel-to-json-converter.php)

* El JSON de monta√±as se ha creado manualmente (s√≥lo existen 9 monta√±as en Espa√±a) , como consecuencia de la API OpenWeather, la cual solo permite realizar una petici√≥n del tiempo de una monta√±a en base a sus coordenadas (longitud, latitud). Por lo tanto, siguiendo el mismo proceso que en el JSON de municipios, un objeto de monta√±a del JSON contiene la latitud, longitud y el nombre de la monta√±a.

Para convertir los objetos del JSON en objetos java y cargarlos en nuestra aplicaci√≥n, se han dise√±ado dos clases java con la herramienta jsonSchema2Pojo, obteniendo las clases Montana y Municipio.

[https://www.jsonschema2pojo.org](https://www.jsonschema2pojo.org)

## Estructura del proyecto <a name="estructura"></a>

Se ha llevado a cabo una divisi√≥n de la estructura del proyecto en distintos m√≥dulos.

Dentro de la carpeta <strong>json</strong> se encuentran aquellos modelos de datos que no se guardan en la base de datos sino que almacenan en tiempo de ejecuci√≥n los datos extra√≠dos de los archivos con extensi√≥n json.

El m√≥dulo de <strong>Room</strong> contiene aquellas clases involucradas con la base de datos:
* **DAO**: Los archivos Dao
* **Javadb**: Herramientas utilizadas en la conversi√≥n de datos de los modelos.
* **Modelo**: Clases modelo que almacenan la informaci√≥n de cada entidad.

En el m√≥dulo <strong>utils</strong> se encuentran las dos clases que trabajan con la API.

En el m√≥dulo UI se encuentran aquellas actividades y fragmentos que interactuan con la interfaz de la aplicaci√≥n:
* **Ajustes**: Actividad y fragmento de ajustes
* **Eventos**: Actividades y fragmentos correspondientes a las operaciones CRUD sobre las entidades de Eventos.
* **Inicio**: Fragmento de inicio de la aplicaci√≥n
* **ListaEventos**: Contiene aquellas clases involucradas en mostrar y filtrar los eventos en el caso de uso de la lista.
* **Localizaciones**: Componentes relacionados con el caso de uso de filtrado y b√∫squeda de localizaciones
* **Perfil**: Actividades y fragmentos correspondientes a las operaciones CRUD sobre la entidad de usuario.

<img src="https://i.imgur.com/wROWjBQ.png"/>



## Detalles de implementaci√≥n <a name="detallesImplementacion"></a>

En este apartado se describen aspectos esenciales de la implementaci√≥n de la aplicaci√≥n Android, as√≠ como patrones de dise√±os y aspectos novedosos dentro de √°mbito de la asignatura ASEE.

### Patrones de Dise√±o <a name="patronesDise√±o"></a>

A lo largo del proceso de desarrollo de este proyecto se han incluido una serie de Patrones de Dise√±o en su implementaci√≥n, que expresan esquemas para definir estructuras de dise√±o (o sus relaciones) con las que construir sistemas de software. Facilitan la codificaci√≥n, seguridad y consistencia a la aplicaci√≥n durante su ejecuci√≥n.
Los patrones de dise√±o utilizados se indican a continuaci√≥n.

#### Patr√≥n Singleton

El patr√≥n de dise√±o Singleton es un patr√≥n de dise√±o creacional que gestiona la creaci√≥n de objetos de una clase concreta, de manera que solo pueda existir una √∫nica instancia en tiempo de ejecuci√≥n.

<img src="https://i.imgur.com/CY12Ege.png"/>

Esto se consigue gracias a que la clase que implementa este patr√≥n sigue las siguientes condiciones:

* Posee un atributo privado y est√°tico del tipo de la clase, que ser√° la √∫nica instancia en tiempo de ejecuci√≥n.
* El constructor de la clase es de tipo privado.
* Posee un m√©todo p√∫blico y est√°tico getInstance que devolver√° el atributo de la clase declarado como privado. De forma que si el atributo a√∫n no est√° inicializado (atributo == null) previamente se crear√° mediante el constructor privado. Y si ya est√° inicializado, lo devolver√° directamente.

De esta forma, cada vez que se tenga que utilizar un objeto de esta clase, se invocar√° utilizando llamando al m√©todo getInstance() de forma est√°tica desde el nombre de la clase (Clase.getInstance()), que devolver√° siempre la misma instancia del objeto que utiliza el patr√≥n.

Se ha utilizado el Patr√≥n singleton en la creaci√≥n de la clase AppDatabase, que crea y gestiona la base de datos, ya que con este la clase s√≥lo podr√° tener una √∫nica instancia en tiempo de ejecuci√≥n para no tener que inicializarla varias veces, y acceder siempre a la misma para modificar la base de datos.

As√≠ mismo, tambi√©n se ha utilizado en la creaci√≥n de la clase JsonSingleton, que permite obtener todos los datos relativos al clima de las monta√±as y municipios carg√°ndose de la API. De, esta forma, se pueda acceder a todos los municipios y monta√±as existentes junto con la informaci√≥n sobre su clima en cualquier parte del programa, permitiendo m√°s facilmente la consulta de los datos de estos por el usuario o su asignaci√≥n a eventos.

Ventajas del patr√≥n Singleton
* La propia clase es responsable de crear la √∫nica instancia. Por medio de su m√©todo constructor.
* Permite el acceso global a dicha instancia mediante un m√©todo de clase.
* Declara el constructor de clase como privado para que no sea instanciable directamente.
* Al estar internamente autoreferenciada, en lenguajes como Java, el recolector de basura no act√∫a.
* Se puede ejercer un control preciso sobre cu√°ndo y c√≥mo se accede a √©l.

#### Patr√≥n DAO

El patr√≥n de dise√±o Data Access Object (DAO) es un patr√≥n de dise√±o Arquitect√≥nico que permite gestionar el desarrollo de una aplicaci√≥n que utiliza bases de datos (persistencias de datos) al separar todos los componentes del sistema en 3 tipos bien definidos:

* Componentes relacionados con el **modelo de datos** y la l√≥gica de negocio (clases del diagrama)
* Componentes destinados a la **transferencia de datos**, encargados de conectarse a la base de datos o modificarla. Implementan el patr√≥n de dise√±o **Data Transference Object** (DTO).
* Componentes destinados al **acceso a datos**, conectados con los de transferencia de datos para enviar la informaci√≥n a la l√≥gica de negocio, aislando los detalles de implementaci√≥n. Se tratan de interfaces que son implementadas por los componentes de transferencia, permitiendo ocultar detalles concretos sobre la implementaci√≥n de la conexi√≥n a la base de datos.

<img src="https://i.imgur.com/DoqeMVr.png"/>

Este patr√≥n permite **separar la l√≥gica de datos** de la forma de acceder a estos con conexiones a la base de datos, pues los componentes de acceso a datos son capaces de implementar varios tipos de componente de transferencia de datos, lo que permite **modificar** el tipo de acceso a la base de datos sin afectar la aplicaci√≥n, pudiendo incluso **tener varios tipos de acceso a datos** al mismo tiempo.

Este patr√≥n se ha utilizado durante la inclusi√≥n del servicio Room en Android Studio, ya que este utiliza las interfaces DAO creadas para implementar los componentes de transferencia de datos, que almacenar√°n la informaci√≥n en las clases de la l√≥gica de negocio (declaradas como Entity), conect√°ndose a la base de datos a trav√©s de la clase AppDatabase.

<img src="https://i.imgur.com/FhC2n0x.png"/>

Esta clase **AppDatabase**, que deber√° ser abstracta, se utilizar√° para recuperar informaci√≥n y modificar la base de datos, pues devolver√° las interfaces DAO que contienen la informaci√≥n y pueden manipular la base de datos.

A su vez, **las interfaces DAO** modificar√°n y acceder√°n los valores de los componentes del modelo de datos a trav√©s de los m√©todos getters y setters definidos de estos. As√≠ mismo, estos componentes DAO contar√°n con m√©todos que seg√∫n como se marquen realizan distintas operaciones en la base de datos, siendo la inserci√≥n (Insert), modificaci√≥n (Update), borrado (Delete) y consulta (Query).

Por otra parte, **los componentes de la l√≥gica de negocio** ser√°n las clases marcadas como Entity, que compondr√°n la estructura de la base de datos y almacenar√°n la informaci√≥n recuperada de esta.

Ventajas de utilizar el patr√≥n DAO:
* Es f√°cil de implementar
* Permite separar por completo la l√≥gica de acceso a datos en una capa separada y as√≠ solo trabajar con la l√≥gica de negocio sin preocuparnos de donde viene los datos o los detalles t√©cnicos para consultarlos o actualizarlos.
* Puede funcionar en conjunto con el patr√≥n Repository.

### Refactorizaci√≥n <a name="refactorizaci√≥n "></a>

#### Patr√≥n Repository
Se ha optado por unificar todas las fuentes de datos creando una sola instancia que permita acceder a todos los datos.

<img src="https://imgur.com/XH3atJm.png"/>

Para ello, se han creado una serie de Repositorios asociados a los objetos del modelo de datos que son almacenados en la base de datos y accedidos desde la app. 

La clase **EventRepository** permitir√° acceder tanto a los datos procedentes de la api (APIManager) como a la informaci√≥n que se encuentra en la base de datos de Room (AppDatabase).  La clase de repositorio a√≠sla las fuentes de datos del resto de la app, una capa intermedia entre la capa de dominio y la capa de acceso de datos. Usar una clase de repositorio garantiza que este c√≥digo sea independiente de la clase ViewModel y es una pr√°ctica recomendada para la separaci√≥n del c√≥digo y su arquitectura.

Por dem√°s,  un evento tiene asociado datos relacionados con el tiempo meteorol√≥gico proporcionados por la API. Si el usuario desea consultar los detalles de un evento consultado recientemente, **EventRepository** se encarga de cargar los datos de la Room (o cach√©). En el caso de consultar los detalles de un evento en un periodo de tiempo superior al umbral establecido, entonces se realiza una petici√≥n a la API OpenWeather y se actualiza la cach√© con los datos retornados de la API.

As√≠ mismo, tambi√©n se ha creado una clase **LocationRepository** la cual permitir√° acceder a los datos de la API (APIManager) como fuente de datos externa y al modelo de Room (LocationDAO), en el que se manejan las localizaciones alojadas (municipios). De esta manera, el repositorio har√° de capa intermedia entre la app (los ViewModels) y estas fuentes de datos.

Del mismo modo, se ha creado una clase **UserRepository** la cual permitir√° acceder a los usuarios de Room. 

En el proceso de implementaci√≥n de este patr√≥n, se consideraron una serie de cambios relativos al modelo de datos de la aplicaci√≥n propuesto en una versi√≥n temprana, con el objetivo de implementar la memoria cach√©.
* Para comprobar si se requiere una actualizaci√≥n del tiempo meteorol√≥gico de un evento, es conveniente almacenar la informaci√≥n del tiempo dentro del propio objeto Evento. Por ello, se ha modificado la entidad Evento incluyendo los atributos relativos al tiempo meteorol√≥gico, que anteriormente se encontraba en la clase Weather. 
* Por ende, al consultar los detalles de un evento, se comprueba si es necesario recuperar los datos asociados al tiempo de dicho evento desde la cach√© o actualizar la base de datos con los datos devueltos de la API.
* Creaci√≥n de una clase Location, que almacena toda la informaci√≥n (tiempo) relativa a una ubicaci√≥n concreta. Esta clase sustituye a la anterior Weather, que se introducir√° dentro de la clase Evento.
* Creaci√≥n de una interfaz dao LocationDAO relativa a la gesti√≥n de objetos Location en la base de datos. 

Tras todas estas modificaciones, el modelo de datos resultante utilizado en la base de datos ser√≠a el siguiente:

<img src="https://imgur.com/uMSEZGA.png"/>

**Ventajas de usar un repositorio**
Un m√≥dulo de repositorio controla operaciones de datos y te permite usar varios backends. En una app real t√≠pica, el repositorio implementa la l√≥gica para decidir si debe recuperar datos de una red o usar resultados almacenados en cach√© de una base de datos local. 

Con un repositorio, puedes intercambiar los detalles de la implementaci√≥n, como la migraci√≥n a una biblioteca de persistencia diferente, sin afectar el c√≥digo de llamada, como los modelos de vista. Esto tambi√©n permite que tu c√≥digo sea modular y se pueda probar. Puedes simular con facilidad el repositorio y probar el resto del c√≥digo.

Un repositorio debe funcionar como una √∫nica fuente de verdad para una parte espec√≠fica de los datos de tu app. Cuando se trabaja con varias fuentes de datos, como un recurso conectado en red y una cach√© sin conexi√≥n, el repositorio garantiza que los datos de la app sean lo m√°s precisos y actualizados, lo que proporcionar√° la mejor experiencia posible incluso cuando la app est√© sin conexi√≥n.

#### Patr√≥n Model - View - ViewModel (MVVM)
Con el objetivo de incrementar la seguridad de la aplicaci√≥n y gestionar los datos de forma m√°s r√°pida y eficiente se ha implementado el patr√≥n Model - View - ViewModel (MVVM).
 
Se han implementado los siguientes viewmodels:

* ListaEventosViewModel: Viewmodel que permite gestionar los datos de la lista de eventos del fragmento ListaEventosFragment.
* DetallesEventoViewModel: Viewmodel que gestiona los datos al mostrar los detalles de un evento en el fragmento DetallesEventoFragment.
* TiempoActualViewModel: Viewmodel que gestiona el tiempo actual mostrado en el fragmento de inicio InicioFragment.
* DetallesLocalizacionViewModel: Viewmodel que gestiona el tiempo de una ubicaci√≥n concreta en la actividad DetalleLocalizacionActivity.
* IniciarSesionViewModel: Viewmodel que gestiona el inicio de sesi√≥n en la actividad InicioSesion.
* RegistrarseViewModel: Viewmodel que gestiona la pantalla de registro de usuario en la actividad Registrarse.
* PerfilViewModel: Viewmodel que gestiona la consulta y modificaci√≥n del usuario en el fragmento PerfilFragment.
* BorrarPerfilViewModel: Viewmodel que permite eliminar el usuario en el fragmento DeleteDialogFragment.
* ModificarEventoViewModel: Viewmodel que gestiona los detalles relativos a la pantalla de modificar un evento del fragmento ModificarEventoFragment.
* mainUsuarioViewModel: Viewmodel que permite comprobar y cerrar la sesi√≥n del usuario en MainActivity.

Cabe mencionar que los ViewModels tienen una dependencia relacionada con un Repository espec√≠fico. Para solventar la escalabilidad de c√≥digo de nuestra aplicaci√≥n respecto la adicci√≥n de nuevas dependencias a los ViewModel, se ha implementado el patr√≥n de dise√±o Factory para crear instancias ViewModel de manera sencilla. Adem√°s, ante el crecimiento de dependencias de la app como los repositorios, AppDataBase y factories, entre otros; se han agrupado como atributos en una clase Singleton llamada AppContainer, la cual es instanciada por primera vez en una nueva clase llamada MyApplication que extiende Application. Para iniciar esta clase, se ha modificado el AndroidManifest incrustando un atributo android:name=‚Äù.MyApplication‚Äù.

El recurso de ViewModel destaca como el componente que se encargar√° de servir como puente entre la interacci√≥n de la Vista (View) y el Modelo (Model).

Entre sus ventajas encontramos:

* Su capacidad para separar de forma limpia la presentaci√≥n de una aplicaci√≥n determinada y la l√≥gica del negocio de su interfaz de usuario. Lo que contribuye a abordar m√∫ltiples tipos de inconvenientes de desarrollo, prueba, mantenimiento y evoluci√≥n del sistema.
* Permite que los desarrolladores creen pruebas unitarias para el Model View y el modelo, sin que sea necesario el uso de la vista.
* Los encargados del dise√±o y desarrollo de aplicaciones pueden ser capaces de trabajar de manera simult√°nea e independiente, cada uno en sus componentes durante los procesos de la app.
* ViewModel permite la conservaci√≥n tanto en el estado que contiene un ViewModel como en las operaciones que est√© activa. Este almacenamiento en cach√© significa que no necesitas recuperar datos mediante cambios de configuraci√≥n comunes, como una rotaci√≥n de pantalla.
* SaveStateHandle te permite conservar datos no solo a trav√©s de cambios de configuraci√≥n, sino tambi√©n durante la recreaci√≥n de procesos. Es decir, te permite mantener el estado de la IU intacto, incluso cuando el usuario cierra la app y la abre m√°s adelante.
* Reducci√≥n de la complejidad: al separar la l√≥gica de presentaci√≥n de la l√≥gica de negocio en componentes distintos, el c√≥digo de la aplicaci√≥n se vuelve m√°s f√°cil de entender y mantener.
* Mayor reutilizaci√≥n de c√≥digo: debido a que la l√≥gica de presentaci√≥n y la l√≥gica de negocio est√°n separadas, se pueden reutilizar f√°cilmente en diferentes vistas y contextos.
* Mejora del rendimiento: el patr√≥n MVVM permite que la vista se actualice autom√°ticamente cuando los datos cambien en el modelo, lo que reduce la cantidad de c√≥digo que se debe escribir y mejora el rendimiento de la aplicaci√≥n.


### Aspectos novedosos y decisiones tomadas <a name="aspectosNovedosos"></a>

#### Reglas de Sintaxis <a name="reglasSintaxis"></a>

Para realizar la implementaci√≥n del proyecto, previamente se han establecido una serie de reglas de sintaxis que deben seguir los elementos implementados en Android Studio. Estas son las siguientes:
* En lo referente a los identificadores (atributo **id**) de cada pantalla que se encuentra en los grafos de navegaci√≥n, estos deber√°n comenzar con la cadena "nav_", representando que se tratan de las pantallas de navegaci√≥n que conforman el proyecto.
* Cada actividad que se haya creado, deber√° finalizar su nombre con la subcadena ‚ÄúActivity‚Äù, mientras que cada fragmento creado, deber√° finalizar con la subcadena ‚ÄúFragment‚Äù. Esto aporta m√°s consistencia al proyecto.
* Dado que el nombre de cada layout debe ser en min√∫sculas, el layout (archivo .xml) de una Activity deber√° comenzar por la cadena ‚Äúactivity_‚Äù, mientras que el layout de un Fragment deber√° comenzar por la cadena ‚Äúfragment_‚Äù y el layout que funciona como contenedor de otros fragmentos deber√° comenzar por la cadena ‚Äúcontent_‚Äù.

#### Gesti√≥n de la API <a name="gestionAPI"></a>

En primer lugar se ha decidido no hacer uso de **Retrofit** para la gesti√≥n y configuraci√≥n de la API.

En su lugar, esta funcionalidad se encuentra en una sola clase **APIManager** que seguir√° un patr√≥n de delegaci√≥n mediante una interfaz **APIManagerDelegate** la cual se a√±ade como atributo de aquel componente que quiera hacer uso de la API y as√≠ poder implementar los m√©todos de esta interfaz cuando las llamadas a la API devuelven un resultado.

De esta forma todo el networking de la aplicaci√≥n se encuentra en la misma clase, cuando a los m√©todos que hacen referencia a las distintas llamadas a la API. La llamada a la API se realiza mediante una petici√≥n as√≠ncrona haciendo uso de la **librer√≠a AsyncHttpClient** ahorr√°ndonos as√≠ la creaci√≥n y gesti√≥n de un hilo.

#### Obtenci√≥n de localizaci√≥n <a name="obtencionLocalizacion"></a>

Uno de los casos de uso de la aplicaci√≥n, requiere de obtener las coordenadas (longitud y latitud) de la ubicaci√≥n del dispositivo. Para ello es necesario comprobar que se tienen los permisos de **GPS**, los cuales se comentan en el siguiente apartado. Una vez se tienen los permisos mediante un **LocationManager** se obtienen del proveedor de internet dichas coordenadas.

#### Gesti√≥n de Permisos <a name="gestionPermisos"></a>

Este apartado detalla la solicitud de los permisos necesarios para el correcto funcionamiento de la aplicaci√≥n.

Los permisos (que no se hayan concedido) siempre se piden al iniciar la aplicaci√≥n mediante la clase **Launch**. En caso de no conceder los de GPS, puesto que forman parte de una funcionalidad b√°sica y esencial de la aplicaci√≥n, no se podr√° acceder a la misma hasta que no se otorguen.

Una vez concedidos los permisos, la aplicaci√≥n comprueba en todo momento que estos sigan estando concedidos antes de ejecutar alguna operaci√≥n que los requiera. En caso de no estar otorgados porque el usuario los haya quitado mientras est√° usando la aplicaci√≥n, esta gestionar√≠a correctamente la ausencia de permisos sin generar errores.

En el hipot√©tico caso de necesitar nuevos permisos en el desarrollo de la aplicaci√≥n, el c√≥digo ha sido modularizado de forma que √∫nicamente habr√≠a que a√±adir el nombre de dichos permisos al vector de permisos de la clase **Launch** (deber√≠an estar presentes en el archivo manifest).

#### Carga de municipios y monta√±as desde JSON <a name="cargaJSON"></a>

La lista de monta√±as necesaria para el spinner del caso de uso de Crear Evento de Monta√±a junto a sus coordenadas se encuentra almacenada en un archivo json. De igual forma para el caso de uso de filtrado de localizaciones se ha hecho uso de una lista de todos los municipios de Espa√±a la cual tambi√©n se encuentra almacenada en un archivo json.

Ambos archivos son cargados en un mapa de Java gestionado como una √∫nica instancia accesible desde cualquier lugar de la aplicaci√≥n (Singleton) en la clase **JsonSingleton** al iniciar la aplicaci√≥n por primera vez. Haciendo uso de la librer√≠a Gson obtenemos la informaci√≥n del json en los modelos **Municipio** y **Evento** que posteriormente se almacenar√°n en los mapas del singleton.


#### Men√∫ de Hamburguesa <a name="menuHamburguesa"></a>

Hemos decidido la utilizaci√≥n de un **men√∫ de hamburguesa** como m√©todos de navegaci√≥n entre las pantallas principales de nuestra aplicaci√≥n.

Este men√∫ nos permite que el usuario pueda navegar entre las cuatro pantallas principales de la aplicaci√≥n sin que esto ocupe espacio de pantalla, este men√∫ contiene las pantallas **inicio**, **eventos**, **perfil** y **ajustes**, dejando para la barra de navegaci√≥n la b√∫squeda de ubicaciones y el bot√≥n de cerrar sesi√≥n.

Para su implementaci√≥n se ha utilizado la main activity como contenedora del men√∫ de hamburguesa y de los diferentes fragmentos de inicio, eventos, perfil y ajustes.

De esta manera hemos conseguido que de una forma compacta todo lo que tiene relaci√≥n con la navegaci√≥n de la app.

#### Filtro de Eventos <a name="filtroEventos"></a>

Dentro de la pantalla de la lista de eventos hemos implementado un filtro que nos permite diferenciar los diferentes eventos que haya guardado el usuario, tanto por tipo de evento como teniendo en cuenta o bien el orden de creaci√≥n del evento o la fecha de dicho evento.

Para los tipos de evento hemos decidido que la filtraci√≥n se haga con un Tab, intercambiando entre los eventos de municipio y los eventos de monta√±a.

Para filtrar por orden de creaci√≥n o de fecha de evento, hemos decidido crear un spinner que nos permite seleccionar entre las dos opciones.

Con esto conseguimos que se intercalan los dos tipos de filtrados que hacemos pudiendo obtener as√≠ cuatro configuraciones distintas:

1. Municipios ordenados por fecha de creaci√≥n del evento
2. Municipios ordenados por fecha del evento
3. Monta√±as ordenadas por fecha de creaci√≥n del evento
4. Monta√±as ordenadas por fecha del evento

De esta forma podemos darle todas las opciones que el usuario necesita para filtrar sus eventos de una manera c√≥moda y sencilla.

#### Usuario √∫nico <a name="usuarioUnico"></a>

En esta aplicaci√≥n hemos implementado el usuario de tal forma que solamente existe un √∫nico usuario, esto se ha hecho as√≠ debido a que el usuario se guarda de manera local y no en remoto, y tambi√©n a que no hemos concebido la aplicaci√≥n para qu√© se guarden diferentes cuentas dentro de nuestra aplicaci√≥n, sino como una lista local de eventos.

#### Implementaci√≥n de Spinners en diversos campos <a name="spinners"></a>

Se han implementado campos con el tipo de Spinners en los **campos de Monta√±a** de las pantallas destinadas a crear un evento de Monta√±a (layout del fragmento CrearEventoMontana) y modificar un evento de monta√±a (layout del fragmento ModificarEventoMontana) con el objetivo de seleccionar una monta√±a existente del conjunto obtenido del JSON para crear o modificar un evento.

De esta forma, se asegura que tras seleccionar el nombre de la monta√±a en la creaci√≥n o modificaci√≥n de eventos, esta no sea err√≥nea, pues se ha tenido que elegir un nombre existente entre las monta√±as cargadas, ahorrandole al usuario el hecho de probar hasta dar con el nombre exacto de la monta√±a.

As√≠ mismo, tambi√©n se ha implementado un campo de Spinner para especificar **el tipo de Ordenaci√≥n** que se aplicar√° al filtrar todos los eventos, en la secci√≥n **Eventos**. Dicho campo con el tipo de ordenaci√≥n permitir√° organizar los eventos por orden de creaci√≥n o por fecha.

#### Filtrado de localizaciones <a name="filtradoLocalizaciones"></a>

Una vez iniciada sesi√≥n, desde la pantalla principal se puede acceder a la funcionalidad de filtrado de localizaciones si se pulsa el icono de lupa de la ToolBar.

Se inicia una nueva actividad que se encarga de leer el **listado de municipios** de Espa√±a desde la colecci√≥n de tipo mapa instanciada en el SingletonJSON y se utiliza un **Adapter** como intermediario entre la obtenci√≥n de los municipios con el layout. 

En el layout, se define un nuevo elemento **SearchView**, parecido a un input que permite actualizar en tiempo real la lista de municipios, de acuerdo a la cadena introducida por el usuario. 

En el c√≥digo de la actividad **LocalizacionesActivity**, se define un listener para el SearchView, sobreescribiendo un m√©todo llamado **onQueryTextChange(String text)**. Dentro, se llama a una funci√≥n filtradora llamada **filter(text)** y se le pasa la cadena del SearchView introducida por el usuario. En la funci√≥n de filtrado, se inserta en una variable auxiliar (ArrayList) aquellos municipios que coinciden con la cadena introducida, mediante la funci√≥n findWithPrefix(municipios, cadena). 

Por √∫ltimo, al disponer de la nueva colecci√≥n de municipios filtrados, queda actualizar la lista de items del Adapter y notificar que se ha modificado para actualizar la interfaz con los nuevos municipios coincidentes.

Esto **permite** al usuario buscar una localidad sin necesidad de que este sepa su nombre exacto, el cual es necesario tanto para crear un evento como para ver el tiempo actual en una localidad.

#### Modo Oscuro <a name="modoOscuro"></a>

El modo oscuro es un ajuste de configuraci√≥n que se encuentra en la secci√≥n ‚ÄúAjustes‚Äù del men√∫ hamburguesa. Se ha implementado con las **Preferencias** que nos ofrece la API de Android. Por defecto, el tema de la aplicaci√≥n es el modo oscuro. 

Cuando se activa el **checkbox**, desde el fragmento ‚ÄúAjustesFragment‚Äù se modifica el valor relativo al nuevo tema de la aplicaci√≥n en las **SharedPreferences** , gracias a su **editor**. A continuaci√≥n, se realiza un callback a la actividad ‚ÄúMainActivity‚Äù que soporta el fragmento. La funci√≥n del callback se encarga de leer el archivo SharedPreferences modificado y delega el cambio de tema de la aplicaci√≥n al **AppCompat**, recreando de nuevo la actividad y sus fragmentos involucrados para que la interfaz se actualice en base al nuevo tema.

Por otro lado, se incluyen dos archivos en la carpeta de recursos de la aplicaci√≥n llamados theme (uno con la configuraci√≥n de la interfaz en modo claro y el otro en modo oscuro). En estos archivos theme, se definen unos estilos que ser√°n intercambiados seg√∫n la configuraci√≥n de la aplicaci√≥n.

En el resto de componentes de la aplicaci√≥n, se realiza el mismo proceso. En el caso de las actividades sin fragmentos, en el **onResume()** se llama al m√©todo que se encarga de leer SharedPreferences y delegar el cambio de tema.

Entre las ventajas que existen a la hora de que nuestra aplicaci√≥n tenga modo oscuro destacan las siguientes:

* Es saludable para los ojos: Ahorr√°ndole al usuario molestias visuales.
* Se visualiza mejor en la oscuridad.
* Prolonga la vida de la bater√≠a: Utilizando menos brillo, o incluso con el apagado de los p√≠xeles de la mayor parte de la pantalla en los paneles OLED.
* Mejora la accesibilidad: Muchas personas con diferentes problemas de vista pueden encontrar en esta opci√≥n una forma de visualizar mejor el contenido.

# Gesti√≥n de la calidad del Software <a name="gestionCalidadSoftware"></a>

En este apartado se describen las pruebas realizadas a la aplicaci√≥n Android, as√≠ como el an√°lisis del c√≥digo para solventar problemas.
Pruebas

En primer lugar, se implementan los test **unitarios**, los cuales son m√°s simples de implementar y suelen identificar un mayor n√∫mero de bugs o problemas. Estos presentan una serie de caracter√≠sticas:
* Deben ser muy peque√±os
* Deben estar centralizados en funcionalidades muy espec√≠ficas.
* Se recomienda la realizaci√≥n de test locales
* Normalmente, no es necesario realizar test instrumentalizados.

Existen multitud de frameworks para implementar test unitarios como JUNIT, Cactus, Mockito, etc. Se ha elegido JUnit, un framework para escribir test unitarios repetibles que pueden ser f√°cilmente integrados en cualquier proyecto Java. Es uno de los frameworks m√°s importantes para el desarrollo del concepto Test-Driven Development.

Se utiliza la librer√≠a JUnit para implementar los test unitarios asociados a las tareas ‚ÄúTest Components‚Äù de cada caso de uso. Para ello, en el build.gradle se incluyen las siguientes  librer√≠as:

<code>testImplementation 'junit:junit:4.12'</code>
<br />
<code>testImplementation 'androidx.test:core:1.4.0'</code>
<br />
<code>androidTestImplementation 'androidx.test:core:1.4.0'</code>
<br /><br />
<code>androidTestImplementation 'androidx.test:runner:1.4.0'</code>
<br />
<code>androidTestImplementation 'androidx.test:rules:1.4.0'</code>
<br />
<code>androidTestImplementation 'androidx.test.espresso:espresso-core:3.4.0'</code>

Los test unitarios se almacenan en un paquete de pruebas llamado ‚Äútest‚Äù. Los test son clases java con anotaciones de JUnit, que le indican al ‚ÄúRunner‚Äù por defecto del framework Android c√≥mo se deben ejecutar las clases test. 

Respecto a los nombres de los test unitarios, estos deben describir el funcionamiento/objetivo del test, qu√© caso de uso se est√° testeando y deben incluir el sufijo <_UnitTest>.

Los test <strong>funcionales</strong> conllevan un mayor tiempo de implementaci√≥n y de ejecuci√≥n, aunque tambi√©n proporcionan una mayor fiabilidad.
* Normalmente, eval√∫an las funcionalidades de la aplicaci√≥n.
* Tests de secciones verticales de la aplicaci√≥n. Estos test eval√∫an diferentes interacciones entre las capas.
* No es recomendado el uso de test locales.
* Se recomiendan tests instrumentalizados.

Probar las interacciones de usuario dentro de una sola app ayuda a garantizar que los usuarios no tengan resultados inesperados ni una mala experiencia cuando interact√∫en con la app. Para realizar los test de interfaz o funcionales, se utiliza la librer√≠a **Espresso**. 

Espresso est√° dirigido a desarrolladores, que creen que las pruebas automatizadas son una parte integral del ciclo de vida del desarrollo. Si bien Espresso se puede usar para pruebas de caja negra, quienes est√°n familiarizados con la base de c√≥digo bajo en modo de prueba pueden aprovecharlo al m√°ximo.

En el build.gradle, se a√±ade las dependencias necesarias de la librer√≠a:

<code>androidTestImplementation 'androidx.test.espresso:espresso-core:3.3.0'</code>
<br />
<code>androidTestImplementation 'androidx.test:runner:1.3.0'</code>
<br />
<code>androidTestImplementation 'androidx.test:rules:1.3.0'</code>

Adem√°s, como Espresso es un test instrumentado, hay que indicar en el build.gradle la clase que nos ayuda con la instrumentalizaci√≥n: AndroidJUnitRunner.

<code>testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"</code>

La grabadora de pruebas <strong>Espresso</strong> te permite crear pruebas de IU para tu app sin la necesidad de escribir c√≥digo de prueba. Es imprescindible deshabilitar las animaciones de la app, para evitar fallos en la grabadora. Para ello, se accede a <i>Configuraci√≥n - Opciones para desarrolladores</i> y desactiva todas las siguientes opciones:
* Escala de animaci√≥n de ventana
* Escala de animaci√≥n de transici√≥n
* Escala de duraci√≥n de animador

## Pruebas implementadas <a name="pruebasImplementadas"></a>

En primera instancia, cada l√≠der de los equipos de desarrollo han creado las ramas correspondientes a los casos de uso asignados a cada equipo. Estas nuevas ramas tienen como nombre TEST - CU<N√∫mero> y han sido creadas a partir de la rama ‚Äúorigin/develop‚Äù de la pr√°ctica de implementaci√≥n.

A continuaci√≥n, se engloba en una tabla la planificaci√≥n por roles de las tareas de testeo:

<img src="https://imgur.com/tW23VWd.png" />

Cabe destacar que en esta tabla la tarea **Test Evl.** corresponde a la de la disciplina de test ‚ÄúTest and Evaluate‚Äù, mientras que la tarea denominada **AAM** corresponde a ‚ÄúAchieve Acceptable Mission‚Äù and Improve Test Assets‚Äù.

Una vez creadas las ramas de caso de uso para el testeo, cada l√≠der liderar√° acerca de las tareas que deben realizar cada uno de los roles, as√≠ como las clases y componentes que deben ser evaluados para cada caso de uso.

## Equipo 1 (Se√±or Blanco) <a name="testEquipo1"></a>

### CU01 - A√±adir Evento de Municipio <a name="testCU01"></a>

#### Test unitario <a name="testUnitarioCU01"></a>

Se crea un paquete en los ‚Äútest‚Äù llamado **A√±adirEventoMunicipio**. En √©l, se crean dos clases test unitarias: **EventoUnitTest** y **MunicipioUnitTest**, correspondientes a las clases del modelo de datos **Municipio** y **Evento**.

Respecto el modelo **Municipio**, se testean los m√©todos getter/setters. De la clase **Evento**, se testean los m√©todos getter/setters y el m√©todo compareTo(). 

#### Test funcional <a name="testFuncionalCU01"></a>

Se crea una clase <strong>CrearEventoMunicipioTest</strong> en el paquete AndroidTest para testear el funcionamiento de la Interfaz de usuario al crear un evento de municipio en la aplicaci√≥n. Este m√©todo se ha creado a partir de la grabadora de Espresso, incorporada en Android Studio. 

Este test consiste en lo siguiente: primero se registra con una credenciales e inicia sesi√≥n en la aplicaci√≥n. En la pantalla principal, se pulsa el floating button para crear un nuevo evento. Aparece una pantalla de elecci√≥n del tipo de evento a crear, se elige el de tipo de evento llamado Municipio. 

Esto mostrar√° la pantalla de creaci√≥n, donde se piden todos los datos del evento, en este caso se introducir√° como nombre del evento ‚ÄúFutbol‚Äù y como localidad ‚ÄúSevilla‚Äù.

Se rellenan todos los campos del formulario asociado al nuevo evento y se confirma la creaci√≥n, apareciendo una pantalla de detalles. En este instante, se aplican <strong>asserts</strong> para enriquecer el test. 

A continuaci√≥n, se presiona el bot√≥n ‚Äúback‚Äù para comprobar que se ha incluido el nuevo evento en la lista de eventos, mediante un nuevo <strong>assert</strong>. Para que el test no dependa de otros, es necesario devolver la aplicaci√≥n al estado de ejecuci√≥n inicial (eliminando el evento creado y la cuenta de usuario).

### CU02 - A√±adir Evento de Monta√±a <a name="testCU02"></a>

#### Test unitario <a name="testUnitarioCU02"></a>

Se crea un paquete en los ‚Äútest‚Äù llamado **A√±adirEventoMontana**, el cual requiere dos test unitarios: Montana y Evento. Sin embargo, el segundo se incorpora en el CU01. Por tanto, se crea una clase test unitaria: **MontanaUnitTest**, correspondientes a las clases del modelo de datos <strong>Montana</strong>.

Respecto el modelo **Montana**, se testean los m√©todos getter/setters.

#### Test funcional <a name="testFuncionalCU02"></a>

Se crea una clase <strong>CrearEventoMontanaTest</strong> en el paquete AndroidTest para testear el funcionamiento de la Interfaz de usuario al crear un evento de monta√±a en la aplicaci√≥n. Este m√©todo se ha creado a partir de la grabadora de Espresso, incorporada en Android Studio. 

Este test consiste en lo siguiente: primero se registra con una credenciales e inicia sesi√≥n en la aplicaci√≥n. En la pantalla principal, se pulsa el floating button para crear un nuevo evento. Aparece una pantalla de elecci√≥n del tipo de evento a crear, se elige el de tipo de evento llamado Monta√±a. 

Esto mostrar√° la pantalla de creaci√≥n, donde se piden todos los datos del evento, en este caso se introducir√° como nombre del evento ‚ÄúSenderismo‚Äù y c√≥mo localidad ‚ÄúSierra nevada‚Äù.

Se rellenan todos los campos del formulario asociado al nuevo evento y se confirma la creaci√≥n, apareciendo una pantalla de detalles. En este instante, se aplican <strong>asserts</strong> para enriquecer el test. 

A continuaci√≥n, se presiona el bot√≥n ‚Äúback‚Äù para comprobar que se ha incluido el nuevo evento en la lista de eventos, mediante un nuevo <strong>assert</strong>. Para que el test no dependa de otros, es necesario devolver la aplicaci√≥n al estado de ejecuci√≥n inicial (eliminando el evento creado y la cuenta de usuario).

### CU03 - A√±adir Usuario <a name="testCU03"></a>

#### Test unitario <a name="testUnitarioCU03"></a>

Se crea un paquete en los ‚Äútest‚Äù llamado **A√±adirUsuario**. En √©l, se crea una clase test unitaria: <strong>UsuarioUnitTest</strong>, correspondiente a las clases del modelo de datos <strong>Usuario</strong>.

Respecto el modelo <strong>Usuario</strong>, se testean los m√©todos getter/setters. De la clase Usuario, se testean los m√©todos getter/setters y el m√©todo compareTo(). 

#### Test funcional <a name="testFuncionalCU03"></a>

Se crea una clase **AnadirUsuarioTest** en el paquete AndroidTest para testear el funcionamiento de la Interfaz de usuario al a√±adir una cuenta de usuario en la aplicaci√≥n. Este m√©todo se ha creado a partir de la grabadora de Espresso, incorporada en Android Studio. 

Este test consiste en lo siguiente: primero se registra un nuevo usuario introduciendo en la pantalla de registro los datos relativos al nuevo usuario (nombre de usuario y contrase√±a) y confirmando la operaci√≥n. En este caso, se ha introducido como nombre de usuario ‚ÄúJorge‚Äù y como contrase√±a ‚Äú1234‚Äù, se incorporan adem√°s <strong>asserts</strong> para comprobar que las credenciales son las esperadas. 

Una vez se ha registrado el usuario, se introducen sus credenciales en la pantalla de inicio sesi√≥n para acceder a las funcionalidades de la aplicaci√≥n confirmando el inicio haciendo clic en el bot√≥n de ‚ÄúIniciar sesi√≥n‚Äù, lo que llevar√° a la pantalla principal, donde es necesario devolver la aplicaci√≥n al estado de ejecuci√≥n inicial (eliminando la cuenta de usuario).

### CU04 - A√±adir barra de b√∫squeda y filtrado de ubicaciones <a name="testCU04"></a>

#### Test unitario <a name="testUnitarioCU04"></a>

Los test unitarios de este caso de uso son Municipio (lo tiene implementado el test CU01) y Montana (lo tiene implementado el test CU02).

#### Test funcional <a name="testFuncionalCU04"></a>

Se crea una clase <strong>AnadirBarraBusquedaTest</strong> en el paquete AndroidTest para testear el funcionamiento de la Interfaz de usuario al realizar una b√∫squeda de una localizaci√≥n en la aplicaci√≥n. Este m√©todo se ha creado a partir de la grabadora de Espresso, incorporada en Android Studio. 

Para llevar a cabo este test, primero se ha registrado un usuario en la aplicaci√≥n, introduciendo en la pantalla de registro los datos relativos al nuevo usuario (nombre de usuario y contrase√±a) y confirmando la operaci√≥n. En este caso, se ha introducido como nombre de usuario ‚ÄúLuis‚Äù y como contrase√±a ‚Äú123456‚Äù.

Una vez se ha registrado el usuario, se introducen sus credenciales en la pantalla de inicio sesi√≥n para acceder a las funcionalidades de la aplicaci√≥n confirmando el inicio haciendo clic en el bot√≥n de ‚ÄúIniciar sesi√≥n‚Äù, lo que llevar√° a la pantalla principal.

Una vez se ha iniciado sesi√≥n, se accede a la barra de b√∫squeda haciendo clic en el icono de la lupa colocado en la parte superior de barra de navegaci√≥n (appbar) y se coloca una cadena de texto para comprobar que existen ubicaciones con el nombre de la cadena introducida.

En este caso, se escribir√° la cadena ‚ÄúSevilla‚Äù, lo que deber√° mostrar una lista de ubicaciones en pantalla con al menos una de ellas llamada Sevilla, esto se comprobar√° con un **assert** que se realizar√° sobre un item encontrado del recyclerview que deber√° contener esta cadena.

Finalmente, tras comprobar esto, se procede a borrar el usuario accediendo a la pantalla de ‚ÄúPerfil‚Äù del propio usuario y seleccionar la funcionalidad de eliminar el usuario registrado haciendo clic en el bot√≥n, lo que borrar√° el usuario de la base de datos y cerrar√° sesi√≥n.

## Equipo 2 (Se√±or Marr√≥n) <a name="testEquipo2"></a>

### CU05 - A√±adir preferencias desde el men√∫ AppBar <a name="testCU05"></a>

#### Test unitario <a name="testUnitarioCU05"></a>

En este caso de uso no se requiere ning√∫n test unitario.

#### Test funcional <a name="testFuncionalCU05"></a>

Se crea una clase **MenuTest** en el paquete AndroidTest para testear el funcionamiento del panel lateral de navegaci√≥n de la aplicaci√≥n. Este m√©todo se ha creado a partir de la grabadora de Espresso, incorporada en Android Studio. 

Para llevar a cabo este test, primero se ha registrado un usuario en la aplicaci√≥n, introduciendo en la pantalla de registro los datos relativos al nuevo usuario (nombre de usuario y contrase√±a) y confirmando la operaci√≥n. En este caso, se ha introducido como nombre de usuario ‚Äúpepe‚Äù y como contrase√±a ‚Äúpepe‚Äù.

Una vez se ha registrado el usuario, se introducen sus credenciales en la pantalla de inicio sesi√≥n para acceder a las funcionalidades de la aplicaci√≥n confirmando el inicio haciendo clic en el bot√≥n de ‚ÄúIniciar sesi√≥n‚Äù, lo que llevar√° a la pantalla principal.

Tras llegar a la pantalla principal, se procede a navegar a trav√©s de todas las pantallas que se encuentran en el men√∫ lateral, recorriendo las pantallas de Lista de filtrado de eventos, perfil, ajustes y finalmente de nuevo Inicio.

Finalmente, tras comprobar esto, se procede a borrar el usuario accediendo a la pantalla de ‚ÄúPerfil‚Äù del propio usuario y seleccionar la funcionalidad de eliminar el usuario registrado haciendo clic en el bot√≥n, lo que borrar√° el usuario de la base de datos y cerrar√° sesi√≥n.

### CU06 - Consultar tiempo detallado de una ubicaci√≥n <a name="testCU06"></a>

#### Test unitario <a name="testUnitarioCU06"></a>

Se crea un paquete en los ‚Äútest‚Äù llamado **ConsultarTiempoDetalladoUbicacion**. En √©l, se crea una clase test unitaria: <strong>WeatherUnitTest</strong>, en referencia a la clase del modelo <strong>Weather</strong>, sobre la cual se testean los m√©todos getter/setters.

#### Test funcional <a name="testFuncionalCU06"></a>

Se crea una clase **DetallesLocalizacionTest** en el paquete AndroidTest para testear el funcionamiento de la Interfaz de usuario al consultar los detalles (tiempo) de una localizaci√≥n en la aplicaci√≥n. Este m√©todo se ha creado a partir de la grabadora de Espresso, incorporada en Android Studio. 

Para llevar a cabo este test, primero se ha registrado un usuario en la aplicaci√≥n, introduciendo en la pantalla de registro los datos relativos al nuevo usuario (nombre de usuario y contrase√±a) y confirmando la operaci√≥n. En este caso, se ha introducido como nombre de usuario ‚ÄúLuis‚Äù y como contrase√±a ‚Äú123456‚Äù.

Una vez se ha registrado el usuario, se introducen sus credenciales en la pantalla de inicio sesi√≥n para acceder a las funcionalidades de la aplicaci√≥n confirmando el inicio haciendo clic en el bot√≥n de ‚ÄúIniciar sesi√≥n‚Äù, lo que llevar√° a la pantalla principal.

Tras iniciar sesi√≥n, se accede a la barra de b√∫squeda haciendo clic en el icono de la lupa colocado en la parte superior de barra de navegaci√≥n (appbar) y se coloca una cadena de texto para acceder a una ubicaci√≥n con el nombre de la cadena introducida.

En este caso, se escribir√° la cadena ‚ÄúSevilla‚Äù, lo que muestra una lista de ubicaciones que contienen este nombre, y se hace clic en la ubicaci√≥n que contiene el nombre igual a la cadena ‚ÄúSevilla‚Äù, lo que llevar√° a la pantalla de detalles de la localizaci√≥n.

Esto deber√° mostrar una pantalla con la informaci√≥n de la localidad ‚ÄúSevilla‚Äù, comprobando mediante <strong>assert</strong> que existen cadenas en la pantalla relativas a esta ubicaci√≥n dado que no son igual a las cadenas determinadas por defecto.

Finalmente, tras comprobar esto, se procede a borrar el usuario accediendo a la pantalla de ‚ÄúPerfil‚Äù del propio usuario y seleccionar la funcionalidad de eliminar el usuario registrado haciendo clic en el bot√≥n, lo que borrar√° el usuario de la base de datos y cerrar√° sesi√≥n.

### CU07 - Modificar un evento <a name="testCU07"></a>

#### Test unitario <a name="testUnitarioCU07"></a>

El test unitario de este caso de uso es el del modelo **Evento**, el cual ha sido implementado en el CU01.

#### Test funcional <a name="testFuncionalCU07"></a>

Se crea una clase **ModificarEventoTest** en el paquete AndroidTest para testear el funcionamiento de la Interfaz de usuario al modificar un evento en la aplicaci√≥n. Este m√©todo se ha creado a partir de la grabadora de Espresso, incorporada en Android Studio.

Este test consiste en lo siguiente: primero se registra un nuevo usuario introduciendo en la pantalla de registro los datos relativos al nuevo usuario (nombre de usuario y contrase√±a) y confirmando la operaci√≥n. En este caso, se ha introducido como nombre de usuario ‚Äúa‚Äù y como contrase√±a ‚Äúa‚Äù, se incorporan adem√°s <strong>asserts</strong> para comprobar que las credenciales son las esperadas. 

Una vez se ha registrado el usuario, se introducen sus credenciales en la pantalla de inicio sesi√≥n para acceder a las funcionalidades de la aplicaci√≥n confirmando el inicio haciendo clic en el bot√≥n de ‚ÄúIniciar sesi√≥n‚Äù, lo que llevar√° a la pantalla principal. En ella, se crea un nuevo evento de municipio pulsando en el floating button situado en la parte inferior derecha. Se rellenan los campos del formulario y se confirma la creaci√≥n. En la siguiente pantalla de detalles, se pulsa en el bot√≥n ‚ÄúModificar‚Äù y se modifican los datos del evento. Se cambia el t√≠tulo ‚Äúpadel‚Äù por ‚Äúpadelcomida‚Äù y se localiza el evento en Madrid. Se incorporan <strong>asserts</strong> para enriquecer el test y comprobar que los campos se han modificado correctamente. Con el objetivo de que otros test no dependan de √©ste, se elimina el nuevo evento modificado.

Se sigue el mismo proceso explicado anteriormente para un evento de tipo monta√±a, incorporando <strong>asserts</strong> correspondientes a los valores del evento modificado. Del mismo modo, al modificar el evento, se elimina de la aplicaci√≥n.

Finalmente, tras comprobar esto, se procede a borrar el usuario accediendo a la pantalla de ‚ÄúPerfil‚Äù del propio usuario y seleccionar la funcionalidad de eliminar el usuario registrado haciendo clic en el bot√≥n, lo que borrar√° el usuario de la base de datos y cerrar√° sesi√≥n.

### CU08 - Eliminar un evento <a name="testCU08"></a>

#### Test unitario <a name="testUnitarioCU08"></a>

El test unitario de este caso de uso es el del modelo **Evento**, el cual ha sido implementado en el CU01.

#### Test funcional <a name="testFuncionalCU08"></a>

Se crea una clase **EliminarEventoTest** en el paquete AndroidTest para testear el funcionamiento de la Interfaz de usuario al eliminar un evento en la aplicaci√≥n. Este m√©todo se ha creado a partir de la grabadora de Espresso, incorporada en Android Studio. 

Este test consiste en lo siguiente: primero se registra un nuevo usuario introduciendo en la pantalla de registro los datos relativos al nuevo usuario (nombre de usuario y contrase√±a) y confirmando la operaci√≥n. En este caso, se ha introducido como nombre de usuario ‚ÄúJorge‚Äù y como contrase√±a ‚Äú1234‚Äù, se incorporan adem√°s <strong>asserts</strong> para comprobar que las credenciales son las esperadas. 

Una vez se ha registrado el usuario, se introducen sus credenciales en la pantalla de inicio sesi√≥n para acceder a las funcionalidades de la aplicaci√≥n confirmando el inicio haciendo clic en el bot√≥n de ‚ÄúIniciar sesi√≥n‚Äù, lo que llevar√° a la pantalla de inicio.

Tras llegar a la pantalla principal, se pulsa el floating button para crear un nuevo evento. Aparece una pantalla de elecci√≥n del tipo de evento a crear, se elige el de tipo de evento llamado Municipio. 

Esto mostrar√° la pantalla de creaci√≥n, donde se piden todos los datos del evento, en este caso se introducir√° como nombre del evento ‚ÄúFutbol‚Äù, como localidad ‚ÄúSevilla‚Äù y como descripci√≥n ‚ÄúCon amigos‚Äù.

Se rellenan todos los campos del formulario asociado al nuevo evento y se confirma la creaci√≥n, apareciendo una pantalla de detalles. En este instante, se aplican <strong>asserts</strong> para enriquecer el test. 

A continuaci√≥n, se presiona el bot√≥n ‚Äúback‚Äù para comprobar que se ha incluido el nuevo evento en la lista de eventos, mediante un nuevo <strong>assert</strong>. 

Posteriormente, se vuelve a acceder a la pantalla de detalles del evento creado haciendo clic en el item del evento del recycler View.

Esto llevar√° a la pantalla para consultar este, donde se pulsar√° el bot√≥n para eliminar el evento, comprobando que tras esto lleva a la lista de eventos y que dicha lista est√° vac√≠a mediante un <strong>assert</strong>.

Posteriormente, se pulsa el floating button para crear un nuevo evento. Aparece una pantalla de elecci√≥n del tipo de evento a crear, se elige el de tipo de evento llamado Monta√±a. 

Esto mostrar√° la pantalla de creaci√≥n, donde se piden todos los datos del evento, en este caso se introducir√° como nombre del evento ‚ÄúSenderismo‚Äù y c√≥mo localidad ‚ÄúSierra nevada‚Äù.

Se rellenan todos los campos del formulario asociado al nuevo evento y se confirma la creaci√≥n, apareciendo una pantalla de detalles. En este instante, se aplican <strong>asserts</strong> para enriquecer el test. 

A continuaci√≥n, se presiona el bot√≥n ‚Äúback‚Äù para comprobar que se ha incluido el nuevo evento en la lista de eventos, mediante un nuevo <strong>assert</strong>.

M√°s tarde, se vuelve a acceder a la pantalla de detalles del evento creado haciendo clic en el item del evento del recycler View.

Esto llevar√° a la pantalla para consultar este, donde se pulsar√° el bot√≥n para eliminar el evento, comprobando que tras esto lleva a la lista de eventos y que dicha lista est√° vac√≠a mediante un <strong>assert</strong>.

Finalmente, tras comprobar esto, se procede a borrar el usuario accediendo a la pantalla de ‚ÄúPerfil‚Äù del propio usuario y seleccionar la funcionalidad de eliminar el usuario registrado haciendo clic en el bot√≥n, lo que borrar√° el usuario de la base de datos y cerrar√° sesi√≥n.

## Equipo 3 (Se√±or Naranja) <a name="testEquipo3"></a>

### CU09 - Consultar tiempo meteorol√≥gico en la ubicaci√≥n actual <a name="testCU09"></a>

#### Test unitario <a name="testUnitarioCU09"></a>

El test unitario de este caso de uso es el del modelo **Weather**, el cual ha sido implementado en el CU06.

#### Test funcional <a name="testFuncionalCU09"></a>

Se crea una clase <strong>TiempoActualTest</strong> en el paquete AndroidTest para testear el funcionamiento de la Interfaz de usuario al mostrar el tiempo de la localizaci√≥n actual en la aplicaci√≥n. Este m√©todo se ha creado a partir de la grabadora de Espresso, incorporada en Android Studio. 

Para llevar a cabo este test, primero se ha registrado un usuario en la aplicaci√≥n, introduciendo en la pantalla de registro los datos relativos al nuevo usuario (nombre de usuario y contrase√±a) y confirmando la operaci√≥n. En este caso, se ha introducido como nombre de usuario ‚ÄúLuis‚Äù y como contrase√±a ‚Äú123456‚Äù.

Una vez se ha registrado el usuario, se introducen sus credenciales en la pantalla de inicio sesi√≥n para acceder a las funcionalidades de la aplicaci√≥n confirmando el inicio haciendo clic en el bot√≥n de ‚ÄúIniciar sesi√≥n‚Äù, lo que llevar√° a la pantalla de inicio.

Al llegar a la pantalla principal, se comprueba que el tiempo actual se muestra correctamente en esta (en la parte superior de la pantalla) comprobando mediante **asserts** que los valores que se encuentran en el cuadro del tiempo actual son distintos de los valores por defecto.

Finalmente, tras comprobar esto, se procede a borrar el usuario accediendo a la pantalla de ‚ÄúPerfil‚Äù del propio usuario y seleccionar la funcionalidad de eliminar el usuario registrado haciendo clic en el bot√≥n, lo que borrar√° el usuario de la base de datos y cerrar√° sesi√≥n.

### CU10 - Modificar idioma y tema a modo oscuro <a name="testCU10"></a>

#### Test unitario <a name="testUnitarioCU10"></a>

En este caso de uso no se ha implementado ning√∫n test unitario.

#### Test funcional <a name="testFuncionalCU10"></a>

Se crea una clase <strong>ModoOscuroTest</strong> en el paquete AndroidTest para testear el funcionamiento del modo oscuro o claro en la aplicaci√≥n. Este m√©todo se ha creado a partir de la grabadora de Espresso, incorporada en Android Studio. 

Para llevar a cabo este test, primero se ha registrado un usuario en la aplicaci√≥n, introduciendo en la pantalla de registro los datos relativos al nuevo usuario (nombre de usuario y contrase√±a) y confirmando la operaci√≥n. En este caso, se ha introducido como nombre de usuario ‚Äúpepe‚Äù y como contrase√±a ‚Äúpepe‚Äù.

Una vez se ha registrado el usuario, se introducen sus credenciales en la pantalla de inicio sesi√≥n para acceder a las funcionalidades de la aplicaci√≥n confirmando el inicio haciendo clic en el bot√≥n de ‚ÄúIniciar sesi√≥n‚Äù, lo que llevar√° a la pantalla de inicio.

Tras iniciar sesi√≥n, se accede a la pesta√±a de ajustes a trav√©s del panel lateral de navegaci√≥n para cambiar el tema modo claro, navegando posteriormente a la pesta√±a de Perfil del panel lateral de navegaci√≥n, regresando despu√©s a la pesta√±a de ajustes para cambiar de nuevo el tema a modo oscuro.
Finalmente, tras comprobar esto, se procede a borrar el usuario accediendo a la pantalla de ‚ÄúPerfil‚Äù del propio usuario y tras comprobar mediante un **assert** que el color del nombre de usuario es el del valor del azul oscuro (R.color.Azul_osc), selecciona la funcionalidad de eliminar el usuario registrado haciendo clic en el bot√≥n, lo que borrar√° el usuario de la base de datos y cerrar√° sesi√≥n.

### CU11 - Consultar lista de eventos <a name="testCU11"></a>

#### Test unitario <a name="testUnitarioCU11"></a>

El test unitario de este caso de uso es el del modelo **Evento**, el cual ha sido implementado en el CU01.

#### Test funcional <a name="testFuncionalCU11"></a>

Se crea una clase **ListarEventosTest** en el paquete AndroidTest para testear el funcionamiento de la Interfaz de usuario al realizar una b√∫squeda de una localizaci√≥n en la aplicaci√≥n. Este m√©todo se ha creado a partir de la grabadora de Espresso, incorporada en Android Studio. 

Para llevar a cabo este test, en primer lugar se han creado 4 eventos accediendo al eventoDAO de la base de datos, siendo los nombres de estos ‚Äúcena1‚Äù, ‚Äúcena2‚Äù, ‚Äúcena3‚Äù y ‚Äúcena4‚Äù, con ‚ÄúMadrid‚Äù como localizaciones y con ‚ÄúCa√±as‚Äù como descripciones, insertando estos eventos en la base de datos.

Posteriormente se ha registrado un usuario en la aplicaci√≥n, introduciendo en la pantalla de registro los datos relativos al nuevo usuario (nombre de usuario y contrase√±a) y confirmando la operaci√≥n. En este caso, se ha introducido como nombre de usuario ‚ÄúMiguel‚Äù y como contrase√±a ‚Äúmiguel‚Äù.

Una vez se ha registrado el usuario, se introducen sus credenciales en la pantalla de inicio sesi√≥n para acceder a las funcionalidades de la aplicaci√≥n confirmando el inicio haciendo clic en el bot√≥n de ‚ÄúIniciar sesi√≥n‚Äù, lo que llevar√° a la pantalla de inicio.

Tras llegar a la pantalla principal, se comprueba mediante <strong>asserts</strong> que todos los eventos creados se muestran en la pantalla de inicio, siendo estos 4 eventos de municipio.

Finalmente, tras comprobar esto, se procede a borrar el usuario accediendo a la pantalla de ‚ÄúPerfil‚Äù del propio usuario y seleccionar la funcionalidad de eliminar el usuario registrado haciendo clic en el bot√≥n, lo que borrar√° el usuario de la base de datos y cerrar√° sesi√≥n.

### CU12 - Consultar un evento <a name="testCU12"></a>

#### Test unitario <a name="testUnitarioCU12"></a>

El test unitario de este caso de uso es el del modelo **Evento**, el cual ha sido implementado en el CU01.

#### Test funcional <a name="testFuncionalCU12"></a>

Se crea una clase <strong>ConsultarEventoTest</strong> en el paquete AndroidTest para testear el funcionamiento de la Interfaz de usuario al consultar los detalles de un evento en la aplicaci√≥n. Este m√©todo se ha creado a partir de la grabadora de Espresso, incorporada en Android Studio. 

Para llevar a cabo este test, primero se ha registrado un usuario en la aplicaci√≥n, introduciendo en la pantalla de registro los datos relativos al nuevo usuario (nombre de usuario y contrase√±a) y confirmando la operaci√≥n. En este caso, se ha introducido como nombre de usuario ‚ÄúJorge‚Äù y como contrase√±a ‚Äú1234‚Äù.

Una vez se ha registrado el usuario, se introducen sus credenciales en la pantalla de inicio sesi√≥n para acceder a las funcionalidades de la aplicaci√≥n confirmando el inicio haciendo clic en el bot√≥n de ‚ÄúIniciar sesi√≥n‚Äù, lo que llevar√° a la pantalla de inicio.

Se crea un nuevo evento en la aplicaci√≥n de tipo Municipio, con el t√≠tulo ‚ÄúFutbol‚Äù y localizado en Sevilla, siendo la descripci√≥n del evento ‚Äúcon amigos‚Äù. Al confirmar la creaci√≥n, se realizan asserts para comprobar que los campos que se han rellenado en el test son correctos. En √∫ltima instancia de este evento, se elimina para limpiar la aplicaci√≥n.

A continuaci√≥n, se realiza el mismo proceso para los eventos de tipo Monta√±a. Se rellena el formulario asociado al nuevo evento y se comenten **asserts**, para enriquecer el test. En √∫ltima instancia de este evento, se elimina para limpiar la aplicaci√≥n.

Finalmente, tras comprobar esto, se procede a borrar el usuario accediendo a la pantalla de ‚ÄúPerfil‚Äù del propio usuario y seleccionar la funcionalidad de eliminar el usuario registrado haciendo clic en el bot√≥n, lo que borrar√° el usuario de la base de datos y cerrar√° sesi√≥n.

## Equipo 4 (Se√±or Azul) <a name="testEquipo4"></a>

### CU13 - Iniciar sesi√≥n <a name="testCU13"></a>

#### Test unitario <a name="testUnitarioCU13"></a>

El test unitario de este caso de uso es el del modelo **Usuario**, el cual ha sido implementado en el CU03.

#### Test funcional <a name="testFuncionalCU13"></a>

Se crea una clase **IniciarSesionTest** en el paquete AndroidTest para testear el funcionamiento de la Interfaz de usuario al iniciar sesi√≥n en la aplicaci√≥n. Este m√©todo se ha creado a partir de la grabadora de Espresso, incorporada en Android Studio. 

Para llevar a cabo este test, primero se ha registrado un usuario en la aplicaci√≥n, introduciendo en la pantalla de registro los datos relativos al nuevo usuario (nombre de usuario y contrase√±a) y confirmando la operaci√≥n. En este caso, se ha introducido como nombre de usuario ‚ÄúJorge‚Äù y como contrase√±a ‚Äú1234‚Äù.

Una vez se ha registrado el usuario, se introducen sus credenciales en la pantalla de inicio sesi√≥n para acceder a las funcionalidades de la aplicaci√≥n confirmando el inicio haciendo clic en el bot√≥n de ‚ÄúIniciar sesi√≥n‚Äù, lo que llevar√° a la pantalla de inicio.
Finalmente, tras comprobar esto, se procede a borrar el usuario accediendo a la pantalla de ‚ÄúPerfil‚Äù del propio usuario y seleccionar la funcionalidad de eliminar el usuario registrado haciendo clic en el bot√≥n, lo que borrar√° el usuario de la base de datos y cerrar√° sesi√≥n.

### CU14 - Cerrar sesi√≥n <a name="testCU14"></a>

#### Test unitario <a name="testUnitarioCU14"></a>

El test unitario de este caso de uso es el del modelo **Usuario**, el cual ha sido implementado en el CU03.

#### Test funcional <a name="testFuncionalCU14"></a>

Se crea una clase **CerrarSesionTest** en el paquete AndroidTest para testear el funcionamiento de la Interfaz de usuario al cerrar la sesi√≥n actual en la aplicaci√≥n. Este m√©todo se ha creado a partir de la grabadora de Espresso, incorporada en Android Studio. 

Este test consiste en lo siguiente: primero se registra un nuevo usuario con una credenciales,  y se inicia sesi√≥n en la aplicaci√≥n. En la pantalla principal, en el AppBar (barra de opciones situada en la parte superior de la pantalla) se pulsa en el icono ‚ÄúCerrar Sesi√≥n‚Äù situado en la esquina superior derecha, cerr√°ndose la sesi√≥n y retornando en la pantalla de inicio de sesi√≥n.

Para que el test no dependa de otros, finalmente se procede a borrar el usuario accediendo a la pantalla de ‚ÄúPerfil‚Äù del propio usuario y seleccionar la funcionalidad de eliminar el usuario registrado haciendo clic en el bot√≥n, lo que borrar√° el usuario de la base de datos y cerrar√° sesi√≥n.

### CU15 - Modificar usuario <a name="testCU15"></a>

#### Test unitario <a name="testUnitarioCU15"></a>

El test unitario de este caso de uso es el del modelo **Usuario**, el cual ha sido implementado en el CU03.

#### Test funcional <a name="testFuncionalCU15"></a>

Se crea una clase <strong>ModificarUsuarioTest</strong> en el paquete AndroidTest para testear el funcionamiento de la Interfaz de usuario al modificar el usuario en la aplicaci√≥n. Este m√©todo se ha creado a partir de la grabadora de Espresso, incorporada en Android Studio. 

Este test consiste en lo siguiente: primero se registra un nuevo usuario con una credenciales,  y se inicia sesi√≥n en la aplicaci√≥n. 

En la pantalla principal, se navega por el men√∫ de hamburguesa a la opci√≥n ‚ÄúPerfil‚Äù. Dentro de ella, aparece un formulario con los campos asociados a las credenciales de la cuenta de usuario con la sesi√≥n iniciada. Por defecto, el campo asociado al ‚Äúusername‚Äù queda cargado por el valor actual que tenga la cuenta y se modifica por el usuario ‚Äújuan‚Äù. A continuaci√≥n, se a√±ade la contrase√±a actual ‚Äúpepe‚Äù y se incorpora una nueva contrase√±a llamada ‚Äújuan‚Äù. Se pulsa en el bot√≥n ‚ÄúModificar‚Äù y aparece la pantalla principal. Para comprobar que la modificaci√≥n se ha realizado correctamente, se vuelve a los ajustes de perfil en el men√∫ hamburguesa y se incorpora un **assert** para comprobar que el usuario se ha modificado correctamente.

Finalmente, tras comprobar esto, se procede a borrar el usuario accediendo a la pantalla de ‚ÄúPerfil‚Äù del propio usuario y seleccionar la funcionalidad de eliminar el usuario registrado haciendo clic en el bot√≥n, lo que borrar√° el usuario de la base de datos y cerrar√° sesi√≥n.

### CU16 - Eliminar usuario <a name="testCU16"></a>

#### Test unitario <a name="testUnitarioCU16"></a>

El test unitario de este caso de uso es el del modelo **Usuario**, el cual ha sido implementado en el CU03.

#### Test funcional <a name="testFuncionalCU16"></a>

Se crea una clase **EliminarUsuarioTest** en el paquete AndroidTest para testear el funcionamiento de la Interfaz de usuario al eliminar el usuario en la aplicaci√≥n. Este m√©todo se ha creado a partir de la grabadora de Espresso, incorporada en Android Studio. 

Este test consiste en lo siguiente: primero se registra un nuevo usuario con una credenciales,  y se inicia sesi√≥n en la aplicaci√≥n. En la pantalla principal, se navega por el men√∫ de hamburguesa a la opci√≥n ‚ÄúPerfil‚Äù. Dentro de ella, se pulsa el bot√≥n ‚ÄúEliminar‚Äù para eliminar la cuenta de usuario. 

Para comprobar que la eliminaci√≥n se ha realizado correctamente, se busca iniciar sesi√≥n con las mismas credenciales del usuario borrado, sin tener ning√∫n efecto, comprobando as√≠ que el caso de uso funciona correctamente.

## Arreglo de errores <a name="arregloErrores"></a>
A partir de la implementaci√≥n y observaci√≥n de los test, se han cometido los siguientes arreglos:
* Se ha incluido un constructor por defecto, no parametrizado en la clase Evento, Municipio, Usuario y Montana.
* Al eliminar una cuenta de usuario, se ha incorporado el borrado de todos sus eventos asociados.
* Se ha modificado en el layout fragment_crear_evento_montana.xml un atributo del EditText de la fecha llamado focusable. Incorporaba un fallo puesto que al querer elegir la fecha de un nuevo evento, se ten√≠a que pulsar dos veces en el EditText. Por tanto, se le ha asociado el valor ‚Äúfalse‚Äù al focusable.
Se ha arreglado un error del CU Modificar Evento, espec√≠ficamente en la clase ModificarEventoMunicipioFragment. Se actualiza la vista en un Thread secundario, cuando s√≥lo se puede modificar en el hilo principal. Por tanto, se ha incorporado un requireActivity().runOnUiThread() para solventar el problema.
* Se ha modificado el acceso p√∫blico  a los atributos de la clase Weather, restringiendo el acceso a privado. Este arreglo ha supuesto unas peque√±as modificaciones en 4 componentes software (fragmentos y actividades, entre ellos), debido a la incorporaci√≥n de los getter/setters en la clase Weather.

# An√°lisis de la calidad <a name="gestionCalidad"></a>
En este apartado se ha realizado un proceso de an√°lisis y gesti√≥n de calidad del proyecto desarrollado a lo largo de todas estas entregas, de manera que se compruebe si la calidad de este proyecto es aceptable, as√≠ como corregir el proyecto para mejorarla en caso contrario.

Para ello se utilizar√° la herramienta <strong>SonarQube</strong>, que permite detectar e identificar posibles fallos para mejorar la calidad de un proyecto, as√≠ como si esta es aceptable o no, o en su defecto <strong>SonarCloud</strong>, que consiste en su versi√≥n online.

En concreto, se debe utilizar esa herramienta para realizar un an√°lisis de la calidad de la versi√≥n actual del proyecto e identificar los posibles fallos que pueda presentar esta, tratando de mejorar la calidad corrigiendo 2 de los fallos indicados por cada uno de los integrantes del grupo.

Posteriormente, se publicar√°n las versiones con fallos corregidos en nuevas ramas (una por cada incidencia) y se integrar√°n estas, de manera que se compilar de nuevo el repositorio y comprobar que los los fallos se han solucionado.

De esta forma, se demuestra que la herramienta permite realizar correctamente un an√°lisis de calidad del proyecto para identificar correctamente los fallos de calidad y corregirlos.

En este caso, se emplear√° la herramienta de SonarCloud, utiliz√°ndola de forma online a trav√©s de las Github Actions.

## Caracter√≠sticas de SonarCloud <a name="caracteristicasSonarCloud"></a>

SonarCloud es una plataforma en l√≠nea creada por SonarSource que ofrece an√°lisis de c√≥digo y herramientas de colaboraci√≥n para desarrolladores de software. 

Ayuda a los equipos de desarrollo a mejorar la calidad del c√≥digo y a identificar problemas de seguridad y de cumplimiento normativo, entre otras cosas. Tambi√©n ofrece integraciones con diferentes herramientas de desarrollo y sistemas de control de versiones para facilitar su uso en el flujo de trabajo de un equipo.

## Pasos para gestionar la calidad <a name="pasosGestionCalidad"></a>

Para realizar esta pr√°ctica, se seguir√°n los siguientes pasos:
* Compilar la rama actual sobre la que se encuentra la √∫ltima versi√≥n del proyecto desde github (utilizando github Actions), para analizar la calidad del proyecto y comprobar si tiene errores.
* Tras el an√°lisis, seleccionar 2 puntos de mejora de calidad indicados por SonarCloud para cada integrante del grupo y tratar de mejorarlos, implementando dichas mejoras en una rama por cada correcci√≥n.
* Integrar las ramas correspondientes a develop, y a su vez develop en la rama main.
* Tras aplicar las correcciones implementadas al proyecto, comprobar si estas han solucionado los fallos de calidad que presentaba este compilando de nuevo la rama del proyecto utilizando SonarCloud.

De esta forma, se espera que las correcciones implementadas solucionen los fallos detectados por SonarCloud y que el nuevo an√°lisis realizado refleje esto.

## Repositorios utilizados <a name="repositoriosUtilizados"></a>
Para llevar a cabo el an√°lisis de calidad, se ha utilizado el repositorio con el c√≥digo del proyecto (ubicado en Github) cuyo enlace es el siguiente: <a href="https://github.com/UniExtremadura/proyecto-gps-asee-2022-23-ga04">https://github.com/UniExtremadura/proyecto-gps-asee-2022-23-ga04</a>.

Este se ha a√±adido al repositorio de SonarCloud con el nombre de ‚Äúapp‚Äù, que se puede encontrar en el siguiente enlace: <a href="https://sonarcloud.io/project/overview?id=UniExtremadura_proyecto-gps-asee-2022-23-ga04">https://sonarcloud.io/project/overview?id=UniExtremadura_proyecto-gps-asee-2022-23-ga04</a> 

## Detecci√≥n de fallos <a name="calidadGestionFallos"></a>

En esta primera fase se llevar√° a cabo un an√°lisis inicial de la calidad del proyecto, realizando un proceso de compilaci√≥n del proyecto en la p√°gina oficial de SonarCloud (<a href="https://sonarcloud.io/">https://sonarcloud.io/</a>).

<img src="https://i.imgur.com/0mwXLC8.png" />

Para ello, en primer lugar es necesario a√±adir el proyecto a SonarCloud para poder hacer el an√°lisis. Cabe destacar que para que se pueda importar el proyecto es necesario que el repositorio sea p√∫blico y ser el administrador del mismo, sincronizando SonarCloud con la cuenta correspondiente de GitHub del administrador. 

<img src="https://i.imgur.com/kGiPfuw.png" />

## Problemas solventados <a name="problemasSolventados"></a>

Cada miembro del equipo se ha encargado de resolver dos incidencias en base al an√°lisis de calidad de c√≥digo completado mediante las Github Actions, las cuales utilizan gradle y java para enviar los resultados del an√°lisis a SonarCloud.

### An√°lisis del Sr. Blanco <a name="calidadSrBlanco"></a>

El an√°lisis base sobre el que se parte para resolver las dos incidencias del <strong>Sr. Blanco</strong> es el siguiente:

<img src="https://i.imgur.com/oXWyfx4.png" />

Se puede observar c√≥mo existen 580 Code Smells o incidencias de mantenibilidad. Las dos incidencias resueltas por el Sr. Blanco son las siguientes:

<img src="https://i.imgur.com/I02kTea.png" />

Una vez incorporados los dos commits de las dos incidencias a la rama develop y hecha la integraci√≥n a la rama main, se lanzan las github actions para enviar el an√°lisis a SonarCloud con las dos incidencias resueltas. El an√°lisis resultante al resolver las dos incidencias son las siguientes:

<img src="https://i.imgur.com/JlzhG8T.png" />

### An√°lisis del Sr. Marr√≥n <a name="calidadSrMarron"></a>

An√°lisis Previo a resolver las incidencias:
<img src="https://i.imgur.com/GCHi0Az.png" />

Mi integraci√≥n de las dos incidencias resueltas se realiz√≥ en dos fases (<strong>push</strong>) a main, pues fui el primero del equipo en aprender a utilizar Sonar. Por eso aparecen dos an√°lisis, en los cuales se observa que se ha resuelto una incidencia en cada uno.

<img src="https://i.imgur.com/p7OlZM0.png" />

An√°lisis Posterior a la resoluci√≥n de las incidencias:
<img src="https://i.imgur.com/NkK83MN.png" />

Se observa que hay dos incidencias menos de Mantenibilidad.

### An√°lisis del Sr. Azul <a name="calidadSrAzul"></a>

El an√°lisis base sobre el que se parte para resolver las dos incidencias del <strong>Sr. Azul</strong> es el siguiente:

<img src="https://imgur.com/KHZnYpV.png" />

Se puede observar c√≥mo existen 576 Code Smells o incidencias de mantenibilidad. Las dos incidencias resueltas por el **Sr. Azul** son las siguientes: 

<img src="https://imgur.com/h7Fc8CL.png" />

Una vez incorporados los dos commits de las dos incidencias a la rama develop y hecha la integraci√≥n a la rama main, se lanzan las github actions para enviar el an√°lisis a SonarCloud con las dos incidencias resueltas.

<img src="https://imgur.com/vkSGeFZ.png" /> 
<img src="https://imgur.com/LViIRvI.png" /> 

El an√°lisis resultante al resolver las dos incidencias son las siguientes:

<img src="https://imgur.com/qdZptfO.png" /> 

Se puede observar que el an√°lisis de calidad muestra 574 Code Smells o incidencias de mantenibilidad, indicando que se han podido resolver correctamente las dos anteriores.

### An√°lisis del Sr. Naranja <a name="calidadSrNaranja"></a>

El an√°lisis base sobre el que se parte para resolver las dos incidencias del **Sr. Naranja** es el siguiente:

<img src="https://i.imgur.com/LZMvmB7.png" />

Se puede observar c√≥mo existen 578 Code Smells o incidencias de mantenibilidad. Las dos incidencias resueltas por el Sr. Blanco son las siguientes:

<img src="https://i.imgur.com/ekn2bDg.png" />

Tras esto, una vez incorporados los dos commits de las dos incidencias a la rama develop y hecha la integraci√≥n a la rama main, se lanzan las github actions para enviar el an√°lisis a SonarCloud con las dos incidencias resueltas. El an√°lisis resultante al resolver las dos incidencias son las siguientes:

<img src="https://i.imgur.com/62naat1.png" />

Se puede observar que el an√°lisis de calidad muestra 576 Code Smells o incidencias de mantenibilidad, indicando que se han podido resolver correctamente las anteriores.

# Reflexi√≥n <a name="reflexion"></a>    
Desarrollar una aplicaci√≥n Android es un proyecto muy interesante y desafiante que puede proporcionar gran satisfacci√≥n al ver tu trabajo en uso en dispositivos m√≥viles. Consideramos que tanto la asignatura de ASEE como GPS son las primeras de la carrera que nos han proporcionado un m√©todo realista para nuestro futuro laboral en el desarrollo de aplicaciones Android y gesti√≥n de proyectos.

ASEE nos ha brindado una nueva perspectiva de programaci√≥n diferente a la que ven√≠amos acostumbrados. Android Studio es un framework con infinidad de configuraciones y es muy flexible a las necesidades del programador. Adem√°s, nos hemos visto empapados de la tecnolog√≠a Git durante el desarrollo de la app. A pesar de conocer el controlador de versiones de cursos anteriores, es recomendable recordar y afianzar conceptos de Git asiduamente. 

No nos podemos olvidar de GPS, un conjunto de conocimientos que hemos adquirido sobre la gesti√≥n y metodolog√≠a de desarrollo de un proyecto. Junto con Android Studio, se suman herramientas populares como JIRA, Slack, Github Actions, SonarCloud, JUnit, Espresso, Mokito, etc. Aun cuando las asignaturas han significado una de las m√°s intensas y extensas cargas de trabajo en todo el grado de ingenier√≠a inform√°tica, estamos en lo cierto que todo el esfuerzo dedicado ha merecido la pena, aunque siempre se puede dedicar un poco m√°s de tiempo a perfeccionar las ideas de la aplicaci√≥n (en referencia a la interfaz).

En resumen, desarrollar una aplicaci√≥n Android es un proyecto que requiere de mucho esfuerzo, tiempo y dedicaci√≥n, pero puede ser muy gratificante echar la vista atr√°s y ver el proceso seguido para crear la versi√≥n final.